<!doctype html>
<!-- Until the CSS is loaded and the server sends us the theme colors, make the background dark so
that dark mode users don't get flashbanged by a completely white screen -->
<html data-theme="dark" style="background: #333">
    <head>
        <title>{title}</title>
        <link rel="icon" type="image/x-icon" href="/rio/favicon.png" />

        <!-- <link rel="stylesheet" type="text/css" href="/rio/asset/highlightjs-default-light.css"> -->

        <script type="module" crossorigin>
            (function polyfill() {
                const relList = document.createElement('link').relList;
                if (
                    relList &&
                    relList.supports &&
                    relList.supports('modulepreload')
                ) {
                    return;
                }
                for (const link of document.querySelectorAll(
                    'link[rel="modulepreload"]'
                )) {
                    processPreload(link);
                }
                new MutationObserver((mutations) => {
                    for (const mutation of mutations) {
                        if (mutation.type !== 'childList') {
                            continue;
                        }
                        for (const node of mutation.addedNodes) {
                            if (
                                node.tagName === 'LINK' &&
                                node.rel === 'modulepreload'
                            )
                                processPreload(node);
                        }
                    }
                }).observe(document, { childList: true, subtree: true });
                function getFetchOpts(link) {
                    const fetchOpts = {};
                    if (link.integrity) fetchOpts.integrity = link.integrity;
                    if (link.referrerPolicy)
                        fetchOpts.referrerPolicy = link.referrerPolicy;
                    if (link.crossOrigin === 'use-credentials')
                        fetchOpts.credentials = 'include';
                    else if (link.crossOrigin === 'anonymous')
                        fetchOpts.credentials = 'omit';
                    else fetchOpts.credentials = 'same-origin';
                    return fetchOpts;
                }
                function processPreload(link) {
                    if (link.ep) return;
                    link.ep = true;
                    const fetchOpts = getFetchOpts(link);
                    fetch(link.href, fetchOpts);
                }
            })();
            const style = '';
            async function registerFont(name, urls) {
                const VARIATIONS = [
                    { weight: 'normal', style: 'normal' },
                    { weight: 'bold', style: 'normal' },
                    { weight: 'normal', style: 'italic' },
                    { weight: 'bold', style: 'italic' },
                ];
                let promises = /* @__PURE__ */ new Map();
                for (let [i, url] of urls.entries()) {
                    if (url === null) {
                        continue;
                    }
                    let fontFace = new FontFace(
                        name,
                        `url(${url})`,
                        VARIATIONS[i]
                    );
                    promises.set(url, fontFace.load());
                }
                let numSuccesses = 0;
                let numFailures = 0;
                for (let [url, promise] of promises.entries()) {
                    let fontFace;
                    try {
                        fontFace = await promise;
                    } catch (error2) {
                        numFailures++;
                        console.warn(
                            `Failed to load font file ${url}: ${error2}`
                        );
                        continue;
                    }
                    numSuccesses++;
                    document.fonts.add(fontFace);
                }
                if (numFailures === 0) {
                    console.log(
                        `Successfully registered all ${numSuccesses} variations of font ${name}`
                    );
                } else if (numSuccesses === 0) {
                    console.warn(
                        `Failed to register all ${numFailures} variations of font ${name}`
                    );
                } else {
                    console.warn(
                        `Successfully registered ${numSuccesses} variations of font ${name}, but failed to register ${numFailures} variations`
                    );
                }
            }
            function requestFileUpload(message) {
                let input = document.createElement('input');
                input.type = 'file';
                input.multiple = message.multiple;
                if (message.fileExtensions !== null) {
                    input.accept = message.fileExtensions.join(',');
                }
                input.style.display = 'none';
                function finish() {
                    if (input.parentElement === null) {
                        return;
                    }
                    const data = new FormData();
                    for (const file of input.files || []) {
                        data.append('file_names', file.name);
                        data.append('file_types', file.type);
                        data.append('file_sizes', file.size.toString());
                        data.append('file_streams', file, file.name);
                    }
                    data.append('dummy', 'dummy');
                    fetch(message.uploadUrl, {
                        method: 'PUT',
                        body: data,
                    });
                    input.remove();
                }
                input.addEventListener('change', finish);
                window.addEventListener(
                    'focus',
                    function () {
                        this.window.setTimeout(finish, 500);
                    },
                    { once: true }
                );
                document.body.appendChild(input);
                input.click();
            }
            function setTitle(title) {
                document.title = title;
            }
            function closeSession() {
                window.close();
            }
            class AsyncQueue {
                constructor() {
                    this.waitingForValue = [];
                    this.values = [];
                }
                push(value) {
                    let notifyFirstWaiter = this.waitingForValue.shift();
                    if (notifyFirstWaiter !== void 0) {
                        notifyFirstWaiter(value);
                        return;
                    }
                    this.values.push(value);
                }
                async get() {
                    let value = this.values.shift();
                    if (value !== void 0) {
                        return value;
                    }
                    let waitForValue = new Promise((resolve) => {
                        this.waitingForValue.push(resolve);
                    });
                    return await waitForValue;
                }
            }
            function commitCss(element2) {
                element2.offsetHeight;
            }
            async function sleep(durationInSeconds) {
                await new Promise((resolve, reject) =>
                    setTimeout(resolve, durationInSeconds * 1e3)
                );
            }
            function reprElement(element2) {
                let chunks = [element2.tagName.toLowerCase()];
                for (let attr of element2.attributes) {
                    chunks.push(`${attr.name}=${JSON.stringify(attr.value)}`);
                }
                return `<${chunks.join(' ')}>`;
            }
            function range(start, end) {
                let result = [];
                for (let ii = start; ii < end; ii++) {
                    result.push(ii);
                }
                return result;
            }
            function firstDefined(...args) {
                for (let arg of args) {
                    if (arg !== void 0) {
                        return arg;
                    }
                }
                return void 0;
            }
            let websocket = null;
            let connectionAttempt = 1;
            let pingPongHandlerId;
            let incomingMessageQueue = new AsyncQueue();
            function setConnectionLostPopupVisibleUnlessGoingAway(visible) {
                if (goingAway) {
                    return;
                }
                let connectionLostPopup = document.querySelector(
                    '.rio-connection-lost-popup'
                );
                if (connectionLostPopup === null) {
                    return;
                }
                if (visible) {
                    connectionLostPopup.style.display = 'block';
                    commitCss(connectionLostPopup);
                    connectionLostPopup.classList.add(
                        'rio-connection-lost-popup-visible'
                    );
                } else {
                    connectionLostPopup.classList.remove(
                        'rio-connection-lost-popup-visible'
                    );
                    connectionLostPopup.style.display = 'none';
                }
            }
            globalThis.setConnectionLostPopupVisible =
                setConnectionLostPopupVisibleUnlessGoingAway;
            async function processMessages() {
                while (true) {
                    let message = await incomingMessageQueue.get();
                    let response = await processMessageReturnResponse(message);
                    if (response !== null) {
                        sendMessageOverWebsocket(response);
                    }
                }
            }
            processMessages();
            function createWebsocket() {
                if (goingAway) {
                    return;
                }
                let url = new URL(
                    `/rio/ws?sessionToken=${globalThis.SESSION_TOKEN}`,
                    window.location.href
                );
                url.protocol = url.protocol.replace('http', 'ws');
                console.log(`Connecting websocket to ${url.href}`);
                websocket = new WebSocket(url.href);
                websocket.addEventListener('open', onOpen);
                websocket.addEventListener('message', onMessage);
                websocket.addEventListener('error', onError);
                websocket.addEventListener('close', onClose);
            }
            function initWebsocket() {
                createWebsocket();
                websocket.addEventListener('open', sendInitialMessage);
            }
            function sendInitialMessage() {
                let userSettings = {};
                for (let key in localStorage) {
                    if (!key.startsWith('rio:userSetting:')) {
                        continue;
                    }
                    try {
                        userSettings[key.slice('rio:userSetting:'.length)] =
                            JSON.parse(localStorage[key]);
                    } catch (e) {
                        console.warn(
                            `Failed to parse user setting ${key}: ${e}`
                        );
                    }
                }
                let decimalSeparator = (1.1).toLocaleString().replace(/1/g, '');
                let thousandsSeparator = (1111)
                    .toLocaleString()
                    .replace(/1/g, '');
                sendMessageOverWebsocket({
                    websiteUrl: window.location.href,
                    preferredLanguages: navigator.languages,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    decimalSeparator,
                    thousandsSeparator,
                    userSettings,
                    prefersLightTheme: !window.matchMedia(
                        '(prefers-color-scheme: dark)'
                    ).matches,
                    windowWidth: window.innerWidth / pixelsPerRem,
                    windowHeight: window.innerHeight / pixelsPerRem,
                });
            }
            function onOpen() {
                console.log('Websocket connection opened');
                connectionAttempt = 1;
                setConnectionLostPopupVisibleUnlessGoingAway(false);
                pingPongHandlerId = setInterval(() => {
                    sendMessageOverWebsocket({
                        jsonrpc: '2.0',
                        method: 'ping',
                        params: ['ping'],
                        id: `ping-${Date.now()}`,
                    });
                }, globalThis.PING_PONG_INTERVAL_SECONDS * 1e3);
            }
            function onMessage(event) {
                let message = JSON.parse(event.data);
                console.log('Received message: ', JSON.parse(event.data));
                incomingMessageQueue.push(message);
            }
            function onError(event) {
                console.warn(`Websocket error`);
            }
            function onClose(event) {
                clearInterval(pingPongHandlerId);
                setConnectionLostPopupVisibleUnlessGoingAway(true);
                if (connectionAttempt >= 10 && !globalThis.RIO_DEBUG_MODE) {
                    console.warn(
                        `Websocket connection closed. Giving up trying to reconnect.`
                    );
                    return;
                }
                let delay;
                if (globalThis.RIO_DEBUG_MODE) {
                    delay = 0.5;
                } else {
                    delay = 2 ** connectionAttempt - 1;
                    delay = Math.min(delay, 300);
                }
                console.log(
                    `Websocket connection closed. Reconnecting in ${delay} seconds`
                );
                setTimeout(createWebsocket, delay * 1e3);
            }
            function sendMessageOverWebsocket(message) {
                if (!websocket) {
                    console.error(
                        `Attempted to send message, but the websocket is not connected: ${message}`
                    );
                    return;
                }
                console.log('Sending message: ', message);
                websocket.send(JSON.stringify(message));
            }
            function callRemoteMethodDiscardResponse(method, params) {
                sendMessageOverWebsocket({
                    jsonrpc: '2.0',
                    method,
                    params,
                });
            }
            async function processMessageReturnResponse(message) {
                if (message.method === void 0) {
                    return null;
                }
                let response;
                let responseIsError = false;
                switch (message.method) {
                    case 'updateComponentStates':
                        updateComponentStates(
                            message.params.deltaStates,
                            message.params.rootComponentId
                        );
                        if (globalThis.RIO_DEBUGGER !== null) {
                            let debuggerTree = globalThis.RIO_DEBUGGER;
                            debuggerTree.afterComponentStateChange(
                                message.params.deltaStates
                            );
                        }
                        response = null;
                        break;
                    case 'evaluateJavaScript':
                        try {
                            const func = new Function(
                                message.params.javaScriptSource
                            );
                            response = func();
                            if (response === void 0) {
                                response = null;
                            }
                        } catch (e) {
                            response = e.toString();
                            responseIsError = true;
                            console.warn(
                                `Uncaught exception in \`evaluateJavaScript\`: ${e}`
                            );
                        }
                        break;
                    case 'setKeyboardFocus':
                        let component =
                            componentsById[message.params.componentId];
                        component.grabKeyboardFocus();
                        response = null;
                        break;
                    case 'setTitle':
                        setTitle(message.params.title);
                        response = null;
                        break;
                    case 'requestFileUpload':
                        requestFileUpload(message.params);
                        response = null;
                        break;
                    case 'setUserSettings':
                        for (let key in message.params.deltaSettings) {
                            localStorage.setItem(
                                `rio:userSetting:${key}`,
                                JSON.stringify(
                                    message.params.deltaSettings[key]
                                )
                            );
                        }
                        response = null;
                        break;
                    case 'registerFont':
                        await registerFont(
                            message.params.name,
                            message.params.urls
                        );
                        response = null;
                        break;
                    case 'applyTheme':
                        for (let key in message.params.cssVariables) {
                            document.documentElement.style.setProperty(
                                key,
                                message.params.cssVariables[key]
                            );
                        }
                        document.documentElement.setAttribute(
                            'data-theme',
                            message.params.themeVariant
                        );
                        document.documentElement.style.background = '';
                        response = null;
                        break;
                    case 'invalidSessionToken':
                        console.error(
                            'Reloading the page because the session token is invalid'
                        );
                        window.location.reload();
                        response = null;
                        break;
                    case 'closeSession':
                        closeSession();
                        response = null;
                        break;
                    default:
                        throw `Encountered unknown RPC method: ${message.method}`;
                }
                if (message.id === void 0) {
                    return null;
                }
                let rpcResponse = {
                    jsonrpc: '2.0',
                    id: message.id,
                };
                if (responseIsError) {
                    rpcResponse['error'] = {
                        code: -32e3,
                        message: response,
                    };
                } else {
                    rpcResponse['result'] = response;
                }
                return rpcResponse;
            }
            class EventHandler {
                constructor(component) {
                    this.component = component;
                    component._eventHandlers.add(this);
                }
                disconnect() {
                    this.component._eventHandlers.delete(this);
                }
            }
            function _no_op() {
                return true;
            }
            class ClickHandler extends EventHandler {
                constructor(component, args) {
                    super(component);
                    this.onClick = args.onClick;
                    this.target = args.target ?? component.element;
                    this.capturing = args.capturing ?? false;
                    this.target.addEventListener(
                        'click',
                        this.onClick,
                        this.capturing
                    );
                }
                disconnect() {
                    super.disconnect();
                    this.target.removeEventListener(
                        'click',
                        this.onClick,
                        this.capturing
                    );
                }
            }
            class DragHandler extends EventHandler {
                constructor(component, args) {
                    super(component);
                    this.onMouseDown = this._onMouseDown.bind(this);
                    this.onMouseMove = this._onMouseMove.bind(this);
                    this.onMouseUp = this._onMouseUp.bind(this);
                    this.onClick = this._onClick.bind(this);
                    this.hasDragged = false;
                    this.element = args.element;
                    this.onStart = args.onStart ?? _no_op;
                    this.onMove = args.onMove ?? _no_op;
                    this.onEnd = args.onEnd ?? _no_op;
                    this.capturing = args.capturing ?? true;
                    this.element.addEventListener(
                        'mousedown',
                        this.onMouseDown,
                        this.capturing
                    );
                }
                _onMouseDown(event) {
                    console.debug('Drag: mouse down');
                    let onStartResult = this.onStart(event);
                    console.debug('Drag: onStart result', onStartResult);
                    if (onStartResult !== true && onStartResult !== false) {
                        throw new Error(
                            `Drag event onStart must return a boolean, but it returned ${onStartResult}`
                        );
                    }
                    if (!onStartResult) {
                        return;
                    }
                    console.debug('Drag: mouse down stop propagation');
                    event.stopPropagation();
                    window.addEventListener(
                        'mousemove',
                        this.onMouseMove,
                        true
                    );
                    window.addEventListener('mouseup', this.onMouseUp, true);
                    window.addEventListener('click', this.onClick, true);
                }
                _onMouseMove(event) {
                    console.debug('Drag: mouse move');
                    this.hasDragged = true;
                    event.stopPropagation();
                    this.onMove(event);
                }
                _onMouseUp(event) {
                    console.debug('Drag: mouse up');
                    if (this.hasDragged) {
                        console.debug('Preventing default due to drag');
                        event.stopPropagation();
                    }
                    this._disconnectDragListeners();
                    this.onEnd(event);
                }
                _onClick(event) {
                    console.debug('Drag: click');
                    if (this.hasDragged) {
                        console.debug('Preventing default due to drag');
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        event.preventDefault();
                    }
                }
                _disconnectDragListeners() {
                    window.removeEventListener(
                        'mousemove',
                        this.onMouseMove,
                        true
                    );
                    window.removeEventListener('mouseup', this.onMouseUp, true);
                    window.removeEventListener('click', this.onClick, true);
                }
                disconnect() {
                    super.disconnect();
                    this.element.removeEventListener(
                        'mousedown',
                        this.onMouseDown,
                        this.capturing
                    );
                    this._disconnectDragListeners();
                }
            }
            class ComponentBase {
                constructor(id, state) {
                    this.parent = null;
                    this.children = /* @__PURE__ */ new Set();
                    this._eventHandlers = /* @__PURE__ */ new Set();
                    this.id = id;
                    this.state = state;
                    this.element = this.createElement();
                    this.element.classList.add('rio-component');
                    this.isLayoutDirty = true;
                }
                /// Mark this element's layout as dirty, and chain up to the parent.
                makeLayoutDirty() {
                    let cur = this;
                    while (cur !== null && !cur.isLayoutDirty) {
                        cur.isLayoutDirty = true;
                        cur = cur.parent;
                    }
                }
                isInjectedLayoutComponent() {
                    return this.id < 0;
                }
                getParentExcludingInjected() {
                    let parent = this.parent;
                    while (true) {
                        if (parent === null) {
                            return null;
                        }
                        if (!parent.isInjectedLayoutComponent()) {
                            return parent;
                        }
                        parent = parent.parent;
                    }
                }
                unparent(latentComponents) {
                    console.assert(this.parent !== null);
                    this.parent.children.delete(this);
                    latentComponents.add(this);
                }
                registerChild(latentComponents, child) {
                    if (child.parent !== null) {
                        child.parent.children.delete(child);
                    }
                    child.parent = this;
                    this.children.add(child);
                    latentComponents.delete(child);
                }
                /// Appends the given child component at the end of the given HTML element.
                /// Does not remove or modify any existing children. If `childId` is
                /// `undefined`, does nothing.
                appendChild(
                    latentComponents,
                    childId,
                    parentElement = this.element
                ) {
                    if (childId === void 0) {
                        return;
                    }
                    let child = componentsById[childId];
                    parentElement.appendChild(child.element);
                    this.registerChild(latentComponents, child);
                    this.makeLayoutDirty();
                }
                /// Replaces the first child of the given HTML element with the given child.
                /// If `childId` is `null`, removes the current child. If `childId` is
                /// `undefined`, does nothing.
                replaceFirstChild(
                    latentComponents,
                    childId,
                    parentElement = this.element
                ) {
                    if (childId === void 0) {
                        return;
                    }
                    const currentChildElement = parentElement.firstElementChild;
                    if (childId === null) {
                        if (currentChildElement !== null) {
                            let child2 =
                                getComponentByElement(currentChildElement);
                            currentChildElement.remove();
                            child2.unparent(latentComponents);
                            this.makeLayoutDirty();
                        }
                        console.assert(
                            parentElement.firstElementChild === null
                        );
                        return;
                    }
                    if (currentChildElement !== null) {
                        let child2 = getComponentByElement(currentChildElement);
                        if (child2.id === childId) {
                            return;
                        }
                        currentChildElement.remove();
                        child2.unparent(latentComponents);
                    }
                    let child = componentsById[childId];
                    parentElement.appendChild(child.element);
                    this.registerChild(latentComponents, child);
                    this.makeLayoutDirty();
                }
                /// Replaces all children of the given HTML element with the given children.
                /// If `childIds` is `undefined`, does nothing.
                ///
                /// If `wrapInDivs` is true, each child is wrapped in a `<div>` element.
                /// This also requires any existing children to be wrapped in `<div>`s.
                replaceChildren(
                    latentComponents,
                    childIds,
                    parentElement = this.element,
                    wrapInDivs = false
                ) {
                    if (childIds === void 0) {
                        return;
                    }
                    let dirty = false;
                    let curElement = parentElement.firstElementChild;
                    let children = childIds.map((id) => componentsById[id]);
                    let curIndex = 0;
                    let wrap;
                    let unwrap;
                    if (wrapInDivs) {
                        wrap = (element2) => {
                            let wrapper = document.createElement('div');
                            wrapper.appendChild(element2);
                            return wrapper;
                        };
                        unwrap = (element2) => element2.firstElementChild;
                    } else {
                        wrap = (element2) => element2;
                        unwrap = (element2) => element2;
                    }
                    while (true) {
                        if (curElement === null) {
                            while (curIndex < children.length) {
                                let child = children[curIndex];
                                parentElement.appendChild(wrap(child.element));
                                this.registerChild(latentComponents, child);
                                dirty = true;
                                curIndex++;
                            }
                            break;
                        }
                        if (curIndex >= children.length) {
                            while (curElement !== null) {
                                let nextElement = curElement.nextElementSibling;
                                curElement.remove();
                                let childElement2 = unwrap(curElement);
                                if (childElement2 !== null) {
                                    let child =
                                        getComponentByElement(childElement2);
                                    child.unparent(latentComponents);
                                }
                                dirty = true;
                                curElement = nextElement;
                            }
                            break;
                        }
                        let childElement = unwrap(curElement);
                        if (childElement === null) {
                            let nextElement = curElement.nextElementSibling;
                            curElement.remove();
                            dirty = true;
                            curElement = nextElement;
                            continue;
                        }
                        let curChild = getComponentByElement(childElement);
                        let expectedChild = children[curIndex];
                        if (curChild === expectedChild) {
                            curElement = curElement.nextElementSibling;
                            curIndex++;
                            continue;
                        }
                        parentElement.insertBefore(
                            wrap(expectedChild.element),
                            curElement
                        );
                        this.registerChild(latentComponents, expectedChild);
                        curIndex++;
                        dirty = true;
                    }
                    if (dirty) {
                        this.makeLayoutDirty();
                    }
                }
                /// This method is called when a component is about to be removed from the
                /// component tree. It can be used for cleaning up event handlers and helper
                /// HTML elements (like popups).
                onDestruction() {
                    for (let handler of this._eventHandlers) {
                        handler.disconnect();
                    }
                }
                /// Send a message to the python instance corresponding to this component. The
                /// message is an arbitrary JSON object and will be passed to the instance's
                /// `_on_message` method.
                sendMessageToBackend(message) {
                    callRemoteMethodDiscardResponse('componentMessage', {
                        componentId: this.id,
                        payload: message,
                    });
                }
                _setStateDontNotifyBackend(deltaState) {
                    this.updateElement(deltaState, null);
                    this.state = {
                        ...this.state,
                        ...deltaState,
                    };
                }
                setStateAndNotifyBackend(deltaState) {
                    this._setStateDontNotifyBackend(deltaState);
                    callRemoteMethodDiscardResponse('componentStateUpdate', {
                        componentId: this.id,
                        deltaState,
                    });
                    if (globalThis.RIO_DEBUGGER !== null) {
                        let debuggerTree = globalThis.RIO_DEBUGGER;
                        debuggerTree.afterComponentStateChange({
                            componentIdString: deltaState,
                        });
                    }
                }
                addClickHandler(args) {
                    return new ClickHandler(this, args);
                }
                addDragHandler(args) {
                    return new DragHandler(this, args);
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 0;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 0;
                }
                updateAllocatedWidth(ctx) {}
                updateAllocatedHeight(ctx) {}
                toString() {
                    let class_name = this.constructor.name;
                    return `<${class_name} id:${this.id}>`;
                }
            }
            globalThis.RIO_COMPONENT_BASE = ComponentBase;
            class AlignComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                    this.makeLayoutDirty();
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth =
                        componentsById[this.state.content].requestedWidth;
                }
                updateAllocatedWidth(ctx) {
                    let child = componentsById[this.state.content];
                    if (this.state.align_x === null) {
                        child.allocatedWidth = this.allocatedWidth;
                        child.element.style.left = '0';
                    } else {
                        child.allocatedWidth = child.requestedWidth;
                        let additionalSpace =
                            this.allocatedWidth - child.requestedWidth;
                        child.element.style.left =
                            additionalSpace * this.state.align_x + 'rem';
                    }
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight =
                        componentsById[this.state.content].requestedHeight;
                }
                updateAllocatedHeight(ctx) {
                    let child = componentsById[this.state.content];
                    if (this.state.align_y === null) {
                        child.allocatedHeight = this.allocatedHeight;
                        child.element.style.top = '0';
                    } else {
                        child.allocatedHeight = child.requestedHeight;
                        let additionalSpace =
                            this.allocatedHeight - child.requestedHeight;
                        child.element.style.top =
                            additionalSpace * this.state.align_y + 'rem';
                    }
                }
            }
            function colorToCssString(color) {
                const [r, g, b, a] = color;
                return `rgba(${r * 255}, ${g * 255}, ${b * 255}, ${a})`;
            }
            function gradientToCssString(angleDegrees, stops) {
                let stopStrings = [];
                for (let i = 0; i < stops.length; i++) {
                    let color = stops[i][0];
                    let position = stops[i][1];
                    stopStrings.push(
                        `${colorToCssString(color)} ${position * 100}%`
                    );
                }
                return `linear-gradient(${90 - angleDegrees}deg, ${stopStrings.join(
                    ', '
                )})`;
            }
            function fillToCssString(fill) {
                if (fill.type === 'solid') {
                    return colorToCssString(fill.color);
                } else if (fill.type === 'linearGradient') {
                    if (fill.stops.length == 1) {
                        return colorToCssString(fill.stops[0][0]);
                    }
                    return gradientToCssString(fill.angleDegrees, fill.stops);
                } else if (fill.type === 'image') {
                    let cssUrl = `url('${fill.imageUrl}')`;
                    if (fill.fillMode == 'fit') {
                        return `${cssUrl} center/contain no-repeat`;
                    } else if (fill.fillMode == 'stretch') {
                        return `${cssUrl} top left / 100% 100%`;
                    } else if (fill.fillMode == 'tile') {
                        return `${cssUrl} left top repeat`;
                    } else if (fill.fillMode == 'zoom') {
                        return `${cssUrl} center/cover no-repeat`;
                    } else {
                        throw `Invalid fill mode for image fill: ${fill.type}`;
                    }
                }
                throw `Invalid fill type: ${fill.type}`;
            }
            function fillToCss(fill) {
                return {
                    background: fillToCssString(fill),
                };
            }
            function textStyleToCss(style2) {
                let result = {
                    background: 'none',
                    color: 'unset',
                    // FIXME
                };
                if (style2 === 'dim') {
                    style2 = 'text';
                    result['opacity'] = '0.4';
                } else {
                    result['opacity'] = '1';
                }
                if (typeof style2 === 'string') {
                    let globalPrefix = `var(--rio-global-${style2}-`;
                    let localPrefix = `var(--rio-local-${style2}-`;
                    result['color'] = localPrefix + 'color)';
                    result['background'] = localPrefix + 'background)';
                    result['-webkit-background-clip'] =
                        localPrefix + 'background-clip)';
                    result['-webkit-text-fill-color'] =
                        localPrefix + 'fill-color)';
                    result['font-weight'] = localPrefix + 'font-weight)';
                    result['font-family'] = globalPrefix + 'font-name)';
                    result['font-size'] = globalPrefix + 'font-size)';
                    result['text-style'] = globalPrefix + 'font-italic)';
                    result['text-decoration'] = globalPrefix + 'underlined)';
                    result['text-transform'] = globalPrefix + 'all-caps)';
                } else {
                    result['font-size'] = style2.fontSize + 'em';
                    result['font-style'] = style2.italic ? 'italic' : 'normal';
                    result['font-weight'] = style2.fontWeight;
                    result['text-decoration'] = style2.underlined
                        ? 'underline'
                        : 'none';
                    result['text-transform'] = style2.allCaps
                        ? 'uppercase'
                        : 'none';
                    if (style2.fontName === null) {
                        result['font-family'] = 'inherit';
                    } else {
                        result['font-family'] = style2.fontName;
                    }
                    if (style2.fill === null) {
                        result['color'] = 'var(--rio-local-text-color)';
                        result['background'] =
                            'var(--rio-local-text-background)';
                        result['-webkit-background-clip'] =
                            'var(--rio-local-text-background-clip)';
                        result['-webkit-text-fill-color'] =
                            'var(--rio-local-text-fill-color)';
                    } else if (Array.isArray(style2.fill)) {
                        result['color'] = colorToCssString(style2.fill);
                        result['background'] = 'none';
                        result['-webkit-background-clip'] = 'unset';
                        result['-webkit-text-fill-color'] = 'unset';
                    } else if (style2.fill.type === 'solid') {
                        result['color'] = colorToCssString(style2.fill.color);
                        result['background'] = 'none';
                        result['-webkit-background-clip'] = 'unset';
                        result['-webkit-text-fill-color'] = 'unset';
                    } else {
                        result['color'] = 'unset';
                        result['background'] = fillToCssString(style2.fill);
                        result['-webkit-background-clip'] = 'text';
                        result['-webkit-text-fill-color'] = 'transparent';
                    }
                }
                return result;
            }
            const ICON_PROMISE_CACHE = {};
            function applyColorSet(element2, colorSet) {
                element2.classList.remove(
                    'rio-switcheroo-primary',
                    'rio-switcheroo-secondary',
                    'rio-switcheroo-background',
                    'rio-switcheroo-neutral',
                    'rio-switcheroo-hud',
                    'rio-switcheroo-disabled',
                    'rio-switcheroo-success',
                    'rio-switcheroo-warning',
                    'rio-switcheroo-danger',
                    'rio-switcheroo-custom',
                    'rio-switcheroo-accent-to-plain'
                );
                if (colorSet === 'keep') {
                    return;
                }
                let switcheroo;
                if (typeof colorSet !== 'string') {
                    element2.style.setProperty(
                        '--rio-local-custom-plain-bg',
                        colorToCssString(colorSet.plainBg)
                    );
                    element2.style.setProperty(
                        '--rio-local-custom-plain-bg-variant',
                        colorToCssString(colorSet.plainBgVariant)
                    );
                    element2.style.setProperty(
                        '--rio-local-custom-plain-bg-active',
                        colorToCssString(colorSet.plainBgActive)
                    );
                    element2.style.setProperty(
                        '--rio-local-custom-plain-fg',
                        colorToCssString(colorSet.plainFg)
                    );
                    element2.style.setProperty(
                        '--rio-local-custom-accent-bg',
                        colorToCssString(colorSet.accentBg)
                    );
                    element2.style.setProperty(
                        '--rio-local-custom-accent-fg',
                        colorToCssString(colorSet.accentFg)
                    );
                    switcheroo = 'custom';
                } else {
                    switcheroo = colorSet;
                }
                element2.classList.add(`rio-switcheroo-${switcheroo}`);
            }
            function applyFillToSVG(svgRoot, fill) {
                switch (fill.type) {
                    case 'solid':
                        applySolidFill(svgRoot, fill.color);
                        break;
                    case 'linearGradient':
                        applyLinearGradientFill(
                            svgRoot,
                            fill.angleDegrees,
                            fill.stops
                        );
                        break;
                    case 'image':
                        applyImageFill(svgRoot, fill.imageUrl, fill.fillMode);
                        break;
                    default:
                        throw new Error(`Invalid fill type: ${fill}`);
                }
            }
            function applySolidFill(svgRoot, color) {
                const [r, g, b, a] = color;
                svgRoot.style.fill = `rgba(${r * 255}, ${g * 255}, ${b * 255}, ${a})`;
            }
            function applyLinearGradientFill(svgRoot, angleDegrees, stops) {
                const gradientId = generateUniqueId();
                const gradient = createLinearGradient(
                    gradientId,
                    angleDegrees,
                    stops
                );
                let defs = svgRoot.querySelector('defs');
                if (defs === null) {
                    defs = document.createElementNS(
                        'http://www.w3.org/2000/svg',
                        'defs'
                    );
                    svgRoot.appendChild(defs);
                }
                defs.appendChild(gradient);
                svgRoot.style.fill = `url(#${gradientId})`;
            }
            function applyImageFill(svgRoot, imageUrl, fillMode) {
                const patternId = generateUniqueId();
                const pattern = document.createElementNS(
                    'http://www.w3.org/2000/svg',
                    'pattern'
                );
                pattern.setAttribute('id', patternId);
                pattern.setAttribute('width', '100%');
                pattern.setAttribute('height', '100%');
                pattern.setAttribute('preserveAspectRatio', 'none');
                const image = document.createElementNS(
                    'http://www.w3.org/2000/svg',
                    'image'
                );
                image.setAttribute('width', '100%');
                image.setAttribute('height', '100%');
                image.setAttribute('href', imageUrl);
                image.setAttribute('preserveAspectRatio', 'none');
                pattern.appendChild(image);
                let defs = svgRoot.querySelector('defs');
                if (defs === null) {
                    defs = document.createElementNS(
                        'http://www.w3.org/2000/svg',
                        'defs'
                    );
                    svgRoot.appendChild(defs);
                }
                defs.appendChild(pattern);
                svgRoot.setAttribute('fill', `url(#${patternId})`);
            }
            function generateUniqueId() {
                return Math.random().toString(36);
            }
            function createLinearGradient(gradientId, angleDegrees, stops) {
                const gradient = document.createElementNS(
                    'http://www.w3.org/2000/svg',
                    'linearGradient'
                );
                gradient.setAttribute('id', gradientId);
                gradient.setAttribute(
                    'gradientTransform',
                    `rotate(${angleDegrees})`
                );
                let ii = -1;
                for (const [color, offset] of stops) {
                    ii += 1;
                    const [r, g, b, a] = color;
                    const stop = document.createElementNS(
                        'http://www.w3.org/2000/svg',
                        'stop'
                    );
                    stop.setAttribute('offset', `${offset}`);
                    stop.setAttribute(
                        'style',
                        `stop-color: rgba(${r * 255}, ${g * 255}, ${b * 255}, ${a})`
                    );
                    stop.setAttribute('id', `${gradientId}-stop-${ii}`);
                    gradient.appendChild(stop);
                }
                return gradient;
            }
            async function applyIcon(target, iconName, cssColor) {
                let promise = ICON_PROMISE_CACHE[iconName];
                if (promise === void 0) {
                    console.log(`Fetching icon ${iconName} from server`);
                    promise = fetch(`/rio/icon/${iconName}`).then((response) =>
                        response.text()
                    );
                    ICON_PROMISE_CACHE[iconName] = promise;
                }
                target.setAttribute('data-rio-icon', iconName);
                let svgSource;
                try {
                    svgSource = await promise;
                } catch (err) {
                    console.error(`Error loading icon ${iconName}: ${err}`);
                    delete ICON_PROMISE_CACHE[iconName];
                    return;
                }
                if (target.getAttribute('data-rio-icon') !== iconName) {
                    return;
                }
                target.removeAttribute('data-rio-icon');
                target.innerHTML = svgSource;
                let svgRoot = target.querySelector('svg');
                svgRoot.style.fill = cssColor;
            }
            const _textDimensionsCache = /* @__PURE__ */ new Map();
            function getTextDimensions(text2, style2, restrictWidth = null) {
                if (text2.trim().length === 0) {
                    text2 = 'l';
                }
                let key;
                let sizeNormalizationFactor;
                if (typeof style2 === 'string') {
                    key = `${style2}+${text2}`;
                    sizeNormalizationFactor = 1;
                } else {
                    key = `${style2.fontName}+${style2.fontWeight}+${style2.italic}+${style2.underlined}+${style2.allCaps}+${text2}`;
                    sizeNormalizationFactor = style2.fontSize;
                }
                if (restrictWidth !== null) {
                    key += `+${restrictWidth}`;
                }
                let cached = _textDimensionsCache.get(key);
                if (cached !== void 0) {
                    return [
                        cached[0] * sizeNormalizationFactor,
                        cached[1] * sizeNormalizationFactor,
                    ];
                }
                let element2 = document.createElement('div');
                element2.textContent = text2;
                Object.assign(element2.style, textStyleToCss(style2));
                element2.style.position = 'absolute';
                element2.style.whiteSpace = 'pre-wrap';
                document.body.appendChild(element2);
                if (restrictWidth !== null) {
                    element2.style.width = `${restrictWidth}rem`;
                }
                let rect = element2.getBoundingClientRect();
                let result = [
                    rect.width / pixelsPerRem,
                    rect.height / pixelsPerRem,
                ];
                element2.remove();
                _textDimensionsCache.set(key, [
                    result[0] / sizeNormalizationFactor,
                    result[1] / sizeNormalizationFactor,
                ]);
                return result;
            }
            globalThis.getTextDimensions = getTextDimensions;
            function getElementDimensions(element2) {
                let isInDom = element2.isConnected;
                let originalDisplay = element2.style.display;
                let parentElement = null;
                let nextSibling = null;
                if (!isInDom) {
                    parentElement = element2.parentElement;
                    nextSibling = element2.nextSibling;
                }
                if (!isInDom) {
                    document.body.appendChild(element2);
                } else {
                    element2.style.display = 'fixed';
                }
                let result = [
                    element2.scrollWidth / pixelsPerRem,
                    element2.scrollHeight / pixelsPerRem,
                ];
                if (isInDom) {
                    element2.style.display = originalDisplay;
                } else if (parentElement === null) {
                    element2.remove();
                } else if (nextSibling === null) {
                    parentElement.appendChild(element2);
                } else {
                    parentElement.insertBefore(element2, nextSibling);
                }
                return result;
            }
            globalThis.getElementDimensions = getElementDimensions;
            function getElementWidth(element2) {
                let dimensions = getElementDimensions(element2);
                return dimensions[0];
            }
            function getElementHeight(element2) {
                let dimensions = getElementDimensions(element2);
                return dimensions[1];
            }
            class BuildFailedComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-build-failed');
                    element2.innerHTML = `
            <div class="rio-build-failed-top"></div>
            <div class="rio-build-failed-content">
                <div class="rio-build-failed-header">
                    <div class="rio-build-failed-icon"></div>
                    <div class="rio-build-failed-summary"></div>
                </div>
                <div class="rio-build-failed-details"></div>
            </div>
            <div class="rio-build-failed-bottom"></div>
        `;
                    this.iconElement = element2.querySelector(
                        '.rio-build-failed-icon'
                    );
                    this.summaryElement = element2.querySelector(
                        '.rio-build-failed-summary'
                    );
                    this.detailsElement = element2.querySelector(
                        '.rio-build-failed-details'
                    );
                    applyIcon(
                        this.iconElement,
                        'material/error:fill',
                        'var(--rio-global-danger-fg)'
                    );
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.error_summary !== void 0) {
                        this.summaryElement.innerText =
                            deltaState.error_summary;
                    }
                    if (deltaState.error_details !== void 0) {
                        this.detailsElement.innerText =
                            deltaState.error_details;
                    }
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 4;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 4;
                }
                updateAllocatedHeight(ctx) {
                    let summaryDims = getElementDimensions(this.summaryElement);
                    let detailsDims = getElementDimensions(this.detailsElement);
                    let summaryVisible =
                        this.allocatedWidth > summaryDims[0] + 6;
                    let detailsVisible =
                        summaryVisible &&
                        this.allocatedWidth > detailsDims[0] + 1 && // The padding is a guess
                        this.allocatedHeight > detailsDims[1] + 6;
                    summaryVisible =
                        summaryVisible && this.state.error_summary.length > 0;
                    detailsVisible =
                        detailsVisible && this.state.error_details.length > 0;
                    this.summaryElement.style.display = summaryVisible
                        ? ''
                        : 'none';
                    this.detailsElement.style.display = detailsVisible
                        ? ''
                        : 'none';
                }
            }
            var supportsCssVariables_;
            function supportsCssVariables(windowObj, forceRefresh) {
                if (forceRefresh === void 0) {
                    forceRefresh = false;
                }
                var CSS = windowObj.CSS;
                var supportsCssVars = supportsCssVariables_;
                if (
                    typeof supportsCssVariables_ === 'boolean' &&
                    !forceRefresh
                ) {
                    return supportsCssVariables_;
                }
                var supportsFunctionPresent =
                    CSS && typeof CSS.supports === 'function';
                if (!supportsFunctionPresent) {
                    return false;
                }
                var explicitlySupportsCssVars = CSS.supports(
                    '--css-vars',
                    'yes'
                );
                var weAreFeatureDetectingSafari10plus =
                    CSS.supports('(--css-vars: yes)') &&
                    CSS.supports('color', '#00000000');
                supportsCssVars =
                    explicitlySupportsCssVars ||
                    weAreFeatureDetectingSafari10plus;
                if (!forceRefresh) {
                    supportsCssVariables_ = supportsCssVars;
                }
                return supportsCssVars;
            }
            function getNormalizedEventCoords(evt, pageOffset, clientRect) {
                if (!evt) {
                    return { x: 0, y: 0 };
                }
                var x = pageOffset.x,
                    y = pageOffset.y;
                var documentX = x + clientRect.left;
                var documentY = y + clientRect.top;
                var normalizedX;
                var normalizedY;
                if (evt.type === 'touchstart') {
                    var touchEvent = evt;
                    normalizedX =
                        touchEvent.changedTouches[0].pageX - documentX;
                    normalizedY =
                        touchEvent.changedTouches[0].pageY - documentY;
                } else {
                    var mouseEvent = evt;
                    normalizedX = mouseEvent.pageX - documentX;
                    normalizedY = mouseEvent.pageY - documentY;
                }
                return { x: normalizedX, y: normalizedY };
            }
            var extendStatics = function (d, b) {
                extendStatics =
                    Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array &&
                        function (d2, b2) {
                            d2.__proto__ = b2;
                        }) ||
                    function (d2, b2) {
                        for (var p in b2)
                            if (Object.prototype.hasOwnProperty.call(b2, p))
                                d2[p] = b2[p];
                    };
                return extendStatics(d, b);
            };
            function __extends(d, b) {
                if (typeof b !== 'function' && b !== null)
                    throw new TypeError(
                        'Class extends value ' +
                            String(b) +
                            ' is not a constructor or null'
                    );
                extendStatics(d, b);
                function __() {
                    this.constructor = d;
                }
                d.prototype =
                    b === null
                        ? Object.create(b)
                        : ((__.prototype = b.prototype), new __());
            }
            var __assign = function () {
                __assign =
                    Object.assign ||
                    function __assign2(t) {
                        for (var s, i = 1, n = arguments.length; i < n; i++) {
                            s = arguments[i];
                            for (var p in s)
                                if (Object.prototype.hasOwnProperty.call(s, p))
                                    t[p] = s[p];
                        }
                        return t;
                    };
                return __assign.apply(this, arguments);
            };
            function __values(o) {
                var s = typeof Symbol === 'function' && Symbol.iterator,
                    m = s && o[s],
                    i = 0;
                if (m) return m.call(o);
                if (o && typeof o.length === 'number')
                    return {
                        next: function () {
                            if (o && i >= o.length) o = void 0;
                            return { value: o && o[i++], done: !o };
                        },
                    };
                throw new TypeError(
                    s
                        ? 'Object is not iterable.'
                        : 'Symbol.iterator is not defined.'
                );
            }
            function __read(o, n) {
                var m = typeof Symbol === 'function' && o[Symbol.iterator];
                if (!m) return o;
                var i = m.call(o),
                    r,
                    ar = [],
                    e;
                try {
                    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                        ar.push(r.value);
                } catch (error2) {
                    e = { error: error2 };
                } finally {
                    try {
                        if (r && !r.done && (m = i['return'])) m.call(i);
                    } finally {
                        if (e) throw e.error;
                    }
                }
                return ar;
            }
            function __spreadArray(to, from, pack) {
                if (pack || arguments.length === 2)
                    for (var i = 0, l = from.length, ar; i < l; i++) {
                        if (ar || !(i in from)) {
                            if (!ar)
                                ar = Array.prototype.slice.call(from, 0, i);
                            ar[i] = from[i];
                        }
                    }
                return to.concat(ar || Array.prototype.slice.call(from));
            }
            typeof SuppressedError === 'function'
                ? SuppressedError
                : function (error2, suppressed, message) {
                      var e = new Error(message);
                      return (
                          (e.name = 'SuppressedError'),
                          (e.error = error2),
                          (e.suppressed = suppressed),
                          e
                      );
                  };
            /**
             * @license
             * Copyright 2016 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var MDCFoundation =
                /** @class */
                (function () {
                    function MDCFoundation2(adapter) {
                        if (adapter === void 0) {
                            adapter = {};
                        }
                        this.adapter = adapter;
                    }
                    Object.defineProperty(MDCFoundation2, 'cssClasses', {
                        get: function () {
                            return {};
                        },
                        enumerable: false,
                        configurable: true,
                    });
                    Object.defineProperty(MDCFoundation2, 'strings', {
                        get: function () {
                            return {};
                        },
                        enumerable: false,
                        configurable: true,
                    });
                    Object.defineProperty(MDCFoundation2, 'numbers', {
                        get: function () {
                            return {};
                        },
                        enumerable: false,
                        configurable: true,
                    });
                    Object.defineProperty(MDCFoundation2, 'defaultAdapter', {
                        get: function () {
                            return {};
                        },
                        enumerable: false,
                        configurable: true,
                    });
                    MDCFoundation2.prototype.init = function () {};
                    MDCFoundation2.prototype.destroy = function () {};
                    return MDCFoundation2;
                })();
            /**
             * @license
             * Copyright 2016 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var MDCComponent =
                /** @class */
                (function () {
                    function MDCComponent2(root, foundation) {
                        var args = [];
                        for (var _i = 2; _i < arguments.length; _i++) {
                            args[_i - 2] = arguments[_i];
                        }
                        this.root = root;
                        this.initialize.apply(
                            this,
                            __spreadArray([], __read(args))
                        );
                        this.foundation =
                            foundation === void 0
                                ? this.getDefaultFoundation()
                                : foundation;
                        this.foundation.init();
                        this.initialSyncWithDOM();
                    }
                    MDCComponent2.attachTo = function (root) {
                        return new MDCComponent2(root, new MDCFoundation({}));
                    };
                    MDCComponent2.prototype.initialize = function () {};
                    MDCComponent2.prototype.getDefaultFoundation = function () {
                        throw new Error(
                            'Subclasses must override getDefaultFoundation to return a properly configured foundation class'
                        );
                    };
                    MDCComponent2.prototype.initialSyncWithDOM = function () {};
                    MDCComponent2.prototype.destroy = function () {
                        this.foundation.destroy();
                    };
                    MDCComponent2.prototype.listen = function (
                        evtType,
                        handler,
                        options
                    ) {
                        this.root.addEventListener(evtType, handler, options);
                    };
                    MDCComponent2.prototype.unlisten = function (
                        evtType,
                        handler,
                        options
                    ) {
                        this.root.removeEventListener(
                            evtType,
                            handler,
                            options
                        );
                    };
                    MDCComponent2.prototype.emit = function (
                        evtType,
                        evtData,
                        shouldBubble
                    ) {
                        if (shouldBubble === void 0) {
                            shouldBubble = false;
                        }
                        var evt;
                        if (typeof CustomEvent === 'function') {
                            evt = new CustomEvent(evtType, {
                                bubbles: shouldBubble,
                                detail: evtData,
                            });
                        } else {
                            evt = document.createEvent('CustomEvent');
                            evt.initCustomEvent(
                                evtType,
                                shouldBubble,
                                false,
                                evtData
                            );
                        }
                        this.root.dispatchEvent(evt);
                    };
                    return MDCComponent2;
                })();
            /**
             * @license
             * Copyright 2019 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            function applyPassive(globalObj) {
                if (globalObj === void 0) {
                    globalObj = window;
                }
                return supportsPassiveOption(globalObj)
                    ? { passive: true }
                    : false;
            }
            function supportsPassiveOption(globalObj) {
                if (globalObj === void 0) {
                    globalObj = window;
                }
                var passiveSupported = false;
                try {
                    var options = {
                        // This function will be called when the browser
                        // attempts to access the passive property.
                        get passive() {
                            passiveSupported = true;
                            return false;
                        },
                    };
                    var handler = function () {};
                    globalObj.document.addEventListener(
                        'test',
                        handler,
                        options
                    );
                    globalObj.document.removeEventListener(
                        'test',
                        handler,
                        options
                    );
                } catch (err) {
                    passiveSupported = false;
                }
                return passiveSupported;
            }
            /**
             * @license
             * Copyright 2018 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            function matches(element2, selector) {
                var nativeMatches =
                    element2.matches ||
                    element2.webkitMatchesSelector ||
                    element2.msMatchesSelector;
                return nativeMatches.call(element2, selector);
            }
            /**
             * @license
             * Copyright 2016 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var cssClasses$2 = {
                // Ripple is a special case where the "root" component is really a "mixin" of sorts,
                // given that it's an 'upgrade' to an existing component. That being said it is the root
                // CSS class that all other CSS classes derive from.
                BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
                FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
                FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
                ROOT: 'mdc-ripple-upgraded',
                UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
            };
            var strings$2 = {
                VAR_FG_SCALE: '--mdc-ripple-fg-scale',
                VAR_FG_SIZE: '--mdc-ripple-fg-size',
                VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
                VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
                VAR_LEFT: '--mdc-ripple-left',
                VAR_TOP: '--mdc-ripple-top',
            };
            var numbers$1 = {
                DEACTIVATION_TIMEOUT_MS: 225,
                FG_DEACTIVATION_MS: 150,
                INITIAL_ORIGIN_SCALE: 0.6,
                PADDING: 10,
                TAP_DELAY_MS: 300,
                // Delay between touch and simulated mouse events on touch devices
            };
            /**
             * @license
             * Copyright 2016 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var ACTIVATION_EVENT_TYPES = [
                'touchstart',
                'pointerdown',
                'mousedown',
                'keydown',
            ];
            var POINTER_DEACTIVATION_EVENT_TYPES = [
                'touchend',
                'pointerup',
                'mouseup',
                'contextmenu',
            ];
            var activatedTargets = [];
            var MDCRippleFoundation =
                /** @class */
                (function (_super) {
                    __extends(MDCRippleFoundation2, _super);
                    function MDCRippleFoundation2(adapter) {
                        var _this =
                            _super.call(
                                this,
                                __assign(
                                    __assign(
                                        {},
                                        MDCRippleFoundation2.defaultAdapter
                                    ),
                                    adapter
                                )
                            ) || this;
                        _this.activationAnimationHasEnded = false;
                        _this.activationTimer = 0;
                        _this.fgDeactivationRemovalTimer = 0;
                        _this.fgScale = '0';
                        _this.frame = { width: 0, height: 0 };
                        _this.initialSize = 0;
                        _this.layoutFrame = 0;
                        _this.maxRadius = 0;
                        _this.unboundedCoords = { left: 0, top: 0 };
                        _this.activationState = _this.defaultActivationState();
                        _this.activationTimerCallback = function () {
                            _this.activationAnimationHasEnded = true;
                            _this.runDeactivationUXLogicIfReady();
                        };
                        _this.activateHandler = function (e) {
                            _this.activateImpl(e);
                        };
                        _this.deactivateHandler = function () {
                            _this.deactivateImpl();
                        };
                        _this.focusHandler = function () {
                            _this.handleFocus();
                        };
                        _this.blurHandler = function () {
                            _this.handleBlur();
                        };
                        _this.resizeHandler = function () {
                            _this.layout();
                        };
                        return _this;
                    }
                    Object.defineProperty(MDCRippleFoundation2, 'cssClasses', {
                        get: function () {
                            return cssClasses$2;
                        },
                        enumerable: false,
                        configurable: true,
                    });
                    Object.defineProperty(MDCRippleFoundation2, 'strings', {
                        get: function () {
                            return strings$2;
                        },
                        enumerable: false,
                        configurable: true,
                    });
                    Object.defineProperty(MDCRippleFoundation2, 'numbers', {
                        get: function () {
                            return numbers$1;
                        },
                        enumerable: false,
                        configurable: true,
                    });
                    Object.defineProperty(
                        MDCRippleFoundation2,
                        'defaultAdapter',
                        {
                            get: function () {
                                return {
                                    addClass: function () {
                                        return void 0;
                                    },
                                    browserSupportsCssVars: function () {
                                        return true;
                                    },
                                    computeBoundingRect: function () {
                                        return {
                                            top: 0,
                                            right: 0,
                                            bottom: 0,
                                            left: 0,
                                            width: 0,
                                            height: 0,
                                        };
                                    },
                                    containsEventTarget: function () {
                                        return true;
                                    },
                                    deregisterDocumentInteractionHandler:
                                        function () {
                                            return void 0;
                                        },
                                    deregisterInteractionHandler: function () {
                                        return void 0;
                                    },
                                    deregisterResizeHandler: function () {
                                        return void 0;
                                    },
                                    getWindowPageOffset: function () {
                                        return { x: 0, y: 0 };
                                    },
                                    isSurfaceActive: function () {
                                        return true;
                                    },
                                    isSurfaceDisabled: function () {
                                        return true;
                                    },
                                    isUnbounded: function () {
                                        return true;
                                    },
                                    registerDocumentInteractionHandler:
                                        function () {
                                            return void 0;
                                        },
                                    registerInteractionHandler: function () {
                                        return void 0;
                                    },
                                    registerResizeHandler: function () {
                                        return void 0;
                                    },
                                    removeClass: function () {
                                        return void 0;
                                    },
                                    updateCssVariable: function () {
                                        return void 0;
                                    },
                                };
                            },
                            enumerable: false,
                            configurable: true,
                        }
                    );
                    MDCRippleFoundation2.prototype.init = function () {
                        var _this = this;
                        var supportsPressRipple = this.supportsPressRipple();
                        this.registerRootHandlers(supportsPressRipple);
                        if (supportsPressRipple) {
                            var _a = MDCRippleFoundation2.cssClasses,
                                ROOT_1 = _a.ROOT,
                                UNBOUNDED_1 = _a.UNBOUNDED;
                            requestAnimationFrame(function () {
                                _this.adapter.addClass(ROOT_1);
                                if (_this.adapter.isUnbounded()) {
                                    _this.adapter.addClass(UNBOUNDED_1);
                                    _this.layoutInternal();
                                }
                            });
                        }
                    };
                    MDCRippleFoundation2.prototype.destroy = function () {
                        var _this = this;
                        if (this.supportsPressRipple()) {
                            if (this.activationTimer) {
                                clearTimeout(this.activationTimer);
                                this.activationTimer = 0;
                                this.adapter.removeClass(
                                    MDCRippleFoundation2.cssClasses
                                        .FG_ACTIVATION
                                );
                            }
                            if (this.fgDeactivationRemovalTimer) {
                                clearTimeout(this.fgDeactivationRemovalTimer);
                                this.fgDeactivationRemovalTimer = 0;
                                this.adapter.removeClass(
                                    MDCRippleFoundation2.cssClasses
                                        .FG_DEACTIVATION
                                );
                            }
                            var _a = MDCRippleFoundation2.cssClasses,
                                ROOT_2 = _a.ROOT,
                                UNBOUNDED_2 = _a.UNBOUNDED;
                            requestAnimationFrame(function () {
                                _this.adapter.removeClass(ROOT_2);
                                _this.adapter.removeClass(UNBOUNDED_2);
                                _this.removeCssVars();
                            });
                        }
                        this.deregisterRootHandlers();
                        this.deregisterDeactivationHandlers();
                    };
                    MDCRippleFoundation2.prototype.activate = function (evt) {
                        this.activateImpl(evt);
                    };
                    MDCRippleFoundation2.prototype.deactivate = function () {
                        this.deactivateImpl();
                    };
                    MDCRippleFoundation2.prototype.layout = function () {
                        var _this = this;
                        if (this.layoutFrame) {
                            cancelAnimationFrame(this.layoutFrame);
                        }
                        this.layoutFrame = requestAnimationFrame(function () {
                            _this.layoutInternal();
                            _this.layoutFrame = 0;
                        });
                    };
                    MDCRippleFoundation2.prototype.setUnbounded = function (
                        unbounded
                    ) {
                        var UNBOUNDED =
                            MDCRippleFoundation2.cssClasses.UNBOUNDED;
                        if (unbounded) {
                            this.adapter.addClass(UNBOUNDED);
                        } else {
                            this.adapter.removeClass(UNBOUNDED);
                        }
                    };
                    MDCRippleFoundation2.prototype.handleFocus = function () {
                        var _this = this;
                        requestAnimationFrame(function () {
                            return _this.adapter.addClass(
                                MDCRippleFoundation2.cssClasses.BG_FOCUSED
                            );
                        });
                    };
                    MDCRippleFoundation2.prototype.handleBlur = function () {
                        var _this = this;
                        requestAnimationFrame(function () {
                            return _this.adapter.removeClass(
                                MDCRippleFoundation2.cssClasses.BG_FOCUSED
                            );
                        });
                    };
                    MDCRippleFoundation2.prototype.supportsPressRipple =
                        function () {
                            return this.adapter.browserSupportsCssVars();
                        };
                    MDCRippleFoundation2.prototype.defaultActivationState =
                        function () {
                            return {
                                activationEvent: void 0,
                                hasDeactivationUXRun: false,
                                isActivated: false,
                                isProgrammatic: false,
                                wasActivatedByPointer: false,
                                wasElementMadeActive: false,
                            };
                        };
                    MDCRippleFoundation2.prototype.registerRootHandlers =
                        function (supportsPressRipple) {
                            var e_1, _a;
                            if (supportsPressRipple) {
                                try {
                                    for (
                                        var ACTIVATION_EVENT_TYPES_1 = __values(
                                                ACTIVATION_EVENT_TYPES
                                            ),
                                            ACTIVATION_EVENT_TYPES_1_1 =
                                                ACTIVATION_EVENT_TYPES_1.next();
                                        !ACTIVATION_EVENT_TYPES_1_1.done;
                                        ACTIVATION_EVENT_TYPES_1_1 =
                                            ACTIVATION_EVENT_TYPES_1.next()
                                    ) {
                                        var evtType =
                                            ACTIVATION_EVENT_TYPES_1_1.value;
                                        this.adapter.registerInteractionHandler(
                                            evtType,
                                            this.activateHandler
                                        );
                                    }
                                } catch (e_1_1) {
                                    e_1 = { error: e_1_1 };
                                } finally {
                                    try {
                                        if (
                                            ACTIVATION_EVENT_TYPES_1_1 &&
                                            !ACTIVATION_EVENT_TYPES_1_1.done &&
                                            (_a =
                                                ACTIVATION_EVENT_TYPES_1.return)
                                        )
                                            _a.call(ACTIVATION_EVENT_TYPES_1);
                                    } finally {
                                        if (e_1) throw e_1.error;
                                    }
                                }
                                if (this.adapter.isUnbounded()) {
                                    this.adapter.registerResizeHandler(
                                        this.resizeHandler
                                    );
                                }
                            }
                            this.adapter.registerInteractionHandler(
                                'focus',
                                this.focusHandler
                            );
                            this.adapter.registerInteractionHandler(
                                'blur',
                                this.blurHandler
                            );
                        };
                    MDCRippleFoundation2.prototype.registerDeactivationHandlers =
                        function (evt) {
                            var e_2, _a;
                            if (evt.type === 'keydown') {
                                this.adapter.registerInteractionHandler(
                                    'keyup',
                                    this.deactivateHandler
                                );
                            } else {
                                try {
                                    for (
                                        var POINTER_DEACTIVATION_EVENT_TYPES_1 =
                                                __values(
                                                    POINTER_DEACTIVATION_EVENT_TYPES
                                                ),
                                            POINTER_DEACTIVATION_EVENT_TYPES_1_1 =
                                                POINTER_DEACTIVATION_EVENT_TYPES_1.next();
                                        !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done;
                                        POINTER_DEACTIVATION_EVENT_TYPES_1_1 =
                                            POINTER_DEACTIVATION_EVENT_TYPES_1.next()
                                    ) {
                                        var evtType =
                                            POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
                                        this.adapter.registerDocumentInteractionHandler(
                                            evtType,
                                            this.deactivateHandler
                                        );
                                    }
                                } catch (e_2_1) {
                                    e_2 = { error: e_2_1 };
                                } finally {
                                    try {
                                        if (
                                            POINTER_DEACTIVATION_EVENT_TYPES_1_1 &&
                                            !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done &&
                                            (_a =
                                                POINTER_DEACTIVATION_EVENT_TYPES_1.return)
                                        )
                                            _a.call(
                                                POINTER_DEACTIVATION_EVENT_TYPES_1
                                            );
                                    } finally {
                                        if (e_2) throw e_2.error;
                                    }
                                }
                            }
                        };
                    MDCRippleFoundation2.prototype.deregisterRootHandlers =
                        function () {
                            var e_3, _a;
                            try {
                                for (
                                    var ACTIVATION_EVENT_TYPES_2 = __values(
                                            ACTIVATION_EVENT_TYPES
                                        ),
                                        ACTIVATION_EVENT_TYPES_2_1 =
                                            ACTIVATION_EVENT_TYPES_2.next();
                                    !ACTIVATION_EVENT_TYPES_2_1.done;
                                    ACTIVATION_EVENT_TYPES_2_1 =
                                        ACTIVATION_EVENT_TYPES_2.next()
                                ) {
                                    var evtType =
                                        ACTIVATION_EVENT_TYPES_2_1.value;
                                    this.adapter.deregisterInteractionHandler(
                                        evtType,
                                        this.activateHandler
                                    );
                                }
                            } catch (e_3_1) {
                                e_3 = { error: e_3_1 };
                            } finally {
                                try {
                                    if (
                                        ACTIVATION_EVENT_TYPES_2_1 &&
                                        !ACTIVATION_EVENT_TYPES_2_1.done &&
                                        (_a = ACTIVATION_EVENT_TYPES_2.return)
                                    )
                                        _a.call(ACTIVATION_EVENT_TYPES_2);
                                } finally {
                                    if (e_3) throw e_3.error;
                                }
                            }
                            this.adapter.deregisterInteractionHandler(
                                'focus',
                                this.focusHandler
                            );
                            this.adapter.deregisterInteractionHandler(
                                'blur',
                                this.blurHandler
                            );
                            if (this.adapter.isUnbounded()) {
                                this.adapter.deregisterResizeHandler(
                                    this.resizeHandler
                                );
                            }
                        };
                    MDCRippleFoundation2.prototype.deregisterDeactivationHandlers =
                        function () {
                            var e_4, _a;
                            this.adapter.deregisterInteractionHandler(
                                'keyup',
                                this.deactivateHandler
                            );
                            try {
                                for (
                                    var POINTER_DEACTIVATION_EVENT_TYPES_2 =
                                            __values(
                                                POINTER_DEACTIVATION_EVENT_TYPES
                                            ),
                                        POINTER_DEACTIVATION_EVENT_TYPES_2_1 =
                                            POINTER_DEACTIVATION_EVENT_TYPES_2.next();
                                    !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done;
                                    POINTER_DEACTIVATION_EVENT_TYPES_2_1 =
                                        POINTER_DEACTIVATION_EVENT_TYPES_2.next()
                                ) {
                                    var evtType =
                                        POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
                                    this.adapter.deregisterDocumentInteractionHandler(
                                        evtType,
                                        this.deactivateHandler
                                    );
                                }
                            } catch (e_4_1) {
                                e_4 = { error: e_4_1 };
                            } finally {
                                try {
                                    if (
                                        POINTER_DEACTIVATION_EVENT_TYPES_2_1 &&
                                        !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done &&
                                        (_a =
                                            POINTER_DEACTIVATION_EVENT_TYPES_2.return)
                                    )
                                        _a.call(
                                            POINTER_DEACTIVATION_EVENT_TYPES_2
                                        );
                                } finally {
                                    if (e_4) throw e_4.error;
                                }
                            }
                        };
                    MDCRippleFoundation2.prototype.removeCssVars = function () {
                        var _this = this;
                        var rippleStrings = MDCRippleFoundation2.strings;
                        var keys = Object.keys(rippleStrings);
                        keys.forEach(function (key) {
                            if (key.indexOf('VAR_') === 0) {
                                _this.adapter.updateCssVariable(
                                    rippleStrings[key],
                                    null
                                );
                            }
                        });
                    };
                    MDCRippleFoundation2.prototype.activateImpl = function (
                        evt
                    ) {
                        var _this = this;
                        if (this.adapter.isSurfaceDisabled()) {
                            return;
                        }
                        var activationState = this.activationState;
                        if (activationState.isActivated) {
                            return;
                        }
                        var previousActivationEvent =
                            this.previousActivationEvent;
                        var isSameInteraction =
                            previousActivationEvent &&
                            evt !== void 0 &&
                            previousActivationEvent.type !== evt.type;
                        if (isSameInteraction) {
                            return;
                        }
                        activationState.isActivated = true;
                        activationState.isProgrammatic = evt === void 0;
                        activationState.activationEvent = evt;
                        activationState.wasActivatedByPointer =
                            activationState.isProgrammatic
                                ? false
                                : evt !== void 0 &&
                                  (evt.type === 'mousedown' ||
                                      evt.type === 'touchstart' ||
                                      evt.type === 'pointerdown');
                        var hasActivatedChild =
                            evt !== void 0 &&
                            activatedTargets.length > 0 &&
                            activatedTargets.some(function (target) {
                                return _this.adapter.containsEventTarget(
                                    target
                                );
                            });
                        if (hasActivatedChild) {
                            this.resetActivationState();
                            return;
                        }
                        if (evt !== void 0) {
                            activatedTargets.push(evt.target);
                            this.registerDeactivationHandlers(evt);
                        }
                        activationState.wasElementMadeActive =
                            this.checkElementMadeActive(evt);
                        if (activationState.wasElementMadeActive) {
                            this.animateActivation();
                        }
                        requestAnimationFrame(function () {
                            activatedTargets = [];
                            if (
                                !activationState.wasElementMadeActive &&
                                evt !== void 0 &&
                                (evt.key === ' ' || evt.keyCode === 32)
                            ) {
                                activationState.wasElementMadeActive =
                                    _this.checkElementMadeActive(evt);
                                if (activationState.wasElementMadeActive) {
                                    _this.animateActivation();
                                }
                            }
                            if (!activationState.wasElementMadeActive) {
                                _this.activationState =
                                    _this.defaultActivationState();
                            }
                        });
                    };
                    MDCRippleFoundation2.prototype.checkElementMadeActive =
                        function (evt) {
                            return evt !== void 0 && evt.type === 'keydown'
                                ? this.adapter.isSurfaceActive()
                                : true;
                        };
                    MDCRippleFoundation2.prototype.animateActivation =
                        function () {
                            var _this = this;
                            var _a = MDCRippleFoundation2.strings,
                                VAR_FG_TRANSLATE_START =
                                    _a.VAR_FG_TRANSLATE_START,
                                VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
                            var _b = MDCRippleFoundation2.cssClasses,
                                FG_DEACTIVATION = _b.FG_DEACTIVATION,
                                FG_ACTIVATION = _b.FG_ACTIVATION;
                            var DEACTIVATION_TIMEOUT_MS =
                                MDCRippleFoundation2.numbers
                                    .DEACTIVATION_TIMEOUT_MS;
                            this.layoutInternal();
                            var translateStart = '';
                            var translateEnd = '';
                            if (!this.adapter.isUnbounded()) {
                                var _c = this.getFgTranslationCoordinates(),
                                    startPoint = _c.startPoint,
                                    endPoint = _c.endPoint;
                                translateStart =
                                    startPoint.x + 'px, ' + startPoint.y + 'px';
                                translateEnd =
                                    endPoint.x + 'px, ' + endPoint.y + 'px';
                            }
                            this.adapter.updateCssVariable(
                                VAR_FG_TRANSLATE_START,
                                translateStart
                            );
                            this.adapter.updateCssVariable(
                                VAR_FG_TRANSLATE_END,
                                translateEnd
                            );
                            clearTimeout(this.activationTimer);
                            clearTimeout(this.fgDeactivationRemovalTimer);
                            this.rmBoundedActivationClasses();
                            this.adapter.removeClass(FG_DEACTIVATION);
                            this.adapter.computeBoundingRect();
                            this.adapter.addClass(FG_ACTIVATION);
                            this.activationTimer = setTimeout(function () {
                                _this.activationTimerCallback();
                            }, DEACTIVATION_TIMEOUT_MS);
                        };
                    MDCRippleFoundation2.prototype.getFgTranslationCoordinates =
                        function () {
                            var _a = this.activationState,
                                activationEvent = _a.activationEvent,
                                wasActivatedByPointer =
                                    _a.wasActivatedByPointer;
                            var startPoint;
                            if (wasActivatedByPointer) {
                                startPoint = getNormalizedEventCoords(
                                    activationEvent,
                                    this.adapter.getWindowPageOffset(),
                                    this.adapter.computeBoundingRect()
                                );
                            } else {
                                startPoint = {
                                    x: this.frame.width / 2,
                                    y: this.frame.height / 2,
                                };
                            }
                            startPoint = {
                                x: startPoint.x - this.initialSize / 2,
                                y: startPoint.y - this.initialSize / 2,
                            };
                            var endPoint = {
                                x: this.frame.width / 2 - this.initialSize / 2,
                                y: this.frame.height / 2 - this.initialSize / 2,
                            };
                            return { startPoint, endPoint };
                        };
                    MDCRippleFoundation2.prototype.runDeactivationUXLogicIfReady =
                        function () {
                            var _this = this;
                            var FG_DEACTIVATION =
                                MDCRippleFoundation2.cssClasses.FG_DEACTIVATION;
                            var _a = this.activationState,
                                hasDeactivationUXRun = _a.hasDeactivationUXRun,
                                isActivated = _a.isActivated;
                            var activationHasEnded =
                                hasDeactivationUXRun || !isActivated;
                            if (
                                activationHasEnded &&
                                this.activationAnimationHasEnded
                            ) {
                                this.rmBoundedActivationClasses();
                                this.adapter.addClass(FG_DEACTIVATION);
                                this.fgDeactivationRemovalTimer = setTimeout(
                                    function () {
                                        _this.adapter.removeClass(
                                            FG_DEACTIVATION
                                        );
                                    },
                                    numbers$1.FG_DEACTIVATION_MS
                                );
                            }
                        };
                    MDCRippleFoundation2.prototype.rmBoundedActivationClasses =
                        function () {
                            var FG_ACTIVATION =
                                MDCRippleFoundation2.cssClasses.FG_ACTIVATION;
                            this.adapter.removeClass(FG_ACTIVATION);
                            this.activationAnimationHasEnded = false;
                            this.adapter.computeBoundingRect();
                        };
                    MDCRippleFoundation2.prototype.resetActivationState =
                        function () {
                            var _this = this;
                            this.previousActivationEvent =
                                this.activationState.activationEvent;
                            this.activationState =
                                this.defaultActivationState();
                            setTimeout(function () {
                                return (_this.previousActivationEvent = void 0);
                            }, MDCRippleFoundation2.numbers.TAP_DELAY_MS);
                        };
                    MDCRippleFoundation2.prototype.deactivateImpl =
                        function () {
                            var _this = this;
                            var activationState = this.activationState;
                            if (!activationState.isActivated) {
                                return;
                            }
                            var state = __assign({}, activationState);
                            if (activationState.isProgrammatic) {
                                requestAnimationFrame(function () {
                                    _this.animateDeactivation(state);
                                });
                                this.resetActivationState();
                            } else {
                                this.deregisterDeactivationHandlers();
                                requestAnimationFrame(function () {
                                    _this.activationState.hasDeactivationUXRun = true;
                                    _this.animateDeactivation(state);
                                    _this.resetActivationState();
                                });
                            }
                        };
                    MDCRippleFoundation2.prototype.animateDeactivation =
                        function (_a) {
                            var wasActivatedByPointer =
                                    _a.wasActivatedByPointer,
                                wasElementMadeActive = _a.wasElementMadeActive;
                            if (wasActivatedByPointer || wasElementMadeActive) {
                                this.runDeactivationUXLogicIfReady();
                            }
                        };
                    MDCRippleFoundation2.prototype.layoutInternal =
                        function () {
                            var _this = this;
                            this.frame = this.adapter.computeBoundingRect();
                            var maxDim = Math.max(
                                this.frame.height,
                                this.frame.width
                            );
                            var getBoundedRadius = function () {
                                var hypotenuse = Math.sqrt(
                                    Math.pow(_this.frame.width, 2) +
                                        Math.pow(_this.frame.height, 2)
                                );
                                return (
                                    hypotenuse +
                                    MDCRippleFoundation2.numbers.PADDING
                                );
                            };
                            this.maxRadius = this.adapter.isUnbounded()
                                ? maxDim
                                : getBoundedRadius();
                            var initialSize = Math.floor(
                                maxDim *
                                    MDCRippleFoundation2.numbers
                                        .INITIAL_ORIGIN_SCALE
                            );
                            if (
                                this.adapter.isUnbounded() &&
                                initialSize % 2 !== 0
                            ) {
                                this.initialSize = initialSize - 1;
                            } else {
                                this.initialSize = initialSize;
                            }
                            this.fgScale =
                                '' + this.maxRadius / this.initialSize;
                            this.updateLayoutCssVars();
                        };
                    MDCRippleFoundation2.prototype.updateLayoutCssVars =
                        function () {
                            var _a = MDCRippleFoundation2.strings,
                                VAR_FG_SIZE = _a.VAR_FG_SIZE,
                                VAR_LEFT = _a.VAR_LEFT,
                                VAR_TOP = _a.VAR_TOP,
                                VAR_FG_SCALE = _a.VAR_FG_SCALE;
                            this.adapter.updateCssVariable(
                                VAR_FG_SIZE,
                                this.initialSize + 'px'
                            );
                            this.adapter.updateCssVariable(
                                VAR_FG_SCALE,
                                this.fgScale
                            );
                            if (this.adapter.isUnbounded()) {
                                this.unboundedCoords = {
                                    left: Math.round(
                                        this.frame.width / 2 -
                                            this.initialSize / 2
                                    ),
                                    top: Math.round(
                                        this.frame.height / 2 -
                                            this.initialSize / 2
                                    ),
                                };
                                this.adapter.updateCssVariable(
                                    VAR_LEFT,
                                    this.unboundedCoords.left + 'px'
                                );
                                this.adapter.updateCssVariable(
                                    VAR_TOP,
                                    this.unboundedCoords.top + 'px'
                                );
                            }
                        };
                    return MDCRippleFoundation2;
                })(MDCFoundation);
            /**
             * @license
             * Copyright 2016 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var MDCRipple =
                /** @class */
                (function (_super) {
                    __extends(MDCRipple2, _super);
                    function MDCRipple2() {
                        var _this =
                            (_super !== null &&
                                _super.apply(this, arguments)) ||
                            this;
                        _this.disabled = false;
                        return _this;
                    }
                    MDCRipple2.attachTo = function (root, opts) {
                        if (opts === void 0) {
                            opts = {
                                isUnbounded: void 0,
                            };
                        }
                        var ripple = new MDCRipple2(root);
                        if (opts.isUnbounded !== void 0) {
                            ripple.unbounded = opts.isUnbounded;
                        }
                        return ripple;
                    };
                    MDCRipple2.createAdapter = function (instance) {
                        return {
                            addClass: function (className) {
                                return instance.root.classList.add(className);
                            },
                            browserSupportsCssVars: function () {
                                return supportsCssVariables(window);
                            },
                            computeBoundingRect: function () {
                                return instance.root.getBoundingClientRect();
                            },
                            containsEventTarget: function (target) {
                                return instance.root.contains(target);
                            },
                            deregisterDocumentInteractionHandler: function (
                                evtType,
                                handler
                            ) {
                                return document.documentElement.removeEventListener(
                                    evtType,
                                    handler,
                                    applyPassive()
                                );
                            },
                            deregisterInteractionHandler: function (
                                evtType,
                                handler
                            ) {
                                return instance.root.removeEventListener(
                                    evtType,
                                    handler,
                                    applyPassive()
                                );
                            },
                            deregisterResizeHandler: function (handler) {
                                return window.removeEventListener(
                                    'resize',
                                    handler
                                );
                            },
                            getWindowPageOffset: function () {
                                return {
                                    x: window.pageXOffset,
                                    y: window.pageYOffset,
                                };
                            },
                            isSurfaceActive: function () {
                                return matches(instance.root, ':active');
                            },
                            isSurfaceDisabled: function () {
                                return Boolean(instance.disabled);
                            },
                            isUnbounded: function () {
                                return Boolean(instance.unbounded);
                            },
                            registerDocumentInteractionHandler: function (
                                evtType,
                                handler
                            ) {
                                return document.documentElement.addEventListener(
                                    evtType,
                                    handler,
                                    applyPassive()
                                );
                            },
                            registerInteractionHandler: function (
                                evtType,
                                handler
                            ) {
                                return instance.root.addEventListener(
                                    evtType,
                                    handler,
                                    applyPassive()
                                );
                            },
                            registerResizeHandler: function (handler) {
                                return window.addEventListener(
                                    'resize',
                                    handler
                                );
                            },
                            removeClass: function (className) {
                                return instance.root.classList.remove(
                                    className
                                );
                            },
                            updateCssVariable: function (varName, value) {
                                return instance.root.style.setProperty(
                                    varName,
                                    value
                                );
                            },
                        };
                    };
                    Object.defineProperty(MDCRipple2.prototype, 'unbounded', {
                        get: function () {
                            return Boolean(this.isUnbounded);
                        },
                        set: function (unbounded) {
                            this.isUnbounded = Boolean(unbounded);
                            this.setUnbounded();
                        },
                        enumerable: false,
                        configurable: true,
                    });
                    MDCRipple2.prototype.activate = function () {
                        this.foundation.activate();
                    };
                    MDCRipple2.prototype.deactivate = function () {
                        this.foundation.deactivate();
                    };
                    MDCRipple2.prototype.layout = function () {
                        this.foundation.layout();
                    };
                    MDCRipple2.prototype.getDefaultFoundation = function () {
                        return new MDCRippleFoundation(
                            MDCRipple2.createAdapter(this)
                        );
                    };
                    MDCRipple2.prototype.initialSyncWithDOM = function () {
                        var root = this.root;
                        this.isUnbounded =
                            'mdcRippleIsUnbounded' in root.dataset;
                    };
                    MDCRipple2.prototype.setUnbounded = function () {
                        this.foundation.setUnbounded(Boolean(this.isUnbounded));
                    };
                    return MDCRipple2;
                })(MDCComponent);
            class SingleContainer extends ComponentBase {
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 0;
                    for (let child of this.children) {
                        this.naturalWidth = Math.max(
                            this.naturalWidth,
                            child.requestedWidth
                        );
                    }
                }
                updateAllocatedWidth(ctx) {
                    for (let child of this.children) {
                        child.allocatedWidth = this.allocatedWidth;
                    }
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 0;
                    for (let child of this.children) {
                        this.naturalHeight = Math.max(
                            this.naturalHeight,
                            child.requestedHeight
                        );
                    }
                }
                updateAllocatedHeight(ctx) {
                    for (let child of this.children) {
                        child.allocatedHeight = this.allocatedHeight;
                        let element2 = child.element;
                        element2.style.left = '0';
                        element2.style.top = '0';
                    }
                }
            }
            class ButtonComponent extends SingleContainer {
                constructor() {
                    super(...arguments);
                    this.isStillInitiallyDisabled = true;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-button', 'mdc-ripple-surface');
                    this.innerElement = document.createElement('div');
                    element2.appendChild(this.innerElement);
                    this.mdcRipple = new MDCRipple(this.innerElement);
                    this.innerElement.onclick = (event) => {
                        event.stopPropagation();
                        if (
                            !this.state['is_sensitive'] ||
                            this.isStillInitiallyDisabled
                        ) {
                            return;
                        }
                        this.sendMessageToBackend({
                            type: 'press',
                        });
                    };
                    setTimeout(() => {
                        this.isStillInitiallyDisabled = false;
                    }, this.state.initially_disabled_for * 1e3);
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content,
                        this.innerElement
                    );
                    if (deltaState.shape !== void 0) {
                        this.innerElement.classList.remove(
                            'rio-shape-pill',
                            'rio-shape-rounded',
                            'rio-shape-rectangle',
                            'rio-shape-circle'
                        );
                        let className = 'rio-shape-' + deltaState.shape;
                        this.innerElement.classList.add(className);
                    }
                    if (deltaState.style !== void 0) {
                        this.innerElement.classList.remove(
                            'rio-buttonstyle-major',
                            'rio-buttonstyle-minor',
                            'rio-buttonstyle-plain'
                        );
                        let className = 'rio-buttonstyle-' + deltaState.style;
                        this.innerElement.classList.add(className);
                    }
                    if (
                        deltaState.color !== void 0 ||
                        deltaState.is_sensitive !== void 0 ||
                        deltaState.style !== void 0
                    ) {
                        let is_sensitive = firstDefined(
                            deltaState.is_sensitive,
                            this.state['is_sensitive']
                        );
                        let colorSet = is_sensitive
                            ? firstDefined(
                                  deltaState.color,
                                  this.state['color']
                              )
                            : 'disabled';
                        if (colorSet === 'keep') {
                            colorSet = 'accent-to-plain';
                        }
                        applyColorSet(this.innerElement, colorSet);
                    }
                }
                updateAllocatedHeight(ctx) {
                    super.updateAllocatedHeight(ctx);
                    this.mdcRipple.layout();
                }
            }
            class CardComponent extends SingleContainer {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-card');
                    element2.onclick = (event) => {
                        if (!this.state.reportPress) {
                            return;
                        }
                        event.stopPropagation();
                        this.sendMessageToBackend({});
                    };
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                    if (deltaState.corner_radius !== void 0) {
                        if (typeof deltaState.corner_radius === 'number') {
                            this.element.style.borderRadius = `${deltaState.corner_radius}rem`;
                        } else {
                            this.element.style.borderRadius = `${deltaState.corner_radius[0]}rem ${deltaState.corner_radius[1]}rem ${deltaState.corner_radius[2]}rem ${deltaState.corner_radius[3]}rem`;
                        }
                    }
                    if (deltaState.reportPress === true) {
                        this.element.style.cursor = 'pointer';
                    } else if (deltaState.reportPress === false) {
                        this.element.style.cursor = 'default';
                    }
                    if (deltaState.elevate_on_hover === true) {
                        this.element.classList.add('rio-card-elevate-on-hover');
                    } else if (deltaState.elevate_on_hover === false) {
                        this.element.classList.remove(
                            'rio-card-elevate-on-hover'
                        );
                    }
                    if (deltaState.colorize_on_hover === true) {
                        this.element.classList.add(
                            'rio-card-colorize-on-hover'
                        );
                    } else if (deltaState.colorize_on_hover === false) {
                        this.element.classList.remove(
                            'rio-card-colorize-on-hover'
                        );
                    }
                    if (deltaState.color !== void 0) {
                        applyColorSet(this.element, deltaState.color);
                    }
                }
            }
            class ClassContainerComponent extends SingleContainer {
                createElement() {
                    return document.createElement('div');
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                    if (deltaState.classes !== void 0) {
                        this.element.className = '';
                        this.element.classList.add(...deltaState.classes);
                    }
                }
            }
            function getDefaultExportFromCjs(x) {
                return x &&
                    x.__esModule &&
                    Object.prototype.hasOwnProperty.call(x, 'default')
                    ? x['default']
                    : x;
            }
            function deepFreeze(obj) {
                if (obj instanceof Map) {
                    obj.clear =
                        obj.delete =
                        obj.set =
                            function () {
                                throw new Error('map is read-only');
                            };
                } else if (obj instanceof Set) {
                    obj.add =
                        obj.clear =
                        obj.delete =
                            function () {
                                throw new Error('set is read-only');
                            };
                }
                Object.freeze(obj);
                Object.getOwnPropertyNames(obj).forEach((name) => {
                    const prop = obj[name];
                    const type = typeof prop;
                    if (
                        (type === 'object' || type === 'function') &&
                        !Object.isFrozen(prop)
                    ) {
                        deepFreeze(prop);
                    }
                });
                return obj;
            }
            class Response {
                /**
                 * @param {CompiledMode} mode
                 */
                constructor(mode) {
                    if (mode.data === void 0) mode.data = {};
                    this.data = mode.data;
                    this.isMatchIgnored = false;
                }
                ignoreMatch() {
                    this.isMatchIgnored = true;
                }
            }
            function escapeHTML(value) {
                return value
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#x27;');
            }
            function inherit$1(original, ...objects) {
                const result = /* @__PURE__ */ Object.create(null);
                for (const key in original) {
                    result[key] = original[key];
                }
                objects.forEach(function (obj) {
                    for (const key in obj) {
                        result[key] = obj[key];
                    }
                });
                return (
                    /** @type {T} */
                    result
                );
            }
            const SPAN_CLOSE = '</span>';
            const emitsWrappingTags = (node) => {
                return !!node.scope;
            };
            const scopeToCSSClass = (name, { prefix }) => {
                if (name.startsWith('language:')) {
                    return name.replace('language:', 'language-');
                }
                if (name.includes('.')) {
                    const pieces = name.split('.');
                    return [
                        `${prefix}${pieces.shift()}`,
                        ...pieces.map((x, i) => `${x}${'_'.repeat(i + 1)}`),
                    ].join(' ');
                }
                return `${prefix}${name}`;
            };
            class HTMLRenderer {
                /**
                 * Creates a new HTMLRenderer
                 *
                 * @param {Tree} parseTree - the parse tree (must support `walk` API)
                 * @param {{classPrefix: string}} options
                 */
                constructor(parseTree, options) {
                    this.buffer = '';
                    this.classPrefix = options.classPrefix;
                    parseTree.walk(this);
                }
                /**
                 * Adds texts to the output stream
                 *
                 * @param {string} text */
                addText(text2) {
                    this.buffer += escapeHTML(text2);
                }
                /**
                 * Adds a node open to the output stream (if needed)
                 *
                 * @param {Node} node */
                openNode(node) {
                    if (!emitsWrappingTags(node)) return;
                    const className = scopeToCSSClass(node.scope, {
                        prefix: this.classPrefix,
                    });
                    this.span(className);
                }
                /**
                 * Adds a node close to the output stream (if needed)
                 *
                 * @param {Node} node */
                closeNode(node) {
                    if (!emitsWrappingTags(node)) return;
                    this.buffer += SPAN_CLOSE;
                }
                /**
                 * returns the accumulated buffer
                 */
                value() {
                    return this.buffer;
                }
                // helpers
                /**
                 * Builds a span element
                 *
                 * @param {string} className */
                span(className) {
                    this.buffer += `<span class="${className}">`;
                }
            }
            const newNode = (opts = {}) => {
                const result = { children: [] };
                Object.assign(result, opts);
                return result;
            };
            class TokenTree {
                constructor() {
                    this.rootNode = newNode();
                    this.stack = [this.rootNode];
                }
                get top() {
                    return this.stack[this.stack.length - 1];
                }
                get root() {
                    return this.rootNode;
                }
                /** @param {Node} node */
                add(node) {
                    this.top.children.push(node);
                }
                /** @param {string} scope */
                openNode(scope) {
                    const node = newNode({ scope });
                    this.add(node);
                    this.stack.push(node);
                }
                closeNode() {
                    if (this.stack.length > 1) {
                        return this.stack.pop();
                    }
                    return void 0;
                }
                closeAllNodes() {
                    while (this.closeNode());
                }
                toJSON() {
                    return JSON.stringify(this.rootNode, null, 4);
                }
                /**
                 * @typedef { import("./html_renderer").Renderer } Renderer
                 * @param {Renderer} builder
                 */
                walk(builder) {
                    return this.constructor._walk(builder, this.rootNode);
                }
                /**
                 * @param {Renderer} builder
                 * @param {Node} node
                 */
                static _walk(builder, node) {
                    if (typeof node === 'string') {
                        builder.addText(node);
                    } else if (node.children) {
                        builder.openNode(node);
                        node.children.forEach((child) =>
                            this._walk(builder, child)
                        );
                        builder.closeNode(node);
                    }
                    return builder;
                }
                /**
                 * @param {Node} node
                 */
                static _collapse(node) {
                    if (typeof node === 'string') return;
                    if (!node.children) return;
                    if (node.children.every((el) => typeof el === 'string')) {
                        node.children = [node.children.join('')];
                    } else {
                        node.children.forEach((child) => {
                            TokenTree._collapse(child);
                        });
                    }
                }
            }
            class TokenTreeEmitter extends TokenTree {
                /**
                 * @param {*} options
                 */
                constructor(options) {
                    super();
                    this.options = options;
                }
                /**
                 * @param {string} text
                 */
                addText(text2) {
                    if (text2 === '') {
                        return;
                    }
                    this.add(text2);
                }
                /** @param {string} scope */
                startScope(scope) {
                    this.openNode(scope);
                }
                endScope() {
                    this.closeNode();
                }
                /**
                 * @param {Emitter & {root: DataNode}} emitter
                 * @param {string} name
                 */
                __addSublanguage(emitter, name) {
                    const node = emitter.root;
                    if (name) node.scope = `language:${name}`;
                    this.add(node);
                }
                toHTML() {
                    const renderer = new HTMLRenderer(this, this.options);
                    return renderer.value();
                }
                finalize() {
                    this.closeAllNodes();
                    return true;
                }
            }
            function source(re) {
                if (!re) return null;
                if (typeof re === 'string') return re;
                return re.source;
            }
            function lookahead(re) {
                return concat('(?=', re, ')');
            }
            function anyNumberOfTimes(re) {
                return concat('(?:', re, ')*');
            }
            function optional(re) {
                return concat('(?:', re, ')?');
            }
            function concat(...args) {
                const joined = args.map((x) => source(x)).join('');
                return joined;
            }
            function stripOptionsFromArgs(args) {
                const opts = args[args.length - 1];
                if (typeof opts === 'object' && opts.constructor === Object) {
                    args.splice(args.length - 1, 1);
                    return opts;
                } else {
                    return {};
                }
            }
            function either(...args) {
                const opts = stripOptionsFromArgs(args);
                const joined =
                    '(' +
                    (opts.capture ? '' : '?:') +
                    args.map((x) => source(x)).join('|') +
                    ')';
                return joined;
            }
            function countMatchGroups(re) {
                return new RegExp(re.toString() + '|').exec('').length - 1;
            }
            function startsWith(re, lexeme) {
                const match = re && re.exec(lexeme);
                return match && match.index === 0;
            }
            const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
            function _rewriteBackreferences(regexps, { joinWith }) {
                let numCaptures = 0;
                return regexps
                    .map((regex) => {
                        numCaptures += 1;
                        const offset = numCaptures;
                        let re = source(regex);
                        let out = '';
                        while (re.length > 0) {
                            const match = BACKREF_RE.exec(re);
                            if (!match) {
                                out += re;
                                break;
                            }
                            out += re.substring(0, match.index);
                            re = re.substring(match.index + match[0].length);
                            if (match[0][0] === '\\' && match[1]) {
                                out += '\\' + String(Number(match[1]) + offset);
                            } else {
                                out += match[0];
                                if (match[0] === '(') {
                                    numCaptures++;
                                }
                            }
                        }
                        return out;
                    })
                    .map((re) => `(${re})`)
                    .join(joinWith);
            }
            const MATCH_NOTHING_RE = /\b\B/;
            const IDENT_RE = '[a-zA-Z]\\w*';
            const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
            const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
            const C_NUMBER_RE =
                '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)';
            const BINARY_NUMBER_RE = '\\b(0b[01]+)';
            const RE_STARTERS_RE =
                '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';
            const SHEBANG = (opts = {}) => {
                const beginShebang = /^#![ ]*\//;
                if (opts.binary) {
                    opts.begin = concat(
                        beginShebang,
                        /.*\b/,
                        opts.binary,
                        /\b.*/
                    );
                }
                return inherit$1(
                    {
                        scope: 'meta',
                        begin: beginShebang,
                        end: /$/,
                        relevance: 0,
                        /** @type {ModeCallback} */
                        'on:begin': (m, resp) => {
                            if (m.index !== 0) resp.ignoreMatch();
                        },
                    },
                    opts
                );
            };
            const BACKSLASH_ESCAPE = {
                begin: '\\\\[\\s\\S]',
                relevance: 0,
            };
            const APOS_STRING_MODE = {
                scope: 'string',
                begin: "'",
                end: "'",
                illegal: '\\n',
                contains: [BACKSLASH_ESCAPE],
            };
            const QUOTE_STRING_MODE = {
                scope: 'string',
                begin: '"',
                end: '"',
                illegal: '\\n',
                contains: [BACKSLASH_ESCAPE],
            };
            const PHRASAL_WORDS_MODE = {
                begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
            };
            const COMMENT = function (begin, end, modeOptions = {}) {
                const mode = inherit$1(
                    {
                        scope: 'comment',
                        begin,
                        end,
                        contains: [],
                    },
                    modeOptions
                );
                mode.contains.push({
                    scope: 'doctag',
                    // hack to avoid the space from being included. the space is necessary to
                    // match here to prevent the plain text rule below from gobbling up doctags
                    begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',
                    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
                    excludeBegin: true,
                    relevance: 0,
                });
                const ENGLISH_WORD = either(
                    // list of common 1 and 2 letter words in English
                    'I',
                    'a',
                    'is',
                    'so',
                    'us',
                    'to',
                    'at',
                    'if',
                    'in',
                    'it',
                    'on',
                    // note: this is not an exhaustive list of contractions, just popular ones
                    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
                    // contractions - can't we'd they're let's, etc
                    /[A-Za-z]+[-][a-z]+/,
                    // `no-way`, etc.
                    /[A-Za-z][a-z]{2,}/
                    // allow capitalized words at beginning of sentences
                );
                mode.contains.push({
                    // TODO: how to include ", (, ) without breaking grammars that use these for
                    // comment delimiters?
                    // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
                    // ---
                    // this tries to find sequences of 3 english words in a row (without any
                    // "programming" type syntax) this gives us a strong signal that we've
                    // TRULY found a comment - vs perhaps scanning with the wrong language.
                    // It's possible to find something that LOOKS like the start of the
                    // comment - but then if there is no readable text - good chance it is a
                    // false match and not a comment.
                    //
                    // for a visual example please see:
                    // https://github.com/highlightjs/highlight.js/issues/2827
                    begin: concat(
                        /[ ]+/,
                        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
                        '(',
                        ENGLISH_WORD,
                        /[.]?[:]?([.][ ]|[ ])/,
                        '){3}'
                    ),
                    // look for 3 words in a row
                });
                return mode;
            };
            const C_LINE_COMMENT_MODE = COMMENT('//', '$');
            const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
            const HASH_COMMENT_MODE = COMMENT('#', '$');
            const NUMBER_MODE = {
                scope: 'number',
                begin: NUMBER_RE,
                relevance: 0,
            };
            const C_NUMBER_MODE = {
                scope: 'number',
                begin: C_NUMBER_RE,
                relevance: 0,
            };
            const BINARY_NUMBER_MODE = {
                scope: 'number',
                begin: BINARY_NUMBER_RE,
                relevance: 0,
            };
            const REGEXP_MODE = {
                scope: 'regexp',
                begin: /\/(?=[^/\n]*\/)/,
                end: /\/[gimuy]*/,
                contains: [
                    BACKSLASH_ESCAPE,
                    {
                        begin: /\[/,
                        end: /\]/,
                        relevance: 0,
                        contains: [BACKSLASH_ESCAPE],
                    },
                ],
            };
            const TITLE_MODE = {
                scope: 'title',
                begin: IDENT_RE,
                relevance: 0,
            };
            const UNDERSCORE_TITLE_MODE = {
                scope: 'title',
                begin: UNDERSCORE_IDENT_RE,
                relevance: 0,
            };
            const METHOD_GUARD = {
                // excludes method names from keyword processing
                begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
                relevance: 0,
            };
            const END_SAME_AS_BEGIN = function (mode) {
                return Object.assign(mode, {
                    /** @type {ModeCallback} */
                    'on:begin': (m, resp) => {
                        resp.data._beginMatch = m[1];
                    },
                    /** @type {ModeCallback} */
                    'on:end': (m, resp) => {
                        if (resp.data._beginMatch !== m[1]) resp.ignoreMatch();
                    },
                });
            };
            var MODES = /* @__PURE__ */ Object.freeze({
                __proto__: null,
                APOS_STRING_MODE,
                BACKSLASH_ESCAPE,
                BINARY_NUMBER_MODE,
                BINARY_NUMBER_RE,
                COMMENT,
                C_BLOCK_COMMENT_MODE,
                C_LINE_COMMENT_MODE,
                C_NUMBER_MODE,
                C_NUMBER_RE,
                END_SAME_AS_BEGIN,
                HASH_COMMENT_MODE,
                IDENT_RE,
                MATCH_NOTHING_RE,
                METHOD_GUARD,
                NUMBER_MODE,
                NUMBER_RE,
                PHRASAL_WORDS_MODE,
                QUOTE_STRING_MODE,
                REGEXP_MODE,
                RE_STARTERS_RE,
                SHEBANG,
                TITLE_MODE,
                UNDERSCORE_IDENT_RE,
                UNDERSCORE_TITLE_MODE,
            });
            function skipIfHasPrecedingDot(match, response) {
                const before = match.input[match.index - 1];
                if (before === '.') {
                    response.ignoreMatch();
                }
            }
            function scopeClassName(mode, _parent) {
                if (mode.className !== void 0) {
                    mode.scope = mode.className;
                    delete mode.className;
                }
            }
            function beginKeywords(mode, parent) {
                if (!parent) return;
                if (!mode.beginKeywords) return;
                mode.begin =
                    '\\b(' +
                    mode.beginKeywords.split(' ').join('|') +
                    ')(?!\\.)(?=\\b|\\s)';
                mode.__beforeBegin = skipIfHasPrecedingDot;
                mode.keywords = mode.keywords || mode.beginKeywords;
                delete mode.beginKeywords;
                if (mode.relevance === void 0) mode.relevance = 0;
            }
            function compileIllegal(mode, _parent) {
                if (!Array.isArray(mode.illegal)) return;
                mode.illegal = either(...mode.illegal);
            }
            function compileMatch(mode, _parent) {
                if (!mode.match) return;
                if (mode.begin || mode.end)
                    throw new Error('begin & end are not supported with match');
                mode.begin = mode.match;
                delete mode.match;
            }
            function compileRelevance(mode, _parent) {
                if (mode.relevance === void 0) mode.relevance = 1;
            }
            const beforeMatchExt = (mode, parent) => {
                if (!mode.beforeMatch) return;
                if (mode.starts)
                    throw new Error('beforeMatch cannot be used with starts');
                const originalMode = Object.assign({}, mode);
                Object.keys(mode).forEach((key) => {
                    delete mode[key];
                });
                mode.keywords = originalMode.keywords;
                mode.begin = concat(
                    originalMode.beforeMatch,
                    lookahead(originalMode.begin)
                );
                mode.starts = {
                    relevance: 0,
                    contains: [
                        Object.assign(originalMode, { endsParent: true }),
                    ],
                };
                mode.relevance = 0;
                delete originalMode.beforeMatch;
            };
            const COMMON_KEYWORDS = [
                'of',
                'and',
                'for',
                'in',
                'not',
                'or',
                'if',
                'then',
                'parent',
                // common variable name
                'list',
                // common variable name
                'value',
                // common variable name
            ];
            const DEFAULT_KEYWORD_SCOPE = 'keyword';
            function compileKeywords(
                rawKeywords,
                caseInsensitive,
                scopeName = DEFAULT_KEYWORD_SCOPE
            ) {
                const compiledKeywords = /* @__PURE__ */ Object.create(null);
                if (typeof rawKeywords === 'string') {
                    compileList(scopeName, rawKeywords.split(' '));
                } else if (Array.isArray(rawKeywords)) {
                    compileList(scopeName, rawKeywords);
                } else {
                    Object.keys(rawKeywords).forEach(function (scopeName2) {
                        Object.assign(
                            compiledKeywords,
                            compileKeywords(
                                rawKeywords[scopeName2],
                                caseInsensitive,
                                scopeName2
                            )
                        );
                    });
                }
                return compiledKeywords;
                function compileList(scopeName2, keywordList) {
                    if (caseInsensitive) {
                        keywordList = keywordList.map((x) => x.toLowerCase());
                    }
                    keywordList.forEach(function (keyword) {
                        const pair = keyword.split('|');
                        compiledKeywords[pair[0]] = [
                            scopeName2,
                            scoreForKeyword(pair[0], pair[1]),
                        ];
                    });
                }
            }
            function scoreForKeyword(keyword, providedScore) {
                if (providedScore) {
                    return Number(providedScore);
                }
                return commonKeyword(keyword) ? 0 : 1;
            }
            function commonKeyword(keyword) {
                return COMMON_KEYWORDS.includes(keyword.toLowerCase());
            }
            const seenDeprecations = {};
            const error = (message) => {
                console.error(message);
            };
            const warn = (message, ...args) => {
                console.log(`WARN: ${message}`, ...args);
            };
            const deprecated = (version2, message) => {
                if (seenDeprecations[`${version2}/${message}`]) return;
                console.log(`Deprecated as of ${version2}. ${message}`);
                seenDeprecations[`${version2}/${message}`] = true;
            };
            const MultiClassError = new Error();
            function remapScopeNames(mode, regexes, { key }) {
                let offset = 0;
                const scopeNames = mode[key];
                const emit = {};
                const positions = {};
                for (let i = 1; i <= regexes.length; i++) {
                    positions[i + offset] = scopeNames[i];
                    emit[i + offset] = true;
                    offset += countMatchGroups(regexes[i - 1]);
                }
                mode[key] = positions;
                mode[key]._emit = emit;
                mode[key]._multi = true;
            }
            function beginMultiClass(mode) {
                if (!Array.isArray(mode.begin)) return;
                if (mode.skip || mode.excludeBegin || mode.returnBegin) {
                    error(
                        'skip, excludeBegin, returnBegin not compatible with beginScope: {}'
                    );
                    throw MultiClassError;
                }
                if (
                    typeof mode.beginScope !== 'object' ||
                    mode.beginScope === null
                ) {
                    error('beginScope must be object');
                    throw MultiClassError;
                }
                remapScopeNames(mode, mode.begin, { key: 'beginScope' });
                mode.begin = _rewriteBackreferences(mode.begin, {
                    joinWith: '',
                });
            }
            function endMultiClass(mode) {
                if (!Array.isArray(mode.end)) return;
                if (mode.skip || mode.excludeEnd || mode.returnEnd) {
                    error(
                        'skip, excludeEnd, returnEnd not compatible with endScope: {}'
                    );
                    throw MultiClassError;
                }
                if (
                    typeof mode.endScope !== 'object' ||
                    mode.endScope === null
                ) {
                    error('endScope must be object');
                    throw MultiClassError;
                }
                remapScopeNames(mode, mode.end, { key: 'endScope' });
                mode.end = _rewriteBackreferences(mode.end, { joinWith: '' });
            }
            function scopeSugar(mode) {
                if (
                    mode.scope &&
                    typeof mode.scope === 'object' &&
                    mode.scope !== null
                ) {
                    mode.beginScope = mode.scope;
                    delete mode.scope;
                }
            }
            function MultiClass(mode) {
                scopeSugar(mode);
                if (typeof mode.beginScope === 'string') {
                    mode.beginScope = { _wrap: mode.beginScope };
                }
                if (typeof mode.endScope === 'string') {
                    mode.endScope = { _wrap: mode.endScope };
                }
                beginMultiClass(mode);
                endMultiClass(mode);
            }
            function compileLanguage(language) {
                function langRe(value, global) {
                    return new RegExp(
                        source(value),
                        'm' +
                            (language.case_insensitive ? 'i' : '') +
                            (language.unicodeRegex ? 'u' : '') +
                            (global ? 'g' : '')
                    );
                }
                class MultiRegex {
                    constructor() {
                        this.matchIndexes = {};
                        this.regexes = [];
                        this.matchAt = 1;
                        this.position = 0;
                    }
                    // @ts-ignore
                    addRule(re, opts) {
                        opts.position = this.position++;
                        this.matchIndexes[this.matchAt] = opts;
                        this.regexes.push([opts, re]);
                        this.matchAt += countMatchGroups(re) + 1;
                    }
                    compile() {
                        if (this.regexes.length === 0) {
                            this.exec = () => null;
                        }
                        const terminators = this.regexes.map((el) => el[1]);
                        this.matcherRe = langRe(
                            _rewriteBackreferences(terminators, {
                                joinWith: '|',
                            }),
                            true
                        );
                        this.lastIndex = 0;
                    }
                    /** @param {string} s */
                    exec(s) {
                        this.matcherRe.lastIndex = this.lastIndex;
                        const match = this.matcherRe.exec(s);
                        if (!match) {
                            return null;
                        }
                        const i = match.findIndex(
                            (el, i2) => i2 > 0 && el !== void 0
                        );
                        const matchData = this.matchIndexes[i];
                        match.splice(0, i);
                        return Object.assign(match, matchData);
                    }
                }
                class ResumableMultiRegex {
                    constructor() {
                        this.rules = [];
                        this.multiRegexes = [];
                        this.count = 0;
                        this.lastIndex = 0;
                        this.regexIndex = 0;
                    }
                    // @ts-ignore
                    getMatcher(index) {
                        if (this.multiRegexes[index])
                            return this.multiRegexes[index];
                        const matcher = new MultiRegex();
                        this.rules
                            .slice(index)
                            .forEach(([re, opts]) => matcher.addRule(re, opts));
                        matcher.compile();
                        this.multiRegexes[index] = matcher;
                        return matcher;
                    }
                    resumingScanAtSamePosition() {
                        return this.regexIndex !== 0;
                    }
                    considerAll() {
                        this.regexIndex = 0;
                    }
                    // @ts-ignore
                    addRule(re, opts) {
                        this.rules.push([re, opts]);
                        if (opts.type === 'begin') this.count++;
                    }
                    /** @param {string} s */
                    exec(s) {
                        const m = this.getMatcher(this.regexIndex);
                        m.lastIndex = this.lastIndex;
                        let result = m.exec(s);
                        if (this.resumingScanAtSamePosition()) {
                            if (result && result.index === this.lastIndex);
                            else {
                                const m2 = this.getMatcher(0);
                                m2.lastIndex = this.lastIndex + 1;
                                result = m2.exec(s);
                            }
                        }
                        if (result) {
                            this.regexIndex += result.position + 1;
                            if (this.regexIndex === this.count) {
                                this.considerAll();
                            }
                        }
                        return result;
                    }
                }
                function buildModeRegex(mode) {
                    const mm = new ResumableMultiRegex();
                    mode.contains.forEach((term) =>
                        mm.addRule(term.begin, { rule: term, type: 'begin' })
                    );
                    if (mode.terminatorEnd) {
                        mm.addRule(mode.terminatorEnd, { type: 'end' });
                    }
                    if (mode.illegal) {
                        mm.addRule(mode.illegal, { type: 'illegal' });
                    }
                    return mm;
                }
                function compileMode(mode, parent) {
                    const cmode =
                        /** @type CompiledMode */
                        mode;
                    if (mode.isCompiled) return cmode;
                    [
                        scopeClassName,
                        // do this early so compiler extensions generally don't have to worry about
                        // the distinction between match/begin
                        compileMatch,
                        MultiClass,
                        beforeMatchExt,
                    ].forEach((ext) => ext(mode, parent));
                    language.compilerExtensions.forEach((ext) =>
                        ext(mode, parent)
                    );
                    mode.__beforeBegin = null;
                    [
                        beginKeywords,
                        // do this later so compiler extensions that come earlier have access to the
                        // raw array if they wanted to perhaps manipulate it, etc.
                        compileIllegal,
                        // default to 1 relevance if not specified
                        compileRelevance,
                    ].forEach((ext) => ext(mode, parent));
                    mode.isCompiled = true;
                    let keywordPattern = null;
                    if (
                        typeof mode.keywords === 'object' &&
                        mode.keywords.$pattern
                    ) {
                        mode.keywords = Object.assign({}, mode.keywords);
                        keywordPattern = mode.keywords.$pattern;
                        delete mode.keywords.$pattern;
                    }
                    keywordPattern = keywordPattern || /\w+/;
                    if (mode.keywords) {
                        mode.keywords = compileKeywords(
                            mode.keywords,
                            language.case_insensitive
                        );
                    }
                    cmode.keywordPatternRe = langRe(keywordPattern, true);
                    if (parent) {
                        if (!mode.begin) mode.begin = /\B|\b/;
                        cmode.beginRe = langRe(cmode.begin);
                        if (!mode.end && !mode.endsWithParent)
                            mode.end = /\B|\b/;
                        if (mode.end) cmode.endRe = langRe(cmode.end);
                        cmode.terminatorEnd = source(cmode.end) || '';
                        if (mode.endsWithParent && parent.terminatorEnd) {
                            cmode.terminatorEnd +=
                                (mode.end ? '|' : '') + parent.terminatorEnd;
                        }
                    }
                    if (mode.illegal)
                        cmode.illegalRe = langRe(
                            /** @type {RegExp | string} */
                            mode.illegal
                        );
                    if (!mode.contains) mode.contains = [];
                    mode.contains = [].concat(
                        ...mode.contains.map(function (c) {
                            return expandOrCloneMode(c === 'self' ? mode : c);
                        })
                    );
                    mode.contains.forEach(function (c) {
                        compileMode(
                            /** @type Mode */
                            c,
                            cmode
                        );
                    });
                    if (mode.starts) {
                        compileMode(mode.starts, parent);
                    }
                    cmode.matcher = buildModeRegex(cmode);
                    return cmode;
                }
                if (!language.compilerExtensions)
                    language.compilerExtensions = [];
                if (language.contains && language.contains.includes('self')) {
                    throw new Error(
                        'ERR: contains `self` is not supported at the top-level of a language.  See documentation.'
                    );
                }
                language.classNameAliases = inherit$1(
                    language.classNameAliases || {}
                );
                return compileMode(
                    /** @type Mode */
                    language
                );
            }
            function dependencyOnParent(mode) {
                if (!mode) return false;
                return mode.endsWithParent || dependencyOnParent(mode.starts);
            }
            function expandOrCloneMode(mode) {
                if (mode.variants && !mode.cachedVariants) {
                    mode.cachedVariants = mode.variants.map(function (variant) {
                        return inherit$1(mode, { variants: null }, variant);
                    });
                }
                if (mode.cachedVariants) {
                    return mode.cachedVariants;
                }
                if (dependencyOnParent(mode)) {
                    return inherit$1(mode, {
                        starts: mode.starts ? inherit$1(mode.starts) : null,
                    });
                }
                if (Object.isFrozen(mode)) {
                    return inherit$1(mode);
                }
                return mode;
            }
            var version = '11.9.0';
            class HTMLInjectionError extends Error {
                constructor(reason, html) {
                    super(reason);
                    this.name = 'HTMLInjectionError';
                    this.html = html;
                }
            }
            const escape = escapeHTML;
            const inherit = inherit$1;
            const NO_MATCH = Symbol('nomatch');
            const MAX_KEYWORD_HITS = 7;
            const HLJS = function (hljs2) {
                const languages = /* @__PURE__ */ Object.create(null);
                const aliases = /* @__PURE__ */ Object.create(null);
                const plugins = [];
                let SAFE_MODE = true;
                const LANGUAGE_NOT_FOUND =
                    "Could not find the language '{}', did you forget to load/include a language module?";
                const PLAINTEXT_LANGUAGE = {
                    disableAutodetect: true,
                    name: 'Plain text',
                    contains: [],
                };
                let options = {
                    ignoreUnescapedHTML: false,
                    throwUnescapedHTML: false,
                    noHighlightRe: /^(no-?highlight)$/i,
                    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
                    classPrefix: 'hljs-',
                    cssSelector: 'pre code',
                    languages: null,
                    // beta configuration options, subject to change, welcome to discuss
                    // https://github.com/highlightjs/highlight.js/issues/1086
                    __emitter: TokenTreeEmitter,
                };
                function shouldNotHighlight(languageName) {
                    return options.noHighlightRe.test(languageName);
                }
                function blockLanguage(block) {
                    let classes = block.className + ' ';
                    classes += block.parentNode
                        ? block.parentNode.className
                        : '';
                    const match = options.languageDetectRe.exec(classes);
                    if (match) {
                        const language = getLanguage(match[1]);
                        if (!language) {
                            warn(LANGUAGE_NOT_FOUND.replace('{}', match[1]));
                            warn(
                                'Falling back to no-highlight mode for this block.',
                                block
                            );
                        }
                        return language ? match[1] : 'no-highlight';
                    }
                    return classes
                        .split(/\s+/)
                        .find(
                            (_class) =>
                                shouldNotHighlight(_class) ||
                                getLanguage(_class)
                        );
                }
                function highlight2(
                    codeOrLanguageName,
                    optionsOrCode,
                    ignoreIllegals
                ) {
                    let code = '';
                    let languageName = '';
                    if (typeof optionsOrCode === 'object') {
                        code = codeOrLanguageName;
                        ignoreIllegals = optionsOrCode.ignoreIllegals;
                        languageName = optionsOrCode.language;
                    } else {
                        deprecated(
                            '10.7.0',
                            'highlight(lang, code, ...args) has been deprecated.'
                        );
                        deprecated(
                            '10.7.0',
                            'Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277'
                        );
                        languageName = codeOrLanguageName;
                        code = optionsOrCode;
                    }
                    if (ignoreIllegals === void 0) {
                        ignoreIllegals = true;
                    }
                    const context = {
                        code,
                        language: languageName,
                    };
                    fire('before:highlight', context);
                    const result = context.result
                        ? context.result
                        : _highlight(
                              context.language,
                              context.code,
                              ignoreIllegals
                          );
                    result.code = context.code;
                    fire('after:highlight', result);
                    return result;
                }
                function _highlight(
                    languageName,
                    codeToHighlight,
                    ignoreIllegals,
                    continuation
                ) {
                    const keywordHits = /* @__PURE__ */ Object.create(null);
                    function keywordData(mode, matchText) {
                        return mode.keywords[matchText];
                    }
                    function processKeywords() {
                        if (!top.keywords) {
                            emitter.addText(modeBuffer);
                            return;
                        }
                        let lastIndex = 0;
                        top.keywordPatternRe.lastIndex = 0;
                        let match = top.keywordPatternRe.exec(modeBuffer);
                        let buf = '';
                        while (match) {
                            buf += modeBuffer.substring(lastIndex, match.index);
                            const word = language.case_insensitive
                                ? match[0].toLowerCase()
                                : match[0];
                            const data = keywordData(top, word);
                            if (data) {
                                const [kind, keywordRelevance] = data;
                                emitter.addText(buf);
                                buf = '';
                                keywordHits[word] =
                                    (keywordHits[word] || 0) + 1;
                                if (keywordHits[word] <= MAX_KEYWORD_HITS)
                                    relevance += keywordRelevance;
                                if (kind.startsWith('_')) {
                                    buf += match[0];
                                } else {
                                    const cssClass =
                                        language.classNameAliases[kind] || kind;
                                    emitKeyword(match[0], cssClass);
                                }
                            } else {
                                buf += match[0];
                            }
                            lastIndex = top.keywordPatternRe.lastIndex;
                            match = top.keywordPatternRe.exec(modeBuffer);
                        }
                        buf += modeBuffer.substring(lastIndex);
                        emitter.addText(buf);
                    }
                    function processSubLanguage() {
                        if (modeBuffer === '') return;
                        let result2 = null;
                        if (typeof top.subLanguage === 'string') {
                            if (!languages[top.subLanguage]) {
                                emitter.addText(modeBuffer);
                                return;
                            }
                            result2 = _highlight(
                                top.subLanguage,
                                modeBuffer,
                                true,
                                continuations[top.subLanguage]
                            );
                            continuations[top.subLanguage] =
                                /** @type {CompiledMode} */
                                result2._top;
                        } else {
                            result2 = highlightAuto(
                                modeBuffer,
                                top.subLanguage.length ? top.subLanguage : null
                            );
                        }
                        if (top.relevance > 0) {
                            relevance += result2.relevance;
                        }
                        emitter.__addSublanguage(
                            result2._emitter,
                            result2.language
                        );
                    }
                    function processBuffer() {
                        if (top.subLanguage != null) {
                            processSubLanguage();
                        } else {
                            processKeywords();
                        }
                        modeBuffer = '';
                    }
                    function emitKeyword(keyword, scope) {
                        if (keyword === '') return;
                        emitter.startScope(scope);
                        emitter.addText(keyword);
                        emitter.endScope();
                    }
                    function emitMultiClass(scope, match) {
                        let i = 1;
                        const max = match.length - 1;
                        while (i <= max) {
                            if (!scope._emit[i]) {
                                i++;
                                continue;
                            }
                            const klass =
                                language.classNameAliases[scope[i]] || scope[i];
                            const text2 = match[i];
                            if (klass) {
                                emitKeyword(text2, klass);
                            } else {
                                modeBuffer = text2;
                                processKeywords();
                                modeBuffer = '';
                            }
                            i++;
                        }
                    }
                    function startNewMode(mode, match) {
                        if (mode.scope && typeof mode.scope === 'string') {
                            emitter.openNode(
                                language.classNameAliases[mode.scope] ||
                                    mode.scope
                            );
                        }
                        if (mode.beginScope) {
                            if (mode.beginScope._wrap) {
                                emitKeyword(
                                    modeBuffer,
                                    language.classNameAliases[
                                        mode.beginScope._wrap
                                    ] || mode.beginScope._wrap
                                );
                                modeBuffer = '';
                            } else if (mode.beginScope._multi) {
                                emitMultiClass(mode.beginScope, match);
                                modeBuffer = '';
                            }
                        }
                        top = Object.create(mode, { parent: { value: top } });
                        return top;
                    }
                    function endOfMode(mode, match, matchPlusRemainder) {
                        let matched = startsWith(
                            mode.endRe,
                            matchPlusRemainder
                        );
                        if (matched) {
                            if (mode['on:end']) {
                                const resp = new Response(mode);
                                mode['on:end'](match, resp);
                                if (resp.isMatchIgnored) matched = false;
                            }
                            if (matched) {
                                while (mode.endsParent && mode.parent) {
                                    mode = mode.parent;
                                }
                                return mode;
                            }
                        }
                        if (mode.endsWithParent) {
                            return endOfMode(
                                mode.parent,
                                match,
                                matchPlusRemainder
                            );
                        }
                    }
                    function doIgnore(lexeme) {
                        if (top.matcher.regexIndex === 0) {
                            modeBuffer += lexeme[0];
                            return 1;
                        } else {
                            resumeScanAtSamePosition = true;
                            return 0;
                        }
                    }
                    function doBeginMatch(match) {
                        const lexeme = match[0];
                        const newMode = match.rule;
                        const resp = new Response(newMode);
                        const beforeCallbacks = [
                            newMode.__beforeBegin,
                            newMode['on:begin'],
                        ];
                        for (const cb of beforeCallbacks) {
                            if (!cb) continue;
                            cb(match, resp);
                            if (resp.isMatchIgnored) return doIgnore(lexeme);
                        }
                        if (newMode.skip) {
                            modeBuffer += lexeme;
                        } else {
                            if (newMode.excludeBegin) {
                                modeBuffer += lexeme;
                            }
                            processBuffer();
                            if (!newMode.returnBegin && !newMode.excludeBegin) {
                                modeBuffer = lexeme;
                            }
                        }
                        startNewMode(newMode, match);
                        return newMode.returnBegin ? 0 : lexeme.length;
                    }
                    function doEndMatch(match) {
                        const lexeme = match[0];
                        const matchPlusRemainder = codeToHighlight.substring(
                            match.index
                        );
                        const endMode = endOfMode(
                            top,
                            match,
                            matchPlusRemainder
                        );
                        if (!endMode) {
                            return NO_MATCH;
                        }
                        const origin = top;
                        if (top.endScope && top.endScope._wrap) {
                            processBuffer();
                            emitKeyword(lexeme, top.endScope._wrap);
                        } else if (top.endScope && top.endScope._multi) {
                            processBuffer();
                            emitMultiClass(top.endScope, match);
                        } else if (origin.skip) {
                            modeBuffer += lexeme;
                        } else {
                            if (!(origin.returnEnd || origin.excludeEnd)) {
                                modeBuffer += lexeme;
                            }
                            processBuffer();
                            if (origin.excludeEnd) {
                                modeBuffer = lexeme;
                            }
                        }
                        do {
                            if (top.scope) {
                                emitter.closeNode();
                            }
                            if (!top.skip && !top.subLanguage) {
                                relevance += top.relevance;
                            }
                            top = top.parent;
                        } while (top !== endMode.parent);
                        if (endMode.starts) {
                            startNewMode(endMode.starts, match);
                        }
                        return origin.returnEnd ? 0 : lexeme.length;
                    }
                    function processContinuations() {
                        const list2 = [];
                        for (
                            let current = top;
                            current !== language;
                            current = current.parent
                        ) {
                            if (current.scope) {
                                list2.unshift(current.scope);
                            }
                        }
                        list2.forEach((item) => emitter.openNode(item));
                    }
                    let lastMatch = {};
                    function processLexeme(textBeforeMatch, match) {
                        const lexeme = match && match[0];
                        modeBuffer += textBeforeMatch;
                        if (lexeme == null) {
                            processBuffer();
                            return 0;
                        }
                        if (
                            lastMatch.type === 'begin' &&
                            match.type === 'end' &&
                            lastMatch.index === match.index &&
                            lexeme === ''
                        ) {
                            modeBuffer += codeToHighlight.slice(
                                match.index,
                                match.index + 1
                            );
                            if (!SAFE_MODE) {
                                const err = new Error(
                                    `0 width match regex (${languageName})`
                                );
                                err.languageName = languageName;
                                err.badRule = lastMatch.rule;
                                throw err;
                            }
                            return 1;
                        }
                        lastMatch = match;
                        if (match.type === 'begin') {
                            return doBeginMatch(match);
                        } else if (
                            match.type === 'illegal' &&
                            !ignoreIllegals
                        ) {
                            const err = new Error(
                                'Illegal lexeme "' +
                                    lexeme +
                                    '" for mode "' +
                                    (top.scope || '<unnamed>') +
                                    '"'
                            );
                            err.mode = top;
                            throw err;
                        } else if (match.type === 'end') {
                            const processed = doEndMatch(match);
                            if (processed !== NO_MATCH) {
                                return processed;
                            }
                        }
                        if (match.type === 'illegal' && lexeme === '') {
                            return 1;
                        }
                        if (iterations > 1e5 && iterations > match.index * 3) {
                            const err = new Error(
                                'potential infinite loop, way more iterations than matches'
                            );
                            throw err;
                        }
                        modeBuffer += lexeme;
                        return lexeme.length;
                    }
                    const language = getLanguage(languageName);
                    if (!language) {
                        error(LANGUAGE_NOT_FOUND.replace('{}', languageName));
                        throw new Error(
                            'Unknown language: "' + languageName + '"'
                        );
                    }
                    const md = compileLanguage(language);
                    let result = '';
                    let top = continuation || md;
                    const continuations = {};
                    const emitter = new options.__emitter(options);
                    processContinuations();
                    let modeBuffer = '';
                    let relevance = 0;
                    let index = 0;
                    let iterations = 0;
                    let resumeScanAtSamePosition = false;
                    try {
                        if (!language.__emitTokens) {
                            top.matcher.considerAll();
                            for (;;) {
                                iterations++;
                                if (resumeScanAtSamePosition) {
                                    resumeScanAtSamePosition = false;
                                } else {
                                    top.matcher.considerAll();
                                }
                                top.matcher.lastIndex = index;
                                const match = top.matcher.exec(codeToHighlight);
                                if (!match) break;
                                const beforeMatch = codeToHighlight.substring(
                                    index,
                                    match.index
                                );
                                const processedCount = processLexeme(
                                    beforeMatch,
                                    match
                                );
                                index = match.index + processedCount;
                            }
                            processLexeme(codeToHighlight.substring(index));
                        } else {
                            language.__emitTokens(codeToHighlight, emitter);
                        }
                        emitter.finalize();
                        result = emitter.toHTML();
                        return {
                            language: languageName,
                            value: result,
                            relevance,
                            illegal: false,
                            _emitter: emitter,
                            _top: top,
                        };
                    } catch (err) {
                        if (err.message && err.message.includes('Illegal')) {
                            return {
                                language: languageName,
                                value: escape(codeToHighlight),
                                illegal: true,
                                relevance: 0,
                                _illegalBy: {
                                    message: err.message,
                                    index,
                                    context: codeToHighlight.slice(
                                        index - 100,
                                        index + 100
                                    ),
                                    mode: err.mode,
                                    resultSoFar: result,
                                },
                                _emitter: emitter,
                            };
                        } else if (SAFE_MODE) {
                            return {
                                language: languageName,
                                value: escape(codeToHighlight),
                                illegal: false,
                                relevance: 0,
                                errorRaised: err,
                                _emitter: emitter,
                                _top: top,
                            };
                        } else {
                            throw err;
                        }
                    }
                }
                function justTextHighlightResult(code) {
                    const result = {
                        value: escape(code),
                        illegal: false,
                        relevance: 0,
                        _top: PLAINTEXT_LANGUAGE,
                        _emitter: new options.__emitter(options),
                    };
                    result._emitter.addText(code);
                    return result;
                }
                function highlightAuto(code, languageSubset) {
                    languageSubset =
                        languageSubset ||
                        options.languages ||
                        Object.keys(languages);
                    const plaintext = justTextHighlightResult(code);
                    const results = languageSubset
                        .filter(getLanguage)
                        .filter(autoDetection)
                        .map((name) => _highlight(name, code, false));
                    results.unshift(plaintext);
                    const sorted = results.sort((a, b) => {
                        if (a.relevance !== b.relevance)
                            return b.relevance - a.relevance;
                        if (a.language && b.language) {
                            if (
                                getLanguage(a.language).supersetOf ===
                                b.language
                            ) {
                                return 1;
                            } else if (
                                getLanguage(b.language).supersetOf ===
                                a.language
                            ) {
                                return -1;
                            }
                        }
                        return 0;
                    });
                    const [best, secondBest] = sorted;
                    const result = best;
                    result.secondBest = secondBest;
                    return result;
                }
                function updateClassName(element2, currentLang, resultLang) {
                    const language =
                        (currentLang && aliases[currentLang]) || resultLang;
                    element2.classList.add('hljs');
                    element2.classList.add(`language-${language}`);
                }
                function highlightElement(element2) {
                    let node = null;
                    const language = blockLanguage(element2);
                    if (shouldNotHighlight(language)) return;
                    fire('before:highlightElement', { el: element2, language });
                    if (element2.dataset.highlighted) {
                        console.log(
                            'Element previously highlighted. To highlight again, first unset `dataset.highlighted`.',
                            element2
                        );
                        return;
                    }
                    if (element2.children.length > 0) {
                        if (!options.ignoreUnescapedHTML) {
                            console.warn(
                                'One of your code blocks includes unescaped HTML. This is a potentially serious security risk.'
                            );
                            console.warn(
                                'https://github.com/highlightjs/highlight.js/wiki/security'
                            );
                            console.warn('The element with unescaped HTML:');
                            console.warn(element2);
                        }
                        if (options.throwUnescapedHTML) {
                            const err = new HTMLInjectionError(
                                'One of your code blocks includes unescaped HTML.',
                                element2.innerHTML
                            );
                            throw err;
                        }
                    }
                    node = element2;
                    const text2 = node.textContent;
                    const result = language
                        ? highlight2(text2, { language, ignoreIllegals: true })
                        : highlightAuto(text2);
                    element2.innerHTML = result.value;
                    element2.dataset.highlighted = 'yes';
                    updateClassName(element2, language, result.language);
                    element2.result = {
                        language: result.language,
                        // TODO: remove with version 11.0
                        re: result.relevance,
                        relevance: result.relevance,
                    };
                    if (result.secondBest) {
                        element2.secondBest = {
                            language: result.secondBest.language,
                            relevance: result.secondBest.relevance,
                        };
                    }
                    fire('after:highlightElement', {
                        el: element2,
                        result,
                        text: text2,
                    });
                }
                function configure(userOptions) {
                    options = inherit(options, userOptions);
                }
                const initHighlighting = () => {
                    highlightAll();
                    deprecated(
                        '10.6.0',
                        'initHighlighting() deprecated.  Use highlightAll() now.'
                    );
                };
                function initHighlightingOnLoad() {
                    highlightAll();
                    deprecated(
                        '10.6.0',
                        'initHighlightingOnLoad() deprecated.  Use highlightAll() now.'
                    );
                }
                let wantsHighlight = false;
                function highlightAll() {
                    if (document.readyState === 'loading') {
                        wantsHighlight = true;
                        return;
                    }
                    const blocks = document.querySelectorAll(
                        options.cssSelector
                    );
                    blocks.forEach(highlightElement);
                }
                function boot() {
                    if (wantsHighlight) highlightAll();
                }
                if (typeof window !== 'undefined' && window.addEventListener) {
                    window.addEventListener('DOMContentLoaded', boot, false);
                }
                function registerLanguage(languageName, languageDefinition) {
                    let lang = null;
                    try {
                        lang = languageDefinition(hljs2);
                    } catch (error$1) {
                        error(
                            "Language definition for '{}' could not be registered.".replace(
                                '{}',
                                languageName
                            )
                        );
                        if (!SAFE_MODE) {
                            throw error$1;
                        } else {
                            error(error$1);
                        }
                        lang = PLAINTEXT_LANGUAGE;
                    }
                    if (!lang.name) lang.name = languageName;
                    languages[languageName] = lang;
                    lang.rawDefinition = languageDefinition.bind(null, hljs2);
                    if (lang.aliases) {
                        registerAliases(lang.aliases, { languageName });
                    }
                }
                function unregisterLanguage(languageName) {
                    delete languages[languageName];
                    for (const alias of Object.keys(aliases)) {
                        if (aliases[alias] === languageName) {
                            delete aliases[alias];
                        }
                    }
                }
                function listLanguages() {
                    return Object.keys(languages);
                }
                function getLanguage(name) {
                    name = (name || '').toLowerCase();
                    return languages[name] || languages[aliases[name]];
                }
                function registerAliases(aliasList, { languageName }) {
                    if (typeof aliasList === 'string') {
                        aliasList = [aliasList];
                    }
                    aliasList.forEach((alias) => {
                        aliases[alias.toLowerCase()] = languageName;
                    });
                }
                function autoDetection(name) {
                    const lang = getLanguage(name);
                    return lang && !lang.disableAutodetect;
                }
                function upgradePluginAPI(plugin) {
                    if (
                        plugin['before:highlightBlock'] &&
                        !plugin['before:highlightElement']
                    ) {
                        plugin['before:highlightElement'] = (data) => {
                            plugin['before:highlightBlock'](
                                Object.assign({ block: data.el }, data)
                            );
                        };
                    }
                    if (
                        plugin['after:highlightBlock'] &&
                        !plugin['after:highlightElement']
                    ) {
                        plugin['after:highlightElement'] = (data) => {
                            plugin['after:highlightBlock'](
                                Object.assign({ block: data.el }, data)
                            );
                        };
                    }
                }
                function addPlugin(plugin) {
                    upgradePluginAPI(plugin);
                    plugins.push(plugin);
                }
                function removePlugin(plugin) {
                    const index = plugins.indexOf(plugin);
                    if (index !== -1) {
                        plugins.splice(index, 1);
                    }
                }
                function fire(event, args) {
                    const cb = event;
                    plugins.forEach(function (plugin) {
                        if (plugin[cb]) {
                            plugin[cb](args);
                        }
                    });
                }
                function deprecateHighlightBlock(el) {
                    deprecated(
                        '10.7.0',
                        'highlightBlock will be removed entirely in v12.0'
                    );
                    deprecated('10.7.0', 'Please use highlightElement now.');
                    return highlightElement(el);
                }
                Object.assign(hljs2, {
                    highlight: highlight2,
                    highlightAuto,
                    highlightAll,
                    highlightElement,
                    // TODO: Remove with v12 API
                    highlightBlock: deprecateHighlightBlock,
                    configure,
                    initHighlighting,
                    initHighlightingOnLoad,
                    registerLanguage,
                    unregisterLanguage,
                    listLanguages,
                    getLanguage,
                    registerAliases,
                    autoDetection,
                    inherit,
                    addPlugin,
                    removePlugin,
                });
                hljs2.debugMode = function () {
                    SAFE_MODE = false;
                };
                hljs2.safeMode = function () {
                    SAFE_MODE = true;
                };
                hljs2.versionString = version;
                hljs2.regex = {
                    concat,
                    lookahead,
                    either,
                    optional,
                    anyNumberOfTimes,
                };
                for (const key in MODES) {
                    if (typeof MODES[key] === 'object') {
                        deepFreeze(MODES[key]);
                    }
                }
                Object.assign(hljs2, MODES);
                return hljs2;
            };
            const highlight = HLJS({});
            highlight.newInstance = () => HLJS({});
            var core = highlight;
            highlight.HighlightJS = highlight;
            highlight.default = highlight;
            var xml_1;
            var hasRequiredXml;
            function requireXml() {
                if (hasRequiredXml) return xml_1;
                hasRequiredXml = 1;
                function xml(hljs2) {
                    const regex = hljs2.regex;
                    const TAG_NAME_RE = regex.concat(
                        /[\p{L}_]/u,
                        regex.optional(/[\p{L}0-9_.-]*:/u),
                        /[\p{L}0-9_.-]*/u
                    );
                    const XML_IDENT_RE = /[\p{L}0-9._:-]+/u;
                    const XML_ENTITIES = {
                        className: 'symbol',
                        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/,
                    };
                    const XML_META_KEYWORDS = {
                        begin: /\s/,
                        contains: [
                            {
                                className: 'keyword',
                                begin: /#?[a-z_][a-z1-9_-]+/,
                                illegal: /\n/,
                            },
                        ],
                    };
                    const XML_META_PAR_KEYWORDS = hljs2.inherit(
                        XML_META_KEYWORDS,
                        {
                            begin: /\(/,
                            end: /\)/,
                        }
                    );
                    const APOS_META_STRING_MODE = hljs2.inherit(
                        hljs2.APOS_STRING_MODE,
                        { className: 'string' }
                    );
                    const QUOTE_META_STRING_MODE = hljs2.inherit(
                        hljs2.QUOTE_STRING_MODE,
                        { className: 'string' }
                    );
                    const TAG_INTERNALS = {
                        endsWithParent: true,
                        illegal: /</,
                        relevance: 0,
                        contains: [
                            {
                                className: 'attr',
                                begin: XML_IDENT_RE,
                                relevance: 0,
                            },
                            {
                                begin: /=\s*/,
                                relevance: 0,
                                contains: [
                                    {
                                        className: 'string',
                                        endsParent: true,
                                        variants: [
                                            {
                                                begin: /"/,
                                                end: /"/,
                                                contains: [XML_ENTITIES],
                                            },
                                            {
                                                begin: /'/,
                                                end: /'/,
                                                contains: [XML_ENTITIES],
                                            },
                                            { begin: /[^\s"'=<>`]+/ },
                                        ],
                                    },
                                ],
                            },
                        ],
                    };
                    return {
                        name: 'HTML, XML',
                        aliases: [
                            'html',
                            'xhtml',
                            'rss',
                            'atom',
                            'xjb',
                            'xsd',
                            'xsl',
                            'plist',
                            'wsf',
                            'svg',
                        ],
                        case_insensitive: true,
                        unicodeRegex: true,
                        contains: [
                            {
                                className: 'meta',
                                begin: /<![a-z]/,
                                end: />/,
                                relevance: 10,
                                contains: [
                                    XML_META_KEYWORDS,
                                    QUOTE_META_STRING_MODE,
                                    APOS_META_STRING_MODE,
                                    XML_META_PAR_KEYWORDS,
                                    {
                                        begin: /\[/,
                                        end: /\]/,
                                        contains: [
                                            {
                                                className: 'meta',
                                                begin: /<![a-z]/,
                                                end: />/,
                                                contains: [
                                                    XML_META_KEYWORDS,
                                                    XML_META_PAR_KEYWORDS,
                                                    QUOTE_META_STRING_MODE,
                                                    APOS_META_STRING_MODE,
                                                ],
                                            },
                                        ],
                                    },
                                ],
                            },
                            hljs2.COMMENT(/<!--/, /-->/, { relevance: 10 }),
                            {
                                begin: /<!\[CDATA\[/,
                                end: /\]\]>/,
                                relevance: 10,
                            },
                            XML_ENTITIES,
                            // xml processing instructions
                            {
                                className: 'meta',
                                end: /\?>/,
                                variants: [
                                    {
                                        begin: /<\?xml/,
                                        relevance: 10,
                                        contains: [QUOTE_META_STRING_MODE],
                                    },
                                    {
                                        begin: /<\?[a-z][a-z0-9]+/,
                                    },
                                ],
                            },
                            {
                                className: 'tag',
                                /*
          The lookahead pattern (?=...) ensures that 'begin' only matches
          '<style' as a single word, followed by a whitespace or an
          ending bracket.
          */
                                begin: /<style(?=\s|>)/,
                                end: />/,
                                keywords: { name: 'style' },
                                contains: [TAG_INTERNALS],
                                starts: {
                                    end: /<\/style>/,
                                    returnEnd: true,
                                    subLanguage: ['css', 'xml'],
                                },
                            },
                            {
                                className: 'tag',
                                // See the comment in the <style tag about the lookahead pattern
                                begin: /<script(?=\s|>)/,
                                end: />/,
                                keywords: { name: 'script' },
                                contains: [TAG_INTERNALS],
                                starts: {
                                    end: /<\/script>/,
                                    returnEnd: true,
                                    subLanguage: [
                                        'javascript',
                                        'handlebars',
                                        'xml',
                                    ],
                                },
                            },
                            // we need this for now for jSX
                            {
                                className: 'tag',
                                begin: /<>|<\/>/,
                            },
                            // open tag
                            {
                                className: 'tag',
                                begin: regex.concat(
                                    /</,
                                    regex.lookahead(
                                        regex.concat(
                                            TAG_NAME_RE,
                                            // <tag/>
                                            // <tag>
                                            // <tag ...
                                            regex.either(/\/>/, />/, /\s/)
                                        )
                                    )
                                ),
                                end: /\/?>/,
                                contains: [
                                    {
                                        className: 'name',
                                        begin: TAG_NAME_RE,
                                        relevance: 0,
                                        starts: TAG_INTERNALS,
                                    },
                                ],
                            },
                            // close tag
                            {
                                className: 'tag',
                                begin: regex.concat(
                                    /<\//,
                                    regex.lookahead(
                                        regex.concat(TAG_NAME_RE, />/)
                                    )
                                ),
                                contains: [
                                    {
                                        className: 'name',
                                        begin: TAG_NAME_RE,
                                        relevance: 0,
                                    },
                                    {
                                        begin: />/,
                                        relevance: 0,
                                        endsParent: true,
                                    },
                                ],
                            },
                        ],
                    };
                }
                xml_1 = xml;
                return xml_1;
            }
            var bash_1;
            var hasRequiredBash;
            function requireBash() {
                if (hasRequiredBash) return bash_1;
                hasRequiredBash = 1;
                function bash(hljs2) {
                    const regex = hljs2.regex;
                    const VAR = {};
                    const BRACED_VAR = {
                        begin: /\$\{/,
                        end: /\}/,
                        contains: [
                            'self',
                            {
                                begin: /:-/,
                                contains: [VAR],
                            },
                            // default values
                        ],
                    };
                    Object.assign(VAR, {
                        className: 'variable',
                        variants: [
                            {
                                begin: regex.concat(
                                    /\$[\w\d#@][\w\d_]*/,
                                    // negative look-ahead tries to avoid matching patterns that are not
                                    // Perl at all like $ident$, @ident@, etc.
                                    `(?![\\w\\d])(?![$])`
                                ),
                            },
                            BRACED_VAR,
                        ],
                    });
                    const SUBST = {
                        className: 'subst',
                        begin: /\$\(/,
                        end: /\)/,
                        contains: [hljs2.BACKSLASH_ESCAPE],
                    };
                    const HERE_DOC = {
                        begin: /<<-?\s*(?=\w+)/,
                        starts: {
                            contains: [
                                hljs2.END_SAME_AS_BEGIN({
                                    begin: /(\w+)/,
                                    end: /(\w+)/,
                                    className: 'string',
                                }),
                            ],
                        },
                    };
                    const QUOTE_STRING = {
                        className: 'string',
                        begin: /"/,
                        end: /"/,
                        contains: [hljs2.BACKSLASH_ESCAPE, VAR, SUBST],
                    };
                    SUBST.contains.push(QUOTE_STRING);
                    const ESCAPED_QUOTE = {
                        match: /\\"/,
                    };
                    const APOS_STRING = {
                        className: 'string',
                        begin: /'/,
                        end: /'/,
                    };
                    const ESCAPED_APOS = {
                        match: /\\'/,
                    };
                    const ARITHMETIC = {
                        begin: /\$?\(\(/,
                        end: /\)\)/,
                        contains: [
                            {
                                begin: /\d+#[0-9a-f]+/,
                                className: 'number',
                            },
                            hljs2.NUMBER_MODE,
                            VAR,
                        ],
                    };
                    const SH_LIKE_SHELLS = [
                        'fish',
                        'bash',
                        'zsh',
                        'sh',
                        'csh',
                        'ksh',
                        'tcsh',
                        'dash',
                        'scsh',
                    ];
                    const KNOWN_SHEBANG = hljs2.SHEBANG({
                        binary: `(${SH_LIKE_SHELLS.join('|')})`,
                        relevance: 10,
                    });
                    const FUNCTION = {
                        className: 'function',
                        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
                        returnBegin: true,
                        contains: [
                            hljs2.inherit(hljs2.TITLE_MODE, {
                                begin: /\w[\w\d_]*/,
                            }),
                        ],
                        relevance: 0,
                    };
                    const KEYWORDS = [
                        'if',
                        'then',
                        'else',
                        'elif',
                        'fi',
                        'for',
                        'while',
                        'until',
                        'in',
                        'do',
                        'done',
                        'case',
                        'esac',
                        'function',
                        'select',
                    ];
                    const LITERALS = ['true', 'false'];
                    const PATH_MODE = { match: /(\/[a-z._-]+)+/ };
                    const SHELL_BUILT_INS = [
                        'break',
                        'cd',
                        'continue',
                        'eval',
                        'exec',
                        'exit',
                        'export',
                        'getopts',
                        'hash',
                        'pwd',
                        'readonly',
                        'return',
                        'shift',
                        'test',
                        'times',
                        'trap',
                        'umask',
                        'unset',
                    ];
                    const BASH_BUILT_INS = [
                        'alias',
                        'bind',
                        'builtin',
                        'caller',
                        'command',
                        'declare',
                        'echo',
                        'enable',
                        'help',
                        'let',
                        'local',
                        'logout',
                        'mapfile',
                        'printf',
                        'read',
                        'readarray',
                        'source',
                        'type',
                        'typeset',
                        'ulimit',
                        'unalias',
                    ];
                    const ZSH_BUILT_INS = [
                        'autoload',
                        'bg',
                        'bindkey',
                        'bye',
                        'cap',
                        'chdir',
                        'clone',
                        'comparguments',
                        'compcall',
                        'compctl',
                        'compdescribe',
                        'compfiles',
                        'compgroups',
                        'compquote',
                        'comptags',
                        'comptry',
                        'compvalues',
                        'dirs',
                        'disable',
                        'disown',
                        'echotc',
                        'echoti',
                        'emulate',
                        'fc',
                        'fg',
                        'float',
                        'functions',
                        'getcap',
                        'getln',
                        'history',
                        'integer',
                        'jobs',
                        'kill',
                        'limit',
                        'log',
                        'noglob',
                        'popd',
                        'print',
                        'pushd',
                        'pushln',
                        'rehash',
                        'sched',
                        'setcap',
                        'setopt',
                        'stat',
                        'suspend',
                        'ttyctl',
                        'unfunction',
                        'unhash',
                        'unlimit',
                        'unsetopt',
                        'vared',
                        'wait',
                        'whence',
                        'where',
                        'which',
                        'zcompile',
                        'zformat',
                        'zftp',
                        'zle',
                        'zmodload',
                        'zparseopts',
                        'zprof',
                        'zpty',
                        'zregexparse',
                        'zsocket',
                        'zstyle',
                        'ztcp',
                    ];
                    const GNU_CORE_UTILS = [
                        'chcon',
                        'chgrp',
                        'chown',
                        'chmod',
                        'cp',
                        'dd',
                        'df',
                        'dir',
                        'dircolors',
                        'ln',
                        'ls',
                        'mkdir',
                        'mkfifo',
                        'mknod',
                        'mktemp',
                        'mv',
                        'realpath',
                        'rm',
                        'rmdir',
                        'shred',
                        'sync',
                        'touch',
                        'truncate',
                        'vdir',
                        'b2sum',
                        'base32',
                        'base64',
                        'cat',
                        'cksum',
                        'comm',
                        'csplit',
                        'cut',
                        'expand',
                        'fmt',
                        'fold',
                        'head',
                        'join',
                        'md5sum',
                        'nl',
                        'numfmt',
                        'od',
                        'paste',
                        'ptx',
                        'pr',
                        'sha1sum',
                        'sha224sum',
                        'sha256sum',
                        'sha384sum',
                        'sha512sum',
                        'shuf',
                        'sort',
                        'split',
                        'sum',
                        'tac',
                        'tail',
                        'tr',
                        'tsort',
                        'unexpand',
                        'uniq',
                        'wc',
                        'arch',
                        'basename',
                        'chroot',
                        'date',
                        'dirname',
                        'du',
                        'echo',
                        'env',
                        'expr',
                        'factor',
                        // "false", // keyword literal already
                        'groups',
                        'hostid',
                        'id',
                        'link',
                        'logname',
                        'nice',
                        'nohup',
                        'nproc',
                        'pathchk',
                        'pinky',
                        'printenv',
                        'printf',
                        'pwd',
                        'readlink',
                        'runcon',
                        'seq',
                        'sleep',
                        'stat',
                        'stdbuf',
                        'stty',
                        'tee',
                        'test',
                        'timeout',
                        // "true", // keyword literal already
                        'tty',
                        'uname',
                        'unlink',
                        'uptime',
                        'users',
                        'who',
                        'whoami',
                        'yes',
                    ];
                    return {
                        name: 'Bash',
                        aliases: ['sh'],
                        keywords: {
                            $pattern: /\b[a-z][a-z0-9._-]+\b/,
                            keyword: KEYWORDS,
                            literal: LITERALS,
                            built_in: [
                                ...SHELL_BUILT_INS,
                                ...BASH_BUILT_INS,
                                // Shell modifiers
                                'set',
                                'shopt',
                                ...ZSH_BUILT_INS,
                                ...GNU_CORE_UTILS,
                            ],
                        },
                        contains: [
                            KNOWN_SHEBANG,
                            // to catch known shells and boost relevancy
                            hljs2.SHEBANG(),
                            // to catch unknown shells but still highlight the shebang
                            FUNCTION,
                            ARITHMETIC,
                            hljs2.HASH_COMMENT_MODE,
                            HERE_DOC,
                            PATH_MODE,
                            QUOTE_STRING,
                            ESCAPED_QUOTE,
                            APOS_STRING,
                            ESCAPED_APOS,
                            VAR,
                        ],
                    };
                }
                bash_1 = bash;
                return bash_1;
            }
            var c_1;
            var hasRequiredC;
            function requireC() {
                if (hasRequiredC) return c_1;
                hasRequiredC = 1;
                function c(hljs2) {
                    const regex = hljs2.regex;
                    const C_LINE_COMMENT_MODE2 = hljs2.COMMENT('//', '$', {
                        contains: [{ begin: /\\\n/ }],
                    });
                    const DECLTYPE_AUTO_RE = 'decltype\\(auto\\)';
                    const NAMESPACE_RE = '[a-zA-Z_]\\w*::';
                    const TEMPLATE_ARGUMENT_RE = '<[^<>]+>';
                    const FUNCTION_TYPE_RE =
                        '(' +
                        DECLTYPE_AUTO_RE +
                        '|' +
                        regex.optional(NAMESPACE_RE) +
                        '[a-zA-Z_]\\w*' +
                        regex.optional(TEMPLATE_ARGUMENT_RE) +
                        ')';
                    const TYPES = {
                        className: 'type',
                        variants: [
                            { begin: '\\b[a-z\\d_]*_t\\b' },
                            { match: /\batomic_[a-z]{3,6}\b/ },
                        ],
                    };
                    const CHARACTER_ESCAPES =
                        '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)';
                    const STRINGS = {
                        className: 'string',
                        variants: [
                            {
                                begin: '(u8?|U|L)?"',
                                end: '"',
                                illegal: '\\n',
                                contains: [hljs2.BACKSLASH_ESCAPE],
                            },
                            {
                                begin:
                                    "(u8?|U|L)?'(" + CHARACTER_ESCAPES + '|.)',
                                end: "'",
                                illegal: '.',
                            },
                            hljs2.END_SAME_AS_BEGIN({
                                begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
                                end: /\)([^()\\ ]{0,16})"/,
                            }),
                        ],
                    };
                    const NUMBERS = {
                        className: 'number',
                        variants: [
                            { begin: "\\b(0b[01']+)" },
                            {
                                begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)",
                            },
                            {
                                begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)",
                            },
                        ],
                        relevance: 0,
                    };
                    const PREPROCESSOR = {
                        className: 'meta',
                        begin: /#\s*[a-z]+\b/,
                        end: /$/,
                        keywords: {
                            keyword:
                                'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include',
                        },
                        contains: [
                            {
                                begin: /\\\n/,
                                relevance: 0,
                            },
                            hljs2.inherit(STRINGS, { className: 'string' }),
                            {
                                className: 'string',
                                begin: /<.*?>/,
                            },
                            C_LINE_COMMENT_MODE2,
                            hljs2.C_BLOCK_COMMENT_MODE,
                        ],
                    };
                    const TITLE_MODE2 = {
                        className: 'title',
                        begin: regex.optional(NAMESPACE_RE) + hljs2.IDENT_RE,
                        relevance: 0,
                    };
                    const FUNCTION_TITLE =
                        regex.optional(NAMESPACE_RE) +
                        hljs2.IDENT_RE +
                        '\\s*\\(';
                    const C_KEYWORDS = [
                        'asm',
                        'auto',
                        'break',
                        'case',
                        'continue',
                        'default',
                        'do',
                        'else',
                        'enum',
                        'extern',
                        'for',
                        'fortran',
                        'goto',
                        'if',
                        'inline',
                        'register',
                        'restrict',
                        'return',
                        'sizeof',
                        'struct',
                        'switch',
                        'typedef',
                        'union',
                        'volatile',
                        'while',
                        '_Alignas',
                        '_Alignof',
                        '_Atomic',
                        '_Generic',
                        '_Noreturn',
                        '_Static_assert',
                        '_Thread_local',
                        // aliases
                        'alignas',
                        'alignof',
                        'noreturn',
                        'static_assert',
                        'thread_local',
                        // not a C keyword but is, for all intents and purposes, treated exactly like one.
                        '_Pragma',
                    ];
                    const C_TYPES = [
                        'float',
                        'double',
                        'signed',
                        'unsigned',
                        'int',
                        'short',
                        'long',
                        'char',
                        'void',
                        '_Bool',
                        '_Complex',
                        '_Imaginary',
                        '_Decimal32',
                        '_Decimal64',
                        '_Decimal128',
                        // modifiers
                        'const',
                        'static',
                        // aliases
                        'complex',
                        'bool',
                        'imaginary',
                    ];
                    const KEYWORDS = {
                        keyword: C_KEYWORDS,
                        type: C_TYPES,
                        literal: 'true false NULL',
                        // TODO: apply hinting work similar to what was done in cpp.js
                        built_in:
                            'std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr',
                    };
                    const EXPRESSION_CONTAINS = [
                        PREPROCESSOR,
                        TYPES,
                        C_LINE_COMMENT_MODE2,
                        hljs2.C_BLOCK_COMMENT_MODE,
                        NUMBERS,
                        STRINGS,
                    ];
                    const EXPRESSION_CONTEXT = {
                        // This mode covers expression context where we can't expect a function
                        // definition and shouldn't highlight anything that looks like one:
                        // `return some()`, `else if()`, `(x*sum(1, 2))`
                        variants: [
                            {
                                begin: /=/,
                                end: /;/,
                            },
                            {
                                begin: /\(/,
                                end: /\)/,
                            },
                            {
                                beginKeywords: 'new throw return else',
                                end: /;/,
                            },
                        ],
                        keywords: KEYWORDS,
                        contains: EXPRESSION_CONTAINS.concat([
                            {
                                begin: /\(/,
                                end: /\)/,
                                keywords: KEYWORDS,
                                contains: EXPRESSION_CONTAINS.concat(['self']),
                                relevance: 0,
                            },
                        ]),
                        relevance: 0,
                    };
                    const FUNCTION_DECLARATION = {
                        begin:
                            '(' +
                            FUNCTION_TYPE_RE +
                            '[\\*&\\s]+)+' +
                            FUNCTION_TITLE,
                        returnBegin: true,
                        end: /[{;=]/,
                        excludeEnd: true,
                        keywords: KEYWORDS,
                        illegal: /[^\w\s\*&:<>.]/,
                        contains: [
                            {
                                // to prevent it from being confused as the function title
                                begin: DECLTYPE_AUTO_RE,
                                keywords: KEYWORDS,
                                relevance: 0,
                            },
                            {
                                begin: FUNCTION_TITLE,
                                returnBegin: true,
                                contains: [
                                    hljs2.inherit(TITLE_MODE2, {
                                        className: 'title.function',
                                    }),
                                ],
                                relevance: 0,
                            },
                            // allow for multiple declarations, e.g.:
                            // extern void f(int), g(char);
                            {
                                relevance: 0,
                                match: /,/,
                            },
                            {
                                className: 'params',
                                begin: /\(/,
                                end: /\)/,
                                keywords: KEYWORDS,
                                relevance: 0,
                                contains: [
                                    C_LINE_COMMENT_MODE2,
                                    hljs2.C_BLOCK_COMMENT_MODE,
                                    STRINGS,
                                    NUMBERS,
                                    TYPES,
                                    // Count matching parentheses.
                                    {
                                        begin: /\(/,
                                        end: /\)/,
                                        keywords: KEYWORDS,
                                        relevance: 0,
                                        contains: [
                                            'self',
                                            C_LINE_COMMENT_MODE2,
                                            hljs2.C_BLOCK_COMMENT_MODE,
                                            STRINGS,
                                            NUMBERS,
                                            TYPES,
                                        ],
                                    },
                                ],
                            },
                            TYPES,
                            C_LINE_COMMENT_MODE2,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            PREPROCESSOR,
                        ],
                    };
                    return {
                        name: 'C',
                        aliases: ['h'],
                        keywords: KEYWORDS,
                        // Until differentiations are added between `c` and `cpp`, `c` will
                        // not be auto-detected to avoid auto-detect conflicts between C and C++
                        disableAutodetect: true,
                        illegal: '</',
                        contains: [].concat(
                            EXPRESSION_CONTEXT,
                            FUNCTION_DECLARATION,
                            EXPRESSION_CONTAINS,
                            [
                                PREPROCESSOR,
                                {
                                    begin: hljs2.IDENT_RE + '::',
                                    keywords: KEYWORDS,
                                },
                                {
                                    className: 'class',
                                    beginKeywords: 'enum class struct union',
                                    end: /[{;:<>=]/,
                                    contains: [
                                        { beginKeywords: 'final class struct' },
                                        hljs2.TITLE_MODE,
                                    ],
                                },
                            ]
                        ),
                        exports: {
                            preprocessor: PREPROCESSOR,
                            strings: STRINGS,
                            keywords: KEYWORDS,
                        },
                    };
                }
                c_1 = c;
                return c_1;
            }
            var cpp_1;
            var hasRequiredCpp;
            function requireCpp() {
                if (hasRequiredCpp) return cpp_1;
                hasRequiredCpp = 1;
                function cpp(hljs2) {
                    const regex = hljs2.regex;
                    const C_LINE_COMMENT_MODE2 = hljs2.COMMENT('//', '$', {
                        contains: [{ begin: /\\\n/ }],
                    });
                    const DECLTYPE_AUTO_RE = 'decltype\\(auto\\)';
                    const NAMESPACE_RE = '[a-zA-Z_]\\w*::';
                    const TEMPLATE_ARGUMENT_RE = '<[^<>]+>';
                    const FUNCTION_TYPE_RE =
                        '(?!struct)(' +
                        DECLTYPE_AUTO_RE +
                        '|' +
                        regex.optional(NAMESPACE_RE) +
                        '[a-zA-Z_]\\w*' +
                        regex.optional(TEMPLATE_ARGUMENT_RE) +
                        ')';
                    const CPP_PRIMITIVE_TYPES = {
                        className: 'type',
                        begin: '\\b[a-z\\d_]*_t\\b',
                    };
                    const CHARACTER_ESCAPES =
                        '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)';
                    const STRINGS = {
                        className: 'string',
                        variants: [
                            {
                                begin: '(u8?|U|L)?"',
                                end: '"',
                                illegal: '\\n',
                                contains: [hljs2.BACKSLASH_ESCAPE],
                            },
                            {
                                begin:
                                    "(u8?|U|L)?'(" + CHARACTER_ESCAPES + '|.)',
                                end: "'",
                                illegal: '.',
                            },
                            hljs2.END_SAME_AS_BEGIN({
                                begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
                                end: /\)([^()\\ ]{0,16})"/,
                            }),
                        ],
                    };
                    const NUMBERS = {
                        className: 'number',
                        variants: [
                            { begin: "\\b(0b[01']+)" },
                            {
                                begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)",
                            },
                            {
                                begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)",
                            },
                        ],
                        relevance: 0,
                    };
                    const PREPROCESSOR = {
                        className: 'meta',
                        begin: /#\s*[a-z]+\b/,
                        end: /$/,
                        keywords: {
                            keyword:
                                'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include',
                        },
                        contains: [
                            {
                                begin: /\\\n/,
                                relevance: 0,
                            },
                            hljs2.inherit(STRINGS, { className: 'string' }),
                            {
                                className: 'string',
                                begin: /<.*?>/,
                            },
                            C_LINE_COMMENT_MODE2,
                            hljs2.C_BLOCK_COMMENT_MODE,
                        ],
                    };
                    const TITLE_MODE2 = {
                        className: 'title',
                        begin: regex.optional(NAMESPACE_RE) + hljs2.IDENT_RE,
                        relevance: 0,
                    };
                    const FUNCTION_TITLE =
                        regex.optional(NAMESPACE_RE) +
                        hljs2.IDENT_RE +
                        '\\s*\\(';
                    const RESERVED_KEYWORDS = [
                        'alignas',
                        'alignof',
                        'and',
                        'and_eq',
                        'asm',
                        'atomic_cancel',
                        'atomic_commit',
                        'atomic_noexcept',
                        'auto',
                        'bitand',
                        'bitor',
                        'break',
                        'case',
                        'catch',
                        'class',
                        'co_await',
                        'co_return',
                        'co_yield',
                        'compl',
                        'concept',
                        'const_cast|10',
                        'consteval',
                        'constexpr',
                        'constinit',
                        'continue',
                        'decltype',
                        'default',
                        'delete',
                        'do',
                        'dynamic_cast|10',
                        'else',
                        'enum',
                        'explicit',
                        'export',
                        'extern',
                        'false',
                        'final',
                        'for',
                        'friend',
                        'goto',
                        'if',
                        'import',
                        'inline',
                        'module',
                        'mutable',
                        'namespace',
                        'new',
                        'noexcept',
                        'not',
                        'not_eq',
                        'nullptr',
                        'operator',
                        'or',
                        'or_eq',
                        'override',
                        'private',
                        'protected',
                        'public',
                        'reflexpr',
                        'register',
                        'reinterpret_cast|10',
                        'requires',
                        'return',
                        'sizeof',
                        'static_assert',
                        'static_cast|10',
                        'struct',
                        'switch',
                        'synchronized',
                        'template',
                        'this',
                        'thread_local',
                        'throw',
                        'transaction_safe',
                        'transaction_safe_dynamic',
                        'true',
                        'try',
                        'typedef',
                        'typeid',
                        'typename',
                        'union',
                        'using',
                        'virtual',
                        'volatile',
                        'while',
                        'xor',
                        'xor_eq',
                    ];
                    const RESERVED_TYPES = [
                        'bool',
                        'char',
                        'char16_t',
                        'char32_t',
                        'char8_t',
                        'double',
                        'float',
                        'int',
                        'long',
                        'short',
                        'void',
                        'wchar_t',
                        'unsigned',
                        'signed',
                        'const',
                        'static',
                    ];
                    const TYPE_HINTS = [
                        'any',
                        'auto_ptr',
                        'barrier',
                        'binary_semaphore',
                        'bitset',
                        'complex',
                        'condition_variable',
                        'condition_variable_any',
                        'counting_semaphore',
                        'deque',
                        'false_type',
                        'future',
                        'imaginary',
                        'initializer_list',
                        'istringstream',
                        'jthread',
                        'latch',
                        'lock_guard',
                        'multimap',
                        'multiset',
                        'mutex',
                        'optional',
                        'ostringstream',
                        'packaged_task',
                        'pair',
                        'promise',
                        'priority_queue',
                        'queue',
                        'recursive_mutex',
                        'recursive_timed_mutex',
                        'scoped_lock',
                        'set',
                        'shared_future',
                        'shared_lock',
                        'shared_mutex',
                        'shared_timed_mutex',
                        'shared_ptr',
                        'stack',
                        'string_view',
                        'stringstream',
                        'timed_mutex',
                        'thread',
                        'true_type',
                        'tuple',
                        'unique_lock',
                        'unique_ptr',
                        'unordered_map',
                        'unordered_multimap',
                        'unordered_multiset',
                        'unordered_set',
                        'variant',
                        'vector',
                        'weak_ptr',
                        'wstring',
                        'wstring_view',
                    ];
                    const FUNCTION_HINTS = [
                        'abort',
                        'abs',
                        'acos',
                        'apply',
                        'as_const',
                        'asin',
                        'atan',
                        'atan2',
                        'calloc',
                        'ceil',
                        'cerr',
                        'cin',
                        'clog',
                        'cos',
                        'cosh',
                        'cout',
                        'declval',
                        'endl',
                        'exchange',
                        'exit',
                        'exp',
                        'fabs',
                        'floor',
                        'fmod',
                        'forward',
                        'fprintf',
                        'fputs',
                        'free',
                        'frexp',
                        'fscanf',
                        'future',
                        'invoke',
                        'isalnum',
                        'isalpha',
                        'iscntrl',
                        'isdigit',
                        'isgraph',
                        'islower',
                        'isprint',
                        'ispunct',
                        'isspace',
                        'isupper',
                        'isxdigit',
                        'labs',
                        'launder',
                        'ldexp',
                        'log',
                        'log10',
                        'make_pair',
                        'make_shared',
                        'make_shared_for_overwrite',
                        'make_tuple',
                        'make_unique',
                        'malloc',
                        'memchr',
                        'memcmp',
                        'memcpy',
                        'memset',
                        'modf',
                        'move',
                        'pow',
                        'printf',
                        'putchar',
                        'puts',
                        'realloc',
                        'scanf',
                        'sin',
                        'sinh',
                        'snprintf',
                        'sprintf',
                        'sqrt',
                        'sscanf',
                        'std',
                        'stderr',
                        'stdin',
                        'stdout',
                        'strcat',
                        'strchr',
                        'strcmp',
                        'strcpy',
                        'strcspn',
                        'strlen',
                        'strncat',
                        'strncmp',
                        'strncpy',
                        'strpbrk',
                        'strrchr',
                        'strspn',
                        'strstr',
                        'swap',
                        'tan',
                        'tanh',
                        'terminate',
                        'to_underlying',
                        'tolower',
                        'toupper',
                        'vfprintf',
                        'visit',
                        'vprintf',
                        'vsprintf',
                    ];
                    const LITERALS = [
                        'NULL',
                        'false',
                        'nullopt',
                        'nullptr',
                        'true',
                    ];
                    const BUILT_IN = ['_Pragma'];
                    const CPP_KEYWORDS = {
                        type: RESERVED_TYPES,
                        keyword: RESERVED_KEYWORDS,
                        literal: LITERALS,
                        built_in: BUILT_IN,
                        _type_hints: TYPE_HINTS,
                    };
                    const FUNCTION_DISPATCH = {
                        className: 'function.dispatch',
                        relevance: 0,
                        keywords: {
                            // Only for relevance, not highlighting.
                            _hint: FUNCTION_HINTS,
                        },
                        begin: regex.concat(
                            /\b/,
                            /(?!decltype)/,
                            /(?!if)/,
                            /(?!for)/,
                            /(?!switch)/,
                            /(?!while)/,
                            hljs2.IDENT_RE,
                            regex.lookahead(/(<[^<>]+>|)\s*\(/)
                        ),
                    };
                    const EXPRESSION_CONTAINS = [
                        FUNCTION_DISPATCH,
                        PREPROCESSOR,
                        CPP_PRIMITIVE_TYPES,
                        C_LINE_COMMENT_MODE2,
                        hljs2.C_BLOCK_COMMENT_MODE,
                        NUMBERS,
                        STRINGS,
                    ];
                    const EXPRESSION_CONTEXT = {
                        // This mode covers expression context where we can't expect a function
                        // definition and shouldn't highlight anything that looks like one:
                        // `return some()`, `else if()`, `(x*sum(1, 2))`
                        variants: [
                            {
                                begin: /=/,
                                end: /;/,
                            },
                            {
                                begin: /\(/,
                                end: /\)/,
                            },
                            {
                                beginKeywords: 'new throw return else',
                                end: /;/,
                            },
                        ],
                        keywords: CPP_KEYWORDS,
                        contains: EXPRESSION_CONTAINS.concat([
                            {
                                begin: /\(/,
                                end: /\)/,
                                keywords: CPP_KEYWORDS,
                                contains: EXPRESSION_CONTAINS.concat(['self']),
                                relevance: 0,
                            },
                        ]),
                        relevance: 0,
                    };
                    const FUNCTION_DECLARATION = {
                        className: 'function',
                        begin:
                            '(' +
                            FUNCTION_TYPE_RE +
                            '[\\*&\\s]+)+' +
                            FUNCTION_TITLE,
                        returnBegin: true,
                        end: /[{;=]/,
                        excludeEnd: true,
                        keywords: CPP_KEYWORDS,
                        illegal: /[^\w\s\*&:<>.]/,
                        contains: [
                            {
                                // to prevent it from being confused as the function title
                                begin: DECLTYPE_AUTO_RE,
                                keywords: CPP_KEYWORDS,
                                relevance: 0,
                            },
                            {
                                begin: FUNCTION_TITLE,
                                returnBegin: true,
                                contains: [TITLE_MODE2],
                                relevance: 0,
                            },
                            // needed because we do not have look-behind on the below rule
                            // to prevent it from grabbing the final : in a :: pair
                            {
                                begin: /::/,
                                relevance: 0,
                            },
                            // initializers
                            {
                                begin: /:/,
                                endsWithParent: true,
                                contains: [STRINGS, NUMBERS],
                            },
                            // allow for multiple declarations, e.g.:
                            // extern void f(int), g(char);
                            {
                                relevance: 0,
                                match: /,/,
                            },
                            {
                                className: 'params',
                                begin: /\(/,
                                end: /\)/,
                                keywords: CPP_KEYWORDS,
                                relevance: 0,
                                contains: [
                                    C_LINE_COMMENT_MODE2,
                                    hljs2.C_BLOCK_COMMENT_MODE,
                                    STRINGS,
                                    NUMBERS,
                                    CPP_PRIMITIVE_TYPES,
                                    // Count matching parentheses.
                                    {
                                        begin: /\(/,
                                        end: /\)/,
                                        keywords: CPP_KEYWORDS,
                                        relevance: 0,
                                        contains: [
                                            'self',
                                            C_LINE_COMMENT_MODE2,
                                            hljs2.C_BLOCK_COMMENT_MODE,
                                            STRINGS,
                                            NUMBERS,
                                            CPP_PRIMITIVE_TYPES,
                                        ],
                                    },
                                ],
                            },
                            CPP_PRIMITIVE_TYPES,
                            C_LINE_COMMENT_MODE2,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            PREPROCESSOR,
                        ],
                    };
                    return {
                        name: 'C++',
                        aliases: [
                            'cc',
                            'c++',
                            'h++',
                            'hpp',
                            'hh',
                            'hxx',
                            'cxx',
                        ],
                        keywords: CPP_KEYWORDS,
                        illegal: '</',
                        classNameAliases: { 'function.dispatch': 'built_in' },
                        contains: [].concat(
                            EXPRESSION_CONTEXT,
                            FUNCTION_DECLARATION,
                            FUNCTION_DISPATCH,
                            EXPRESSION_CONTAINS,
                            [
                                PREPROCESSOR,
                                {
                                    // containers: ie, `vector <int> rooms (9);`
                                    begin: '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)',
                                    end: '>',
                                    keywords: CPP_KEYWORDS,
                                    contains: ['self', CPP_PRIMITIVE_TYPES],
                                },
                                {
                                    begin: hljs2.IDENT_RE + '::',
                                    keywords: CPP_KEYWORDS,
                                },
                                {
                                    match: [
                                        // extra complexity to deal with `enum class` and `enum struct`
                                        /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
                                        /\s+/,
                                        /\w+/,
                                    ],
                                    className: {
                                        1: 'keyword',
                                        3: 'title.class',
                                    },
                                },
                            ]
                        ),
                    };
                }
                cpp_1 = cpp;
                return cpp_1;
            }
            var csharp_1;
            var hasRequiredCsharp;
            function requireCsharp() {
                if (hasRequiredCsharp) return csharp_1;
                hasRequiredCsharp = 1;
                function csharp(hljs2) {
                    const BUILT_IN_KEYWORDS = [
                        'bool',
                        'byte',
                        'char',
                        'decimal',
                        'delegate',
                        'double',
                        'dynamic',
                        'enum',
                        'float',
                        'int',
                        'long',
                        'nint',
                        'nuint',
                        'object',
                        'sbyte',
                        'short',
                        'string',
                        'ulong',
                        'uint',
                        'ushort',
                    ];
                    const FUNCTION_MODIFIERS = [
                        'public',
                        'private',
                        'protected',
                        'static',
                        'internal',
                        'protected',
                        'abstract',
                        'async',
                        'extern',
                        'override',
                        'unsafe',
                        'virtual',
                        'new',
                        'sealed',
                        'partial',
                    ];
                    const LITERAL_KEYWORDS = [
                        'default',
                        'false',
                        'null',
                        'true',
                    ];
                    const NORMAL_KEYWORDS = [
                        'abstract',
                        'as',
                        'base',
                        'break',
                        'case',
                        'catch',
                        'class',
                        'const',
                        'continue',
                        'do',
                        'else',
                        'event',
                        'explicit',
                        'extern',
                        'finally',
                        'fixed',
                        'for',
                        'foreach',
                        'goto',
                        'if',
                        'implicit',
                        'in',
                        'interface',
                        'internal',
                        'is',
                        'lock',
                        'namespace',
                        'new',
                        'operator',
                        'out',
                        'override',
                        'params',
                        'private',
                        'protected',
                        'public',
                        'readonly',
                        'record',
                        'ref',
                        'return',
                        'scoped',
                        'sealed',
                        'sizeof',
                        'stackalloc',
                        'static',
                        'struct',
                        'switch',
                        'this',
                        'throw',
                        'try',
                        'typeof',
                        'unchecked',
                        'unsafe',
                        'using',
                        'virtual',
                        'void',
                        'volatile',
                        'while',
                    ];
                    const CONTEXTUAL_KEYWORDS = [
                        'add',
                        'alias',
                        'and',
                        'ascending',
                        'async',
                        'await',
                        'by',
                        'descending',
                        'equals',
                        'from',
                        'get',
                        'global',
                        'group',
                        'init',
                        'into',
                        'join',
                        'let',
                        'nameof',
                        'not',
                        'notnull',
                        'on',
                        'or',
                        'orderby',
                        'partial',
                        'remove',
                        'select',
                        'set',
                        'unmanaged',
                        'value|0',
                        'var',
                        'when',
                        'where',
                        'with',
                        'yield',
                    ];
                    const KEYWORDS = {
                        keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS),
                        built_in: BUILT_IN_KEYWORDS,
                        literal: LITERAL_KEYWORDS,
                    };
                    const TITLE_MODE2 = hljs2.inherit(hljs2.TITLE_MODE, {
                        begin: '[a-zA-Z](\\.?\\w)*',
                    });
                    const NUMBERS = {
                        className: 'number',
                        variants: [
                            { begin: "\\b(0b[01']+)" },
                            {
                                begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)",
                            },
                            {
                                begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)",
                            },
                        ],
                        relevance: 0,
                    };
                    const VERBATIM_STRING = {
                        className: 'string',
                        begin: '@"',
                        end: '"',
                        contains: [{ begin: '""' }],
                    };
                    const VERBATIM_STRING_NO_LF = hljs2.inherit(
                        VERBATIM_STRING,
                        { illegal: /\n/ }
                    );
                    const SUBST = {
                        className: 'subst',
                        begin: /\{/,
                        end: /\}/,
                        keywords: KEYWORDS,
                    };
                    const SUBST_NO_LF = hljs2.inherit(SUBST, { illegal: /\n/ });
                    const INTERPOLATED_STRING = {
                        className: 'string',
                        begin: /\$"/,
                        end: '"',
                        illegal: /\n/,
                        contains: [
                            { begin: /\{\{/ },
                            { begin: /\}\}/ },
                            hljs2.BACKSLASH_ESCAPE,
                            SUBST_NO_LF,
                        ],
                    };
                    const INTERPOLATED_VERBATIM_STRING = {
                        className: 'string',
                        begin: /\$@"/,
                        end: '"',
                        contains: [
                            { begin: /\{\{/ },
                            { begin: /\}\}/ },
                            { begin: '""' },
                            SUBST,
                        ],
                    };
                    const INTERPOLATED_VERBATIM_STRING_NO_LF = hljs2.inherit(
                        INTERPOLATED_VERBATIM_STRING,
                        {
                            illegal: /\n/,
                            contains: [
                                { begin: /\{\{/ },
                                { begin: /\}\}/ },
                                { begin: '""' },
                                SUBST_NO_LF,
                            ],
                        }
                    );
                    SUBST.contains = [
                        INTERPOLATED_VERBATIM_STRING,
                        INTERPOLATED_STRING,
                        VERBATIM_STRING,
                        hljs2.APOS_STRING_MODE,
                        hljs2.QUOTE_STRING_MODE,
                        NUMBERS,
                        hljs2.C_BLOCK_COMMENT_MODE,
                    ];
                    SUBST_NO_LF.contains = [
                        INTERPOLATED_VERBATIM_STRING_NO_LF,
                        INTERPOLATED_STRING,
                        VERBATIM_STRING_NO_LF,
                        hljs2.APOS_STRING_MODE,
                        hljs2.QUOTE_STRING_MODE,
                        NUMBERS,
                        hljs2.inherit(hljs2.C_BLOCK_COMMENT_MODE, {
                            illegal: /\n/,
                        }),
                    ];
                    const STRING = {
                        variants: [
                            INTERPOLATED_VERBATIM_STRING,
                            INTERPOLATED_STRING,
                            VERBATIM_STRING,
                            hljs2.APOS_STRING_MODE,
                            hljs2.QUOTE_STRING_MODE,
                        ],
                    };
                    const GENERIC_MODIFIER = {
                        begin: '<',
                        end: '>',
                        contains: [{ beginKeywords: 'in out' }, TITLE_MODE2],
                    };
                    const TYPE_IDENT_RE =
                        hljs2.IDENT_RE +
                        '(<' +
                        hljs2.IDENT_RE +
                        '(\\s*,\\s*' +
                        hljs2.IDENT_RE +
                        ')*>)?(\\[\\])?';
                    const AT_IDENTIFIER = {
                        // prevents expressions like `@class` from incorrect flagging
                        // `class` as a keyword
                        begin: '@' + hljs2.IDENT_RE,
                        relevance: 0,
                    };
                    return {
                        name: 'C#',
                        aliases: ['cs', 'c#'],
                        keywords: KEYWORDS,
                        illegal: /::/,
                        contains: [
                            hljs2.COMMENT('///', '$', {
                                returnBegin: true,
                                contains: [
                                    {
                                        className: 'doctag',
                                        variants: [
                                            {
                                                begin: '///',
                                                relevance: 0,
                                            },
                                            { begin: '<!--|-->' },
                                            {
                                                begin: '</?',
                                                end: '>',
                                            },
                                        ],
                                    },
                                ],
                            }),
                            hljs2.C_LINE_COMMENT_MODE,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            {
                                className: 'meta',
                                begin: '#',
                                end: '$',
                                keywords: {
                                    keyword:
                                        'if else elif endif define undef warning error line region endregion pragma checksum',
                                },
                            },
                            STRING,
                            NUMBERS,
                            {
                                beginKeywords: 'class interface',
                                relevance: 0,
                                end: /[{;=]/,
                                illegal: /[^\s:,]/,
                                contains: [
                                    { beginKeywords: 'where class' },
                                    TITLE_MODE2,
                                    GENERIC_MODIFIER,
                                    hljs2.C_LINE_COMMENT_MODE,
                                    hljs2.C_BLOCK_COMMENT_MODE,
                                ],
                            },
                            {
                                beginKeywords: 'namespace',
                                relevance: 0,
                                end: /[{;=]/,
                                illegal: /[^\s:]/,
                                contains: [
                                    TITLE_MODE2,
                                    hljs2.C_LINE_COMMENT_MODE,
                                    hljs2.C_BLOCK_COMMENT_MODE,
                                ],
                            },
                            {
                                beginKeywords: 'record',
                                relevance: 0,
                                end: /[{;=]/,
                                illegal: /[^\s:]/,
                                contains: [
                                    TITLE_MODE2,
                                    GENERIC_MODIFIER,
                                    hljs2.C_LINE_COMMENT_MODE,
                                    hljs2.C_BLOCK_COMMENT_MODE,
                                ],
                            },
                            {
                                // [Attributes("")]
                                className: 'meta',
                                begin: '^\\s*\\[(?=[\\w])',
                                excludeBegin: true,
                                end: '\\]',
                                excludeEnd: true,
                                contains: [
                                    {
                                        className: 'string',
                                        begin: /"/,
                                        end: /"/,
                                    },
                                ],
                            },
                            {
                                // Expression keywords prevent 'keyword Name(...)' from being
                                // recognized as a function definition
                                beginKeywords: 'new return throw await else',
                                relevance: 0,
                            },
                            {
                                className: 'function',
                                begin:
                                    '(' +
                                    TYPE_IDENT_RE +
                                    '\\s+)+' +
                                    hljs2.IDENT_RE +
                                    '\\s*(<[^=]+>\\s*)?\\(',
                                returnBegin: true,
                                end: /\s*[{;=]/,
                                excludeEnd: true,
                                keywords: KEYWORDS,
                                contains: [
                                    // prevents these from being highlighted `title`
                                    {
                                        beginKeywords:
                                            FUNCTION_MODIFIERS.join(' '),
                                        relevance: 0,
                                    },
                                    {
                                        begin:
                                            hljs2.IDENT_RE +
                                            '\\s*(<[^=]+>\\s*)?\\(',
                                        returnBegin: true,
                                        contains: [
                                            hljs2.TITLE_MODE,
                                            GENERIC_MODIFIER,
                                        ],
                                        relevance: 0,
                                    },
                                    { match: /\(\)/ },
                                    {
                                        className: 'params',
                                        begin: /\(/,
                                        end: /\)/,
                                        excludeBegin: true,
                                        excludeEnd: true,
                                        keywords: KEYWORDS,
                                        relevance: 0,
                                        contains: [
                                            STRING,
                                            NUMBERS,
                                            hljs2.C_BLOCK_COMMENT_MODE,
                                        ],
                                    },
                                    hljs2.C_LINE_COMMENT_MODE,
                                    hljs2.C_BLOCK_COMMENT_MODE,
                                ],
                            },
                            AT_IDENTIFIER,
                        ],
                    };
                }
                csharp_1 = csharp;
                return csharp_1;
            }
            var css_1;
            var hasRequiredCss;
            function requireCss() {
                if (hasRequiredCss) return css_1;
                hasRequiredCss = 1;
                const MODES2 = (hljs2) => {
                    return {
                        IMPORTANT: {
                            scope: 'meta',
                            begin: '!important',
                        },
                        BLOCK_COMMENT: hljs2.C_BLOCK_COMMENT_MODE,
                        HEXCOLOR: {
                            scope: 'number',
                            begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/,
                        },
                        FUNCTION_DISPATCH: {
                            className: 'built_in',
                            begin: /[\w-]+(?=\()/,
                        },
                        ATTRIBUTE_SELECTOR_MODE: {
                            scope: 'selector-attr',
                            begin: /\[/,
                            end: /\]/,
                            illegal: '$',
                            contains: [
                                hljs2.APOS_STRING_MODE,
                                hljs2.QUOTE_STRING_MODE,
                            ],
                        },
                        CSS_NUMBER_MODE: {
                            scope: 'number',
                            begin:
                                hljs2.NUMBER_RE +
                                '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
                            relevance: 0,
                        },
                        CSS_VARIABLE: {
                            className: 'attr',
                            begin: /--[A-Za-z_][A-Za-z0-9_-]*/,
                        },
                    };
                };
                const TAGS = [
                    'a',
                    'abbr',
                    'address',
                    'article',
                    'aside',
                    'audio',
                    'b',
                    'blockquote',
                    'body',
                    'button',
                    'canvas',
                    'caption',
                    'cite',
                    'code',
                    'dd',
                    'del',
                    'details',
                    'dfn',
                    'div',
                    'dl',
                    'dt',
                    'em',
                    'fieldset',
                    'figcaption',
                    'figure',
                    'footer',
                    'form',
                    'h1',
                    'h2',
                    'h3',
                    'h4',
                    'h5',
                    'h6',
                    'header',
                    'hgroup',
                    'html',
                    'i',
                    'iframe',
                    'img',
                    'input',
                    'ins',
                    'kbd',
                    'label',
                    'legend',
                    'li',
                    'main',
                    'mark',
                    'menu',
                    'nav',
                    'object',
                    'ol',
                    'p',
                    'q',
                    'quote',
                    'samp',
                    'section',
                    'span',
                    'strong',
                    'summary',
                    'sup',
                    'table',
                    'tbody',
                    'td',
                    'textarea',
                    'tfoot',
                    'th',
                    'thead',
                    'time',
                    'tr',
                    'ul',
                    'var',
                    'video',
                ];
                const MEDIA_FEATURES = [
                    'any-hover',
                    'any-pointer',
                    'aspect-ratio',
                    'color',
                    'color-gamut',
                    'color-index',
                    'device-aspect-ratio',
                    'device-height',
                    'device-width',
                    'display-mode',
                    'forced-colors',
                    'grid',
                    'height',
                    'hover',
                    'inverted-colors',
                    'monochrome',
                    'orientation',
                    'overflow-block',
                    'overflow-inline',
                    'pointer',
                    'prefers-color-scheme',
                    'prefers-contrast',
                    'prefers-reduced-motion',
                    'prefers-reduced-transparency',
                    'resolution',
                    'scan',
                    'scripting',
                    'update',
                    'width',
                    // TODO: find a better solution?
                    'min-width',
                    'max-width',
                    'min-height',
                    'max-height',
                ];
                const PSEUDO_CLASSES = [
                    'active',
                    'any-link',
                    'blank',
                    'checked',
                    'current',
                    'default',
                    'defined',
                    'dir',
                    // dir()
                    'disabled',
                    'drop',
                    'empty',
                    'enabled',
                    'first',
                    'first-child',
                    'first-of-type',
                    'fullscreen',
                    'future',
                    'focus',
                    'focus-visible',
                    'focus-within',
                    'has',
                    // has()
                    'host',
                    // host or host()
                    'host-context',
                    // host-context()
                    'hover',
                    'indeterminate',
                    'in-range',
                    'invalid',
                    'is',
                    // is()
                    'lang',
                    // lang()
                    'last-child',
                    'last-of-type',
                    'left',
                    'link',
                    'local-link',
                    'not',
                    // not()
                    'nth-child',
                    // nth-child()
                    'nth-col',
                    // nth-col()
                    'nth-last-child',
                    // nth-last-child()
                    'nth-last-col',
                    // nth-last-col()
                    'nth-last-of-type',
                    //nth-last-of-type()
                    'nth-of-type',
                    //nth-of-type()
                    'only-child',
                    'only-of-type',
                    'optional',
                    'out-of-range',
                    'past',
                    'placeholder-shown',
                    'read-only',
                    'read-write',
                    'required',
                    'right',
                    'root',
                    'scope',
                    'target',
                    'target-within',
                    'user-invalid',
                    'valid',
                    'visited',
                    'where',
                    // where()
                ];
                const PSEUDO_ELEMENTS = [
                    'after',
                    'backdrop',
                    'before',
                    'cue',
                    'cue-region',
                    'first-letter',
                    'first-line',
                    'grammar-error',
                    'marker',
                    'part',
                    'placeholder',
                    'selection',
                    'slotted',
                    'spelling-error',
                ];
                const ATTRIBUTES = [
                    'align-content',
                    'align-items',
                    'align-self',
                    'all',
                    'animation',
                    'animation-delay',
                    'animation-direction',
                    'animation-duration',
                    'animation-fill-mode',
                    'animation-iteration-count',
                    'animation-name',
                    'animation-play-state',
                    'animation-timing-function',
                    'backface-visibility',
                    'background',
                    'background-attachment',
                    'background-blend-mode',
                    'background-clip',
                    'background-color',
                    'background-image',
                    'background-origin',
                    'background-position',
                    'background-repeat',
                    'background-size',
                    'block-size',
                    'border',
                    'border-block',
                    'border-block-color',
                    'border-block-end',
                    'border-block-end-color',
                    'border-block-end-style',
                    'border-block-end-width',
                    'border-block-start',
                    'border-block-start-color',
                    'border-block-start-style',
                    'border-block-start-width',
                    'border-block-style',
                    'border-block-width',
                    'border-bottom',
                    'border-bottom-color',
                    'border-bottom-left-radius',
                    'border-bottom-right-radius',
                    'border-bottom-style',
                    'border-bottom-width',
                    'border-collapse',
                    'border-color',
                    'border-image',
                    'border-image-outset',
                    'border-image-repeat',
                    'border-image-slice',
                    'border-image-source',
                    'border-image-width',
                    'border-inline',
                    'border-inline-color',
                    'border-inline-end',
                    'border-inline-end-color',
                    'border-inline-end-style',
                    'border-inline-end-width',
                    'border-inline-start',
                    'border-inline-start-color',
                    'border-inline-start-style',
                    'border-inline-start-width',
                    'border-inline-style',
                    'border-inline-width',
                    'border-left',
                    'border-left-color',
                    'border-left-style',
                    'border-left-width',
                    'border-radius',
                    'border-right',
                    'border-right-color',
                    'border-right-style',
                    'border-right-width',
                    'border-spacing',
                    'border-style',
                    'border-top',
                    'border-top-color',
                    'border-top-left-radius',
                    'border-top-right-radius',
                    'border-top-style',
                    'border-top-width',
                    'border-width',
                    'bottom',
                    'box-decoration-break',
                    'box-shadow',
                    'box-sizing',
                    'break-after',
                    'break-before',
                    'break-inside',
                    'caption-side',
                    'caret-color',
                    'clear',
                    'clip',
                    'clip-path',
                    'clip-rule',
                    'color',
                    'column-count',
                    'column-fill',
                    'column-gap',
                    'column-rule',
                    'column-rule-color',
                    'column-rule-style',
                    'column-rule-width',
                    'column-span',
                    'column-width',
                    'columns',
                    'contain',
                    'content',
                    'content-visibility',
                    'counter-increment',
                    'counter-reset',
                    'cue',
                    'cue-after',
                    'cue-before',
                    'cursor',
                    'direction',
                    'display',
                    'empty-cells',
                    'filter',
                    'flex',
                    'flex-basis',
                    'flex-direction',
                    'flex-flow',
                    'flex-grow',
                    'flex-shrink',
                    'flex-wrap',
                    'float',
                    'flow',
                    'font',
                    'font-display',
                    'font-family',
                    'font-feature-settings',
                    'font-kerning',
                    'font-language-override',
                    'font-size',
                    'font-size-adjust',
                    'font-smoothing',
                    'font-stretch',
                    'font-style',
                    'font-synthesis',
                    'font-variant',
                    'font-variant-caps',
                    'font-variant-east-asian',
                    'font-variant-ligatures',
                    'font-variant-numeric',
                    'font-variant-position',
                    'font-variation-settings',
                    'font-weight',
                    'gap',
                    'glyph-orientation-vertical',
                    'grid',
                    'grid-area',
                    'grid-auto-columns',
                    'grid-auto-flow',
                    'grid-auto-rows',
                    'grid-column',
                    'grid-column-end',
                    'grid-column-start',
                    'grid-gap',
                    'grid-row',
                    'grid-row-end',
                    'grid-row-start',
                    'grid-template',
                    'grid-template-areas',
                    'grid-template-columns',
                    'grid-template-rows',
                    'hanging-punctuation',
                    'height',
                    'hyphens',
                    'icon',
                    'image-orientation',
                    'image-rendering',
                    'image-resolution',
                    'ime-mode',
                    'inline-size',
                    'isolation',
                    'justify-content',
                    'left',
                    'letter-spacing',
                    'line-break',
                    'line-height',
                    'list-style',
                    'list-style-image',
                    'list-style-position',
                    'list-style-type',
                    'margin',
                    'margin-block',
                    'margin-block-end',
                    'margin-block-start',
                    'margin-bottom',
                    'margin-inline',
                    'margin-inline-end',
                    'margin-inline-start',
                    'margin-left',
                    'margin-right',
                    'margin-top',
                    'marks',
                    'mask',
                    'mask-border',
                    'mask-border-mode',
                    'mask-border-outset',
                    'mask-border-repeat',
                    'mask-border-slice',
                    'mask-border-source',
                    'mask-border-width',
                    'mask-clip',
                    'mask-composite',
                    'mask-image',
                    'mask-mode',
                    'mask-origin',
                    'mask-position',
                    'mask-repeat',
                    'mask-size',
                    'mask-type',
                    'max-block-size',
                    'max-height',
                    'max-inline-size',
                    'max-width',
                    'min-block-size',
                    'min-height',
                    'min-inline-size',
                    'min-width',
                    'mix-blend-mode',
                    'nav-down',
                    'nav-index',
                    'nav-left',
                    'nav-right',
                    'nav-up',
                    'none',
                    'normal',
                    'object-fit',
                    'object-position',
                    'opacity',
                    'order',
                    'orphans',
                    'outline',
                    'outline-color',
                    'outline-offset',
                    'outline-style',
                    'outline-width',
                    'overflow',
                    'overflow-wrap',
                    'overflow-x',
                    'overflow-y',
                    'padding',
                    'padding-block',
                    'padding-block-end',
                    'padding-block-start',
                    'padding-bottom',
                    'padding-inline',
                    'padding-inline-end',
                    'padding-inline-start',
                    'padding-left',
                    'padding-right',
                    'padding-top',
                    'page-break-after',
                    'page-break-before',
                    'page-break-inside',
                    'pause',
                    'pause-after',
                    'pause-before',
                    'perspective',
                    'perspective-origin',
                    'pointer-events',
                    'position',
                    'quotes',
                    'resize',
                    'rest',
                    'rest-after',
                    'rest-before',
                    'right',
                    'row-gap',
                    'scroll-margin',
                    'scroll-margin-block',
                    'scroll-margin-block-end',
                    'scroll-margin-block-start',
                    'scroll-margin-bottom',
                    'scroll-margin-inline',
                    'scroll-margin-inline-end',
                    'scroll-margin-inline-start',
                    'scroll-margin-left',
                    'scroll-margin-right',
                    'scroll-margin-top',
                    'scroll-padding',
                    'scroll-padding-block',
                    'scroll-padding-block-end',
                    'scroll-padding-block-start',
                    'scroll-padding-bottom',
                    'scroll-padding-inline',
                    'scroll-padding-inline-end',
                    'scroll-padding-inline-start',
                    'scroll-padding-left',
                    'scroll-padding-right',
                    'scroll-padding-top',
                    'scroll-snap-align',
                    'scroll-snap-stop',
                    'scroll-snap-type',
                    'scrollbar-color',
                    'scrollbar-gutter',
                    'scrollbar-width',
                    'shape-image-threshold',
                    'shape-margin',
                    'shape-outside',
                    'speak',
                    'speak-as',
                    'src',
                    // @font-face
                    'tab-size',
                    'table-layout',
                    'text-align',
                    'text-align-all',
                    'text-align-last',
                    'text-combine-upright',
                    'text-decoration',
                    'text-decoration-color',
                    'text-decoration-line',
                    'text-decoration-style',
                    'text-emphasis',
                    'text-emphasis-color',
                    'text-emphasis-position',
                    'text-emphasis-style',
                    'text-indent',
                    'text-justify',
                    'text-orientation',
                    'text-overflow',
                    'text-rendering',
                    'text-shadow',
                    'text-transform',
                    'text-underline-position',
                    'top',
                    'transform',
                    'transform-box',
                    'transform-origin',
                    'transform-style',
                    'transition',
                    'transition-delay',
                    'transition-duration',
                    'transition-property',
                    'transition-timing-function',
                    'unicode-bidi',
                    'vertical-align',
                    'visibility',
                    'voice-balance',
                    'voice-duration',
                    'voice-family',
                    'voice-pitch',
                    'voice-range',
                    'voice-rate',
                    'voice-stress',
                    'voice-volume',
                    'white-space',
                    'widows',
                    'width',
                    'will-change',
                    'word-break',
                    'word-spacing',
                    'word-wrap',
                    'writing-mode',
                    'z-index',
                    // reverse makes sure longer attributes `font-weight` are matched fully
                    // instead of getting false positives on say `font`
                ].reverse();
                function css(hljs2) {
                    const regex = hljs2.regex;
                    const modes = MODES2(hljs2);
                    const VENDOR_PREFIX = {
                        begin: /-(webkit|moz|ms|o)-(?=[a-z])/,
                    };
                    const AT_MODIFIERS = 'and or not only';
                    const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
                    const IDENT_RE2 = '[a-zA-Z-][a-zA-Z0-9_-]*';
                    const STRINGS = [
                        hljs2.APOS_STRING_MODE,
                        hljs2.QUOTE_STRING_MODE,
                    ];
                    return {
                        name: 'CSS',
                        case_insensitive: true,
                        illegal: /[=|'\$]/,
                        keywords: { keyframePosition: 'from to' },
                        classNameAliases: {
                            // for visual continuity with `tag {}` and because we
                            // don't have a great class for this?
                            keyframePosition: 'selector-tag',
                        },
                        contains: [
                            modes.BLOCK_COMMENT,
                            VENDOR_PREFIX,
                            // to recognize keyframe 40% etc which are outside the scope of our
                            // attribute value mode
                            modes.CSS_NUMBER_MODE,
                            {
                                className: 'selector-id',
                                begin: /#[A-Za-z0-9_-]+/,
                                relevance: 0,
                            },
                            {
                                className: 'selector-class',
                                begin: '\\.' + IDENT_RE2,
                                relevance: 0,
                            },
                            modes.ATTRIBUTE_SELECTOR_MODE,
                            {
                                className: 'selector-pseudo',
                                variants: [
                                    {
                                        begin:
                                            ':(' +
                                            PSEUDO_CLASSES.join('|') +
                                            ')',
                                    },
                                    {
                                        begin:
                                            ':(:)?(' +
                                            PSEUDO_ELEMENTS.join('|') +
                                            ')',
                                    },
                                ],
                            },
                            // we may actually need this (12/2020)
                            // { // pseudo-selector params
                            //   begin: /\(/,
                            //   end: /\)/,
                            //   contains: [ hljs.CSS_NUMBER_MODE ]
                            // },
                            modes.CSS_VARIABLE,
                            {
                                className: 'attribute',
                                begin: '\\b(' + ATTRIBUTES.join('|') + ')\\b',
                            },
                            // attribute values
                            {
                                begin: /:/,
                                end: /[;}{]/,
                                contains: [
                                    modes.BLOCK_COMMENT,
                                    modes.HEXCOLOR,
                                    modes.IMPORTANT,
                                    modes.CSS_NUMBER_MODE,
                                    ...STRINGS,
                                    // needed to highlight these as strings and to avoid issues with
                                    // illegal characters that might be inside urls that would tigger the
                                    // languages illegal stack
                                    {
                                        begin: /(url|data-uri)\(/,
                                        end: /\)/,
                                        relevance: 0,
                                        // from keywords
                                        keywords: { built_in: 'url data-uri' },
                                        contains: [
                                            ...STRINGS,
                                            {
                                                className: 'string',
                                                // any character other than `)` as in `url()` will be the start
                                                // of a string, which ends with `)` (from the parent mode)
                                                begin: /[^)]/,
                                                endsWithParent: true,
                                                excludeEnd: true,
                                            },
                                        ],
                                    },
                                    modes.FUNCTION_DISPATCH,
                                ],
                            },
                            {
                                begin: regex.lookahead(/@/),
                                end: '[{;]',
                                relevance: 0,
                                illegal: /:/,
                                // break on Less variables @var: ...
                                contains: [
                                    {
                                        className: 'keyword',
                                        begin: AT_PROPERTY_RE,
                                    },
                                    {
                                        begin: /\s/,
                                        endsWithParent: true,
                                        excludeEnd: true,
                                        relevance: 0,
                                        keywords: {
                                            $pattern: /[a-z-]+/,
                                            keyword: AT_MODIFIERS,
                                            attribute: MEDIA_FEATURES.join(' '),
                                        },
                                        contains: [
                                            {
                                                begin: /[a-z-]+(?=:)/,
                                                className: 'attribute',
                                            },
                                            ...STRINGS,
                                            modes.CSS_NUMBER_MODE,
                                        ],
                                    },
                                ],
                            },
                            {
                                className: 'selector-tag',
                                begin: '\\b(' + TAGS.join('|') + ')\\b',
                            },
                        ],
                    };
                }
                css_1 = css;
                return css_1;
            }
            var markdown_1;
            var hasRequiredMarkdown;
            function requireMarkdown() {
                if (hasRequiredMarkdown) return markdown_1;
                hasRequiredMarkdown = 1;
                function markdown(hljs2) {
                    const regex = hljs2.regex;
                    const INLINE_HTML = {
                        begin: /<\/?[A-Za-z_]/,
                        end: '>',
                        subLanguage: 'xml',
                        relevance: 0,
                    };
                    const HORIZONTAL_RULE = {
                        begin: '^[-\\*]{3,}',
                        end: '$',
                    };
                    const CODE = {
                        className: 'code',
                        variants: [
                            // TODO: fix to allow these to work with sublanguage also
                            { begin: '(`{3,})[^`](.|\\n)*?\\1`*[ ]*' },
                            { begin: '(~{3,})[^~](.|\\n)*?\\1~*[ ]*' },
                            // needed to allow markdown as a sublanguage to work
                            {
                                begin: '```',
                                end: '```+[ ]*$',
                            },
                            {
                                begin: '~~~',
                                end: '~~~+[ ]*$',
                            },
                            { begin: '`.+?`' },
                            {
                                begin: '(?=^( {4}|\\t))',
                                // use contains to gobble up multiple lines to allow the block to be whatever size
                                // but only have a single open/close tag vs one per line
                                contains: [
                                    {
                                        begin: '^( {4}|\\t)',
                                        end: '(\\n)$',
                                    },
                                ],
                                relevance: 0,
                            },
                        ],
                    };
                    const LIST = {
                        className: 'bullet',
                        begin: '^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)',
                        end: '\\s+',
                        excludeEnd: true,
                    };
                    const LINK_REFERENCE = {
                        begin: /^\[[^\n]+\]:/,
                        returnBegin: true,
                        contains: [
                            {
                                className: 'symbol',
                                begin: /\[/,
                                end: /\]/,
                                excludeBegin: true,
                                excludeEnd: true,
                            },
                            {
                                className: 'link',
                                begin: /:\s*/,
                                end: /$/,
                                excludeBegin: true,
                            },
                        ],
                    };
                    const URL_SCHEME = /[A-Za-z][A-Za-z0-9+.-]*/;
                    const LINK = {
                        variants: [
                            // too much like nested array access in so many languages
                            // to have any real relevance
                            {
                                begin: /\[.+?\]\[.*?\]/,
                                relevance: 0,
                            },
                            // popular internet URLs
                            {
                                begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
                                relevance: 2,
                            },
                            {
                                begin: regex.concat(
                                    /\[.+?\]\(/,
                                    URL_SCHEME,
                                    /:\/\/.*?\)/
                                ),
                                relevance: 2,
                            },
                            // relative urls
                            {
                                begin: /\[.+?\]\([./?&#].*?\)/,
                                relevance: 1,
                            },
                            // whatever else, lower relevance (might not be a link at all)
                            {
                                begin: /\[.*?\]\(.*?\)/,
                                relevance: 0,
                            },
                        ],
                        returnBegin: true,
                        contains: [
                            {
                                // empty strings for alt or link text
                                match: /\[(?=\])/,
                            },
                            {
                                className: 'string',
                                relevance: 0,
                                begin: '\\[',
                                end: '\\]',
                                excludeBegin: true,
                                returnEnd: true,
                            },
                            {
                                className: 'link',
                                relevance: 0,
                                begin: '\\]\\(',
                                end: '\\)',
                                excludeBegin: true,
                                excludeEnd: true,
                            },
                            {
                                className: 'symbol',
                                relevance: 0,
                                begin: '\\]\\[',
                                end: '\\]',
                                excludeBegin: true,
                                excludeEnd: true,
                            },
                        ],
                    };
                    const BOLD = {
                        className: 'strong',
                        contains: [],
                        // defined later
                        variants: [
                            {
                                begin: /_{2}(?!\s)/,
                                end: /_{2}/,
                            },
                            {
                                begin: /\*{2}(?!\s)/,
                                end: /\*{2}/,
                            },
                        ],
                    };
                    const ITALIC = {
                        className: 'emphasis',
                        contains: [],
                        // defined later
                        variants: [
                            {
                                begin: /\*(?![*\s])/,
                                end: /\*/,
                            },
                            {
                                begin: /_(?![_\s])/,
                                end: /_/,
                                relevance: 0,
                            },
                        ],
                    };
                    const BOLD_WITHOUT_ITALIC = hljs2.inherit(BOLD, {
                        contains: [],
                    });
                    const ITALIC_WITHOUT_BOLD = hljs2.inherit(ITALIC, {
                        contains: [],
                    });
                    BOLD.contains.push(ITALIC_WITHOUT_BOLD);
                    ITALIC.contains.push(BOLD_WITHOUT_ITALIC);
                    let CONTAINABLE = [INLINE_HTML, LINK];
                    [
                        BOLD,
                        ITALIC,
                        BOLD_WITHOUT_ITALIC,
                        ITALIC_WITHOUT_BOLD,
                    ].forEach((m) => {
                        m.contains = m.contains.concat(CONTAINABLE);
                    });
                    CONTAINABLE = CONTAINABLE.concat(BOLD, ITALIC);
                    const HEADER = {
                        className: 'section',
                        variants: [
                            {
                                begin: '^#{1,6}',
                                end: '$',
                                contains: CONTAINABLE,
                            },
                            {
                                begin: '(?=^.+?\\n[=-]{2,}$)',
                                contains: [
                                    { begin: '^[=-]*$' },
                                    {
                                        begin: '^',
                                        end: '\\n',
                                        contains: CONTAINABLE,
                                    },
                                ],
                            },
                        ],
                    };
                    const BLOCKQUOTE = {
                        className: 'quote',
                        begin: '^>\\s+',
                        contains: CONTAINABLE,
                        end: '$',
                    };
                    return {
                        name: 'Markdown',
                        aliases: ['md', 'mkdown', 'mkd'],
                        contains: [
                            HEADER,
                            INLINE_HTML,
                            LIST,
                            BOLD,
                            ITALIC,
                            BLOCKQUOTE,
                            CODE,
                            HORIZONTAL_RULE,
                            LINK,
                            LINK_REFERENCE,
                        ],
                    };
                }
                markdown_1 = markdown;
                return markdown_1;
            }
            var diff_1;
            var hasRequiredDiff;
            function requireDiff() {
                if (hasRequiredDiff) return diff_1;
                hasRequiredDiff = 1;
                function diff(hljs2) {
                    const regex = hljs2.regex;
                    return {
                        name: 'Diff',
                        aliases: ['patch'],
                        contains: [
                            {
                                className: 'meta',
                                relevance: 10,
                                match: regex.either(
                                    /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
                                    /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
                                    /^--- +\d+,\d+ +----$/
                                ),
                            },
                            {
                                className: 'comment',
                                variants: [
                                    {
                                        begin: regex.either(
                                            /Index: /,
                                            /^index/,
                                            /={3,}/,
                                            /^-{3}/,
                                            /^\*{3} /,
                                            /^\+{3}/,
                                            /^diff --git/
                                        ),
                                        end: /$/,
                                    },
                                    { match: /^\*{15}$/ },
                                ],
                            },
                            {
                                className: 'addition',
                                begin: /^\+/,
                                end: /$/,
                            },
                            {
                                className: 'deletion',
                                begin: /^-/,
                                end: /$/,
                            },
                            {
                                className: 'addition',
                                begin: /^!/,
                                end: /$/,
                            },
                        ],
                    };
                }
                diff_1 = diff;
                return diff_1;
            }
            var ruby_1;
            var hasRequiredRuby;
            function requireRuby() {
                if (hasRequiredRuby) return ruby_1;
                hasRequiredRuby = 1;
                function ruby(hljs2) {
                    const regex = hljs2.regex;
                    const RUBY_METHOD_RE =
                        '([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)';
                    const CLASS_NAME_RE = regex.either(
                        /\b([A-Z]+[a-z0-9]+)+/,
                        // ends in caps
                        /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
                    );
                    const CLASS_NAME_WITH_NAMESPACE_RE = regex.concat(
                        CLASS_NAME_RE,
                        /(::\w+)*/
                    );
                    const PSEUDO_KWS = [
                        'include',
                        'extend',
                        'prepend',
                        'public',
                        'private',
                        'protected',
                        'raise',
                        'throw',
                    ];
                    const RUBY_KEYWORDS = {
                        'variable.constant': [
                            '__FILE__',
                            '__LINE__',
                            '__ENCODING__',
                        ],
                        'variable.language': ['self', 'super'],
                        keyword: [
                            'alias',
                            'and',
                            'begin',
                            'BEGIN',
                            'break',
                            'case',
                            'class',
                            'defined',
                            'do',
                            'else',
                            'elsif',
                            'end',
                            'END',
                            'ensure',
                            'for',
                            'if',
                            'in',
                            'module',
                            'next',
                            'not',
                            'or',
                            'redo',
                            'require',
                            'rescue',
                            'retry',
                            'return',
                            'then',
                            'undef',
                            'unless',
                            'until',
                            'when',
                            'while',
                            'yield',
                            ...PSEUDO_KWS,
                        ],
                        built_in: [
                            'proc',
                            'lambda',
                            'attr_accessor',
                            'attr_reader',
                            'attr_writer',
                            'define_method',
                            'private_constant',
                            'module_function',
                        ],
                        literal: ['true', 'false', 'nil'],
                    };
                    const YARDOCTAG = {
                        className: 'doctag',
                        begin: '@[A-Za-z]+',
                    };
                    const IRB_OBJECT = {
                        begin: '#<',
                        end: '>',
                    };
                    const COMMENT_MODES = [
                        hljs2.COMMENT('#', '$', { contains: [YARDOCTAG] }),
                        hljs2.COMMENT('^=begin', '^=end', {
                            contains: [YARDOCTAG],
                            relevance: 10,
                        }),
                        hljs2.COMMENT('^__END__', hljs2.MATCH_NOTHING_RE),
                    ];
                    const SUBST = {
                        className: 'subst',
                        begin: /#\{/,
                        end: /\}/,
                        keywords: RUBY_KEYWORDS,
                    };
                    const STRING = {
                        className: 'string',
                        contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                        variants: [
                            {
                                begin: /'/,
                                end: /'/,
                            },
                            {
                                begin: /"/,
                                end: /"/,
                            },
                            {
                                begin: /`/,
                                end: /`/,
                            },
                            {
                                begin: /%[qQwWx]?\(/,
                                end: /\)/,
                            },
                            {
                                begin: /%[qQwWx]?\[/,
                                end: /\]/,
                            },
                            {
                                begin: /%[qQwWx]?\{/,
                                end: /\}/,
                            },
                            {
                                begin: /%[qQwWx]?</,
                                end: />/,
                            },
                            {
                                begin: /%[qQwWx]?\//,
                                end: /\//,
                            },
                            {
                                begin: /%[qQwWx]?%/,
                                end: /%/,
                            },
                            {
                                begin: /%[qQwWx]?-/,
                                end: /-/,
                            },
                            {
                                begin: /%[qQwWx]?\|/,
                                end: /\|/,
                            },
                            // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
                            // where ? is the last character of a preceding identifier, as in: `func?4`
                            { begin: /\B\?(\\\d{1,3})/ },
                            { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
                            { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
                            {
                                begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/,
                            },
                            { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
                            { begin: /\B\?\\?\S/ },
                            // heredocs
                            {
                                // this guard makes sure that we have an entire heredoc and not a false
                                // positive (auto-detect, etc.)
                                begin: regex.concat(
                                    /<<[-~]?'?/,
                                    regex.lookahead(
                                        /(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/
                                    )
                                ),
                                contains: [
                                    hljs2.END_SAME_AS_BEGIN({
                                        begin: /(\w+)/,
                                        end: /(\w+)/,
                                        contains: [
                                            hljs2.BACKSLASH_ESCAPE,
                                            SUBST,
                                        ],
                                    }),
                                ],
                            },
                        ],
                    };
                    const decimal = '[1-9](_?[0-9])*|0';
                    const digits = '[0-9](_?[0-9])*';
                    const NUMBER = {
                        className: 'number',
                        relevance: 0,
                        variants: [
                            // decimal integer/float, optionally exponential or rational, optionally imaginary
                            {
                                begin: `\\b(${decimal})(\\.(${digits}))?([eE][+-]?(${digits})|r)?i?\\b`,
                            },
                            // explicit decimal/binary/octal/hexadecimal integer,
                            // optionally rational and/or imaginary
                            { begin: '\\b0[dD][0-9](_?[0-9])*r?i?\\b' },
                            { begin: '\\b0[bB][0-1](_?[0-1])*r?i?\\b' },
                            { begin: '\\b0[oO][0-7](_?[0-7])*r?i?\\b' },
                            {
                                begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b',
                            },
                            // 0-prefixed implicit octal integer, optionally rational and/or imaginary
                            { begin: '\\b0(_?[0-7])+r?i?\\b' },
                        ],
                    };
                    const PARAMS = {
                        variants: [
                            {
                                match: /\(\)/,
                            },
                            {
                                className: 'params',
                                begin: /\(/,
                                end: /(?=\))/,
                                excludeBegin: true,
                                endsParent: true,
                                keywords: RUBY_KEYWORDS,
                            },
                        ],
                    };
                    const INCLUDE_EXTEND = {
                        match: [
                            /(include|extend)\s+/,
                            CLASS_NAME_WITH_NAMESPACE_RE,
                        ],
                        scope: {
                            2: 'title.class',
                        },
                        keywords: RUBY_KEYWORDS,
                    };
                    const CLASS_DEFINITION = {
                        variants: [
                            {
                                match: [
                                    /class\s+/,
                                    CLASS_NAME_WITH_NAMESPACE_RE,
                                    /\s+<\s+/,
                                    CLASS_NAME_WITH_NAMESPACE_RE,
                                ],
                            },
                            {
                                match: [
                                    /\b(class|module)\s+/,
                                    CLASS_NAME_WITH_NAMESPACE_RE,
                                ],
                            },
                        ],
                        scope: {
                            2: 'title.class',
                            4: 'title.class.inherited',
                        },
                        keywords: RUBY_KEYWORDS,
                    };
                    const UPPER_CASE_CONSTANT = {
                        relevance: 0,
                        match: /\b[A-Z][A-Z_0-9]+\b/,
                        className: 'variable.constant',
                    };
                    const METHOD_DEFINITION = {
                        match: [/def/, /\s+/, RUBY_METHOD_RE],
                        scope: {
                            1: 'keyword',
                            3: 'title.function',
                        },
                        contains: [PARAMS],
                    };
                    const OBJECT_CREATION = {
                        relevance: 0,
                        match: [CLASS_NAME_WITH_NAMESPACE_RE, /\.new[. (]/],
                        scope: {
                            1: 'title.class',
                        },
                    };
                    const CLASS_REFERENCE = {
                        relevance: 0,
                        match: CLASS_NAME_RE,
                        scope: 'title.class',
                    };
                    const RUBY_DEFAULT_CONTAINS = [
                        STRING,
                        CLASS_DEFINITION,
                        INCLUDE_EXTEND,
                        OBJECT_CREATION,
                        UPPER_CASE_CONSTANT,
                        CLASS_REFERENCE,
                        METHOD_DEFINITION,
                        {
                            // swallow namespace qualifiers before symbols
                            begin: hljs2.IDENT_RE + '::',
                        },
                        {
                            className: 'symbol',
                            begin: hljs2.UNDERSCORE_IDENT_RE + '(!|\\?)?:',
                            relevance: 0,
                        },
                        {
                            className: 'symbol',
                            begin: ':(?!\\s)',
                            contains: [STRING, { begin: RUBY_METHOD_RE }],
                            relevance: 0,
                        },
                        NUMBER,
                        {
                            // negative-look forward attempts to prevent false matches like:
                            // @ident@ or $ident$ that might indicate this is not ruby at all
                            className: 'variable',
                            begin: `(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])`,
                        },
                        {
                            className: 'params',
                            begin: /\|/,
                            end: /\|/,
                            excludeBegin: true,
                            excludeEnd: true,
                            relevance: 0,
                            // this could be a lot of things (in other languages) other than params
                            keywords: RUBY_KEYWORDS,
                        },
                        {
                            // regexp container
                            begin: '(' + hljs2.RE_STARTERS_RE + '|unless)\\s*',
                            keywords: 'unless',
                            contains: [
                                {
                                    className: 'regexp',
                                    contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                                    illegal: /\n/,
                                    variants: [
                                        {
                                            begin: '/',
                                            end: '/[a-z]*',
                                        },
                                        {
                                            begin: /%r\{/,
                                            end: /\}[a-z]*/,
                                        },
                                        {
                                            begin: '%r\\(',
                                            end: '\\)[a-z]*',
                                        },
                                        {
                                            begin: '%r!',
                                            end: '![a-z]*',
                                        },
                                        {
                                            begin: '%r\\[',
                                            end: '\\][a-z]*',
                                        },
                                    ],
                                },
                            ].concat(IRB_OBJECT, COMMENT_MODES),
                            relevance: 0,
                        },
                    ].concat(IRB_OBJECT, COMMENT_MODES);
                    SUBST.contains = RUBY_DEFAULT_CONTAINS;
                    PARAMS.contains = RUBY_DEFAULT_CONTAINS;
                    const SIMPLE_PROMPT = '[>?]>';
                    const DEFAULT_PROMPT = '[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]';
                    const RVM_PROMPT =
                        '(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>';
                    const IRB_DEFAULT = [
                        {
                            begin: /^\s*=>/,
                            starts: {
                                end: '$',
                                contains: RUBY_DEFAULT_CONTAINS,
                            },
                        },
                        {
                            className: 'meta.prompt',
                            begin:
                                '^(' +
                                SIMPLE_PROMPT +
                                '|' +
                                DEFAULT_PROMPT +
                                '|' +
                                RVM_PROMPT +
                                ')(?=[ ])',
                            starts: {
                                end: '$',
                                keywords: RUBY_KEYWORDS,
                                contains: RUBY_DEFAULT_CONTAINS,
                            },
                        },
                    ];
                    COMMENT_MODES.unshift(IRB_OBJECT);
                    return {
                        name: 'Ruby',
                        aliases: ['rb', 'gemspec', 'podspec', 'thor', 'irb'],
                        keywords: RUBY_KEYWORDS,
                        illegal: /\/\*/,
                        contains: [hljs2.SHEBANG({ binary: 'ruby' })]
                            .concat(IRB_DEFAULT)
                            .concat(COMMENT_MODES)
                            .concat(RUBY_DEFAULT_CONTAINS),
                    };
                }
                ruby_1 = ruby;
                return ruby_1;
            }
            var go_1;
            var hasRequiredGo;
            function requireGo() {
                if (hasRequiredGo) return go_1;
                hasRequiredGo = 1;
                function go(hljs2) {
                    const LITERALS = ['true', 'false', 'iota', 'nil'];
                    const BUILT_INS = [
                        'append',
                        'cap',
                        'close',
                        'complex',
                        'copy',
                        'imag',
                        'len',
                        'make',
                        'new',
                        'panic',
                        'print',
                        'println',
                        'real',
                        'recover',
                        'delete',
                    ];
                    const TYPES = [
                        'bool',
                        'byte',
                        'complex64',
                        'complex128',
                        'error',
                        'float32',
                        'float64',
                        'int8',
                        'int16',
                        'int32',
                        'int64',
                        'string',
                        'uint8',
                        'uint16',
                        'uint32',
                        'uint64',
                        'int',
                        'uint',
                        'uintptr',
                        'rune',
                    ];
                    const KWS = [
                        'break',
                        'case',
                        'chan',
                        'const',
                        'continue',
                        'default',
                        'defer',
                        'else',
                        'fallthrough',
                        'for',
                        'func',
                        'go',
                        'goto',
                        'if',
                        'import',
                        'interface',
                        'map',
                        'package',
                        'range',
                        'return',
                        'select',
                        'struct',
                        'switch',
                        'type',
                        'var',
                    ];
                    const KEYWORDS = {
                        keyword: KWS,
                        type: TYPES,
                        literal: LITERALS,
                        built_in: BUILT_INS,
                    };
                    return {
                        name: 'Go',
                        aliases: ['golang'],
                        keywords: KEYWORDS,
                        illegal: '</',
                        contains: [
                            hljs2.C_LINE_COMMENT_MODE,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            {
                                className: 'string',
                                variants: [
                                    hljs2.QUOTE_STRING_MODE,
                                    hljs2.APOS_STRING_MODE,
                                    {
                                        begin: '`',
                                        end: '`',
                                    },
                                ],
                            },
                            {
                                className: 'number',
                                variants: [
                                    {
                                        begin: hljs2.C_NUMBER_RE + '[i]',
                                        relevance: 1,
                                    },
                                    hljs2.C_NUMBER_MODE,
                                ],
                            },
                            {
                                begin: /:=/,
                                // relevance booster
                            },
                            {
                                className: 'function',
                                beginKeywords: 'func',
                                end: '\\s*(\\{|$)',
                                excludeEnd: true,
                                contains: [
                                    hljs2.TITLE_MODE,
                                    {
                                        className: 'params',
                                        begin: /\(/,
                                        end: /\)/,
                                        endsParent: true,
                                        keywords: KEYWORDS,
                                        illegal: /["']/,
                                    },
                                ],
                            },
                        ],
                    };
                }
                go_1 = go;
                return go_1;
            }
            var graphql_1;
            var hasRequiredGraphql;
            function requireGraphql() {
                if (hasRequiredGraphql) return graphql_1;
                hasRequiredGraphql = 1;
                function graphql(hljs2) {
                    const regex = hljs2.regex;
                    const GQL_NAME = /[_A-Za-z][_0-9A-Za-z]*/;
                    return {
                        name: 'GraphQL',
                        aliases: ['gql'],
                        case_insensitive: true,
                        disableAutodetect: false,
                        keywords: {
                            keyword: [
                                'query',
                                'mutation',
                                'subscription',
                                'type',
                                'input',
                                'schema',
                                'directive',
                                'interface',
                                'union',
                                'scalar',
                                'fragment',
                                'enum',
                                'on',
                            ],
                            literal: ['true', 'false', 'null'],
                        },
                        contains: [
                            hljs2.HASH_COMMENT_MODE,
                            hljs2.QUOTE_STRING_MODE,
                            hljs2.NUMBER_MODE,
                            {
                                scope: 'punctuation',
                                match: /[.]{3}/,
                                relevance: 0,
                            },
                            {
                                scope: 'punctuation',
                                begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
                                relevance: 0,
                            },
                            {
                                scope: 'variable',
                                begin: /\$/,
                                end: /\W/,
                                excludeEnd: true,
                                relevance: 0,
                            },
                            {
                                scope: 'meta',
                                match: /@\w+/,
                                excludeEnd: true,
                            },
                            {
                                scope: 'symbol',
                                begin: regex.concat(
                                    GQL_NAME,
                                    regex.lookahead(/\s*:/)
                                ),
                                relevance: 0,
                            },
                        ],
                        illegal: [/[;<']/, /BEGIN/],
                    };
                }
                graphql_1 = graphql;
                return graphql_1;
            }
            var ini_1;
            var hasRequiredIni;
            function requireIni() {
                if (hasRequiredIni) return ini_1;
                hasRequiredIni = 1;
                function ini(hljs2) {
                    const regex = hljs2.regex;
                    const NUMBERS = {
                        className: 'number',
                        relevance: 0,
                        variants: [
                            { begin: /([+-]+)?[\d]+_[\d_]+/ },
                            { begin: hljs2.NUMBER_RE },
                        ],
                    };
                    const COMMENTS = hljs2.COMMENT();
                    COMMENTS.variants = [
                        {
                            begin: /;/,
                            end: /$/,
                        },
                        {
                            begin: /#/,
                            end: /$/,
                        },
                    ];
                    const VARIABLES = {
                        className: 'variable',
                        variants: [
                            { begin: /\$[\w\d"][\w\d_]*/ },
                            { begin: /\$\{(.*?)\}/ },
                        ],
                    };
                    const LITERALS = {
                        className: 'literal',
                        begin: /\bon|off|true|false|yes|no\b/,
                    };
                    const STRINGS = {
                        className: 'string',
                        contains: [hljs2.BACKSLASH_ESCAPE],
                        variants: [
                            {
                                begin: "'''",
                                end: "'''",
                                relevance: 10,
                            },
                            {
                                begin: '"""',
                                end: '"""',
                                relevance: 10,
                            },
                            {
                                begin: '"',
                                end: '"',
                            },
                            {
                                begin: "'",
                                end: "'",
                            },
                        ],
                    };
                    const ARRAY = {
                        begin: /\[/,
                        end: /\]/,
                        contains: [
                            COMMENTS,
                            LITERALS,
                            VARIABLES,
                            STRINGS,
                            NUMBERS,
                            'self',
                        ],
                        relevance: 0,
                    };
                    const BARE_KEY = /[A-Za-z0-9_-]+/;
                    const QUOTED_KEY_DOUBLE_QUOTE = /"(\\"|[^"])*"/;
                    const QUOTED_KEY_SINGLE_QUOTE = /'[^']*'/;
                    const ANY_KEY = regex.either(
                        BARE_KEY,
                        QUOTED_KEY_DOUBLE_QUOTE,
                        QUOTED_KEY_SINGLE_QUOTE
                    );
                    const DOTTED_KEY = regex.concat(
                        ANY_KEY,
                        '(\\s*\\.\\s*',
                        ANY_KEY,
                        ')*',
                        regex.lookahead(/\s*=\s*[^#\s]/)
                    );
                    return {
                        name: 'TOML, also INI',
                        aliases: ['toml'],
                        case_insensitive: true,
                        illegal: /\S/,
                        contains: [
                            COMMENTS,
                            {
                                className: 'section',
                                begin: /\[+/,
                                end: /\]+/,
                            },
                            {
                                begin: DOTTED_KEY,
                                className: 'attr',
                                starts: {
                                    end: /$/,
                                    contains: [
                                        COMMENTS,
                                        ARRAY,
                                        LITERALS,
                                        VARIABLES,
                                        STRINGS,
                                        NUMBERS,
                                    ],
                                },
                            },
                        ],
                    };
                }
                ini_1 = ini;
                return ini_1;
            }
            var java_1;
            var hasRequiredJava;
            function requireJava() {
                if (hasRequiredJava) return java_1;
                hasRequiredJava = 1;
                var decimalDigits = '[0-9](_*[0-9])*';
                var frac = `\\.(${decimalDigits})`;
                var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';
                var NUMERIC = {
                    className: 'number',
                    variants: [
                        // DecimalFloatingPointLiteral
                        // including ExponentPart
                        {
                            begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})[fFdD]?\\b`,
                        },
                        // excluding ExponentPart
                        {
                            begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)`,
                        },
                        { begin: `(${frac})[fFdD]?\\b` },
                        { begin: `\\b(${decimalDigits})[fFdD]\\b` },
                        // HexadecimalFloatingPointLiteral
                        {
                            begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))[pP][+-]?(${decimalDigits})[fFdD]?\\b`,
                        },
                        // DecimalIntegerLiteral
                        { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
                        // HexIntegerLiteral
                        { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
                        // OctalIntegerLiteral
                        { begin: '\\b0(_*[0-7])*[lL]?\\b' },
                        // BinaryIntegerLiteral
                        { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
                    ],
                    relevance: 0,
                };
                function recurRegex(re, substitution, depth) {
                    if (depth === -1) return '';
                    return re.replace(substitution, (_) => {
                        return recurRegex(re, substitution, depth - 1);
                    });
                }
                function java(hljs2) {
                    const regex = hljs2.regex;
                    const JAVA_IDENT_RE = '[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*';
                    const GENERIC_IDENT_RE =
                        JAVA_IDENT_RE +
                        recurRegex(
                            '(?:<' +
                                JAVA_IDENT_RE +
                                '~~~(?:\\s*,\\s*' +
                                JAVA_IDENT_RE +
                                '~~~)*>)?',
                            /~~~/g,
                            2
                        );
                    const MAIN_KEYWORDS = [
                        'synchronized',
                        'abstract',
                        'private',
                        'var',
                        'static',
                        'if',
                        'const ',
                        'for',
                        'while',
                        'strictfp',
                        'finally',
                        'protected',
                        'import',
                        'native',
                        'final',
                        'void',
                        'enum',
                        'else',
                        'break',
                        'transient',
                        'catch',
                        'instanceof',
                        'volatile',
                        'case',
                        'assert',
                        'package',
                        'default',
                        'public',
                        'try',
                        'switch',
                        'continue',
                        'throws',
                        'protected',
                        'public',
                        'private',
                        'module',
                        'requires',
                        'exports',
                        'do',
                        'sealed',
                        'yield',
                        'permits',
                    ];
                    const BUILT_INS = ['super', 'this'];
                    const LITERALS = ['false', 'true', 'null'];
                    const TYPES = [
                        'char',
                        'boolean',
                        'long',
                        'float',
                        'int',
                        'byte',
                        'short',
                        'double',
                    ];
                    const KEYWORDS = {
                        keyword: MAIN_KEYWORDS,
                        literal: LITERALS,
                        type: TYPES,
                        built_in: BUILT_INS,
                    };
                    const ANNOTATION = {
                        className: 'meta',
                        begin: '@' + JAVA_IDENT_RE,
                        contains: [
                            {
                                begin: /\(/,
                                end: /\)/,
                                contains: ['self'],
                                // allow nested () inside our annotation
                            },
                        ],
                    };
                    const PARAMS = {
                        className: 'params',
                        begin: /\(/,
                        end: /\)/,
                        keywords: KEYWORDS,
                        relevance: 0,
                        contains: [hljs2.C_BLOCK_COMMENT_MODE],
                        endsParent: true,
                    };
                    return {
                        name: 'Java',
                        aliases: ['jsp'],
                        keywords: KEYWORDS,
                        illegal: /<\/|#/,
                        contains: [
                            hljs2.COMMENT('/\\*\\*', '\\*/', {
                                relevance: 0,
                                contains: [
                                    {
                                        // eat up @'s in emails to prevent them to be recognized as doctags
                                        begin: /\w+@/,
                                        relevance: 0,
                                    },
                                    {
                                        className: 'doctag',
                                        begin: '@[A-Za-z]+',
                                    },
                                ],
                            }),
                            // relevance boost
                            {
                                begin: /import java\.[a-z]+\./,
                                keywords: 'import',
                                relevance: 2,
                            },
                            hljs2.C_LINE_COMMENT_MODE,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            {
                                begin: /"""/,
                                end: /"""/,
                                className: 'string',
                                contains: [hljs2.BACKSLASH_ESCAPE],
                            },
                            hljs2.APOS_STRING_MODE,
                            hljs2.QUOTE_STRING_MODE,
                            {
                                match: [
                                    /\b(?:class|interface|enum|extends|implements|new)/,
                                    /\s+/,
                                    JAVA_IDENT_RE,
                                ],
                                className: {
                                    1: 'keyword',
                                    3: 'title.class',
                                },
                            },
                            {
                                // Exceptions for hyphenated keywords
                                match: /non-sealed/,
                                scope: 'keyword',
                            },
                            {
                                begin: [
                                    regex.concat(/(?!else)/, JAVA_IDENT_RE),
                                    /\s+/,
                                    JAVA_IDENT_RE,
                                    /\s+/,
                                    /=(?!=)/,
                                ],
                                className: {
                                    1: 'type',
                                    3: 'variable',
                                    5: 'operator',
                                },
                            },
                            {
                                begin: [/record/, /\s+/, JAVA_IDENT_RE],
                                className: {
                                    1: 'keyword',
                                    3: 'title.class',
                                },
                                contains: [
                                    PARAMS,
                                    hljs2.C_LINE_COMMENT_MODE,
                                    hljs2.C_BLOCK_COMMENT_MODE,
                                ],
                            },
                            {
                                // Expression keywords prevent 'keyword Name(...)' from being
                                // recognized as a function definition
                                beginKeywords: 'new throw return else',
                                relevance: 0,
                            },
                            {
                                begin: [
                                    '(?:' + GENERIC_IDENT_RE + '\\s+)',
                                    hljs2.UNDERSCORE_IDENT_RE,
                                    /\s*(?=\()/,
                                ],
                                className: { 2: 'title.function' },
                                keywords: KEYWORDS,
                                contains: [
                                    {
                                        className: 'params',
                                        begin: /\(/,
                                        end: /\)/,
                                        keywords: KEYWORDS,
                                        relevance: 0,
                                        contains: [
                                            ANNOTATION,
                                            hljs2.APOS_STRING_MODE,
                                            hljs2.QUOTE_STRING_MODE,
                                            NUMERIC,
                                            hljs2.C_BLOCK_COMMENT_MODE,
                                        ],
                                    },
                                    hljs2.C_LINE_COMMENT_MODE,
                                    hljs2.C_BLOCK_COMMENT_MODE,
                                ],
                            },
                            NUMERIC,
                            ANNOTATION,
                        ],
                    };
                }
                java_1 = java;
                return java_1;
            }
            var javascript_1;
            var hasRequiredJavascript;
            function requireJavascript() {
                if (hasRequiredJavascript) return javascript_1;
                hasRequiredJavascript = 1;
                const IDENT_RE2 = '[A-Za-z$_][0-9A-Za-z$_]*';
                const KEYWORDS = [
                    'as',
                    // for exports
                    'in',
                    'of',
                    'if',
                    'for',
                    'while',
                    'finally',
                    'var',
                    'new',
                    'function',
                    'do',
                    'return',
                    'void',
                    'else',
                    'break',
                    'catch',
                    'instanceof',
                    'with',
                    'throw',
                    'case',
                    'default',
                    'try',
                    'switch',
                    'continue',
                    'typeof',
                    'delete',
                    'let',
                    'yield',
                    'const',
                    'class',
                    // JS handles these with a special rule
                    // "get",
                    // "set",
                    'debugger',
                    'async',
                    'await',
                    'static',
                    'import',
                    'from',
                    'export',
                    'extends',
                ];
                const LITERALS = [
                    'true',
                    'false',
                    'null',
                    'undefined',
                    'NaN',
                    'Infinity',
                ];
                const TYPES = [
                    // Fundamental objects
                    'Object',
                    'Function',
                    'Boolean',
                    'Symbol',
                    // numbers and dates
                    'Math',
                    'Date',
                    'Number',
                    'BigInt',
                    // text
                    'String',
                    'RegExp',
                    // Indexed collections
                    'Array',
                    'Float32Array',
                    'Float64Array',
                    'Int8Array',
                    'Uint8Array',
                    'Uint8ClampedArray',
                    'Int16Array',
                    'Int32Array',
                    'Uint16Array',
                    'Uint32Array',
                    'BigInt64Array',
                    'BigUint64Array',
                    // Keyed collections
                    'Set',
                    'Map',
                    'WeakSet',
                    'WeakMap',
                    // Structured data
                    'ArrayBuffer',
                    'SharedArrayBuffer',
                    'Atomics',
                    'DataView',
                    'JSON',
                    // Control abstraction objects
                    'Promise',
                    'Generator',
                    'GeneratorFunction',
                    'AsyncFunction',
                    // Reflection
                    'Reflect',
                    'Proxy',
                    // Internationalization
                    'Intl',
                    // WebAssembly
                    'WebAssembly',
                ];
                const ERROR_TYPES = [
                    'Error',
                    'EvalError',
                    'InternalError',
                    'RangeError',
                    'ReferenceError',
                    'SyntaxError',
                    'TypeError',
                    'URIError',
                ];
                const BUILT_IN_GLOBALS = [
                    'setInterval',
                    'setTimeout',
                    'clearInterval',
                    'clearTimeout',
                    'require',
                    'exports',
                    'eval',
                    'isFinite',
                    'isNaN',
                    'parseFloat',
                    'parseInt',
                    'decodeURI',
                    'decodeURIComponent',
                    'encodeURI',
                    'encodeURIComponent',
                    'escape',
                    'unescape',
                ];
                const BUILT_IN_VARIABLES = [
                    'arguments',
                    'this',
                    'super',
                    'console',
                    'window',
                    'document',
                    'localStorage',
                    'sessionStorage',
                    'module',
                    'global',
                    // Node.js
                ];
                const BUILT_INS = [].concat(
                    BUILT_IN_GLOBALS,
                    TYPES,
                    ERROR_TYPES
                );
                function javascript(hljs2) {
                    const regex = hljs2.regex;
                    const hasClosingTag = (match, { after }) => {
                        const tag = '</' + match[0].slice(1);
                        const pos = match.input.indexOf(tag, after);
                        return pos !== -1;
                    };
                    const IDENT_RE$1 = IDENT_RE2;
                    const FRAGMENT = {
                        begin: '<>',
                        end: '</>',
                    };
                    const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
                    const XML_TAG = {
                        begin: /<[A-Za-z0-9\\._:-]+/,
                        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
                        /**
                         * @param {RegExpMatchArray} match
                         * @param {CallbackResponse} response
                         */
                        isTrulyOpeningTag: (match, response) => {
                            const afterMatchIndex =
                                match[0].length + match.index;
                            const nextChar = match.input[afterMatchIndex];
                            if (
                                // HTML should not include another raw `<` inside a tag
                                // nested type?
                                // `<Array<Array<number>>`, etc.
                                nextChar === '<' || // the , gives away that this is not HTML
                                // `<T, A extends keyof T, V>`
                                nextChar === ','
                            ) {
                                response.ignoreMatch();
                                return;
                            }
                            if (nextChar === '>') {
                                if (
                                    !hasClosingTag(match, {
                                        after: afterMatchIndex,
                                    })
                                ) {
                                    response.ignoreMatch();
                                }
                            }
                            let m;
                            const afterMatch =
                                match.input.substring(afterMatchIndex);
                            if ((m = afterMatch.match(/^\s*=/))) {
                                response.ignoreMatch();
                                return;
                            }
                            if ((m = afterMatch.match(/^\s+extends\s+/))) {
                                if (m.index === 0) {
                                    response.ignoreMatch();
                                    return;
                                }
                            }
                        },
                    };
                    const KEYWORDS$1 = {
                        $pattern: IDENT_RE2,
                        keyword: KEYWORDS,
                        literal: LITERALS,
                        built_in: BUILT_INS,
                        'variable.language': BUILT_IN_VARIABLES,
                    };
                    const decimalDigits = '[0-9](_?[0-9])*';
                    const frac = `\\.(${decimalDigits})`;
                    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
                    const NUMBER = {
                        className: 'number',
                        variants: [
                            // DecimalLiteral
                            {
                                begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b`,
                            },
                            {
                                begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b`,
                            },
                            // DecimalBigIntegerLiteral
                            { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
                            // NonDecimalIntegerLiteral
                            {
                                begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b',
                            },
                            { begin: '\\b0[bB][0-1](_?[0-1])*n?\\b' },
                            { begin: '\\b0[oO][0-7](_?[0-7])*n?\\b' },
                            // LegacyOctalIntegerLiteral (does not include underscore separators)
                            // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
                            { begin: '\\b0[0-7]+n?\\b' },
                        ],
                        relevance: 0,
                    };
                    const SUBST = {
                        className: 'subst',
                        begin: '\\$\\{',
                        end: '\\}',
                        keywords: KEYWORDS$1,
                        contains: [],
                        // defined later
                    };
                    const HTML_TEMPLATE = {
                        begin: 'html`',
                        end: '',
                        starts: {
                            end: '`',
                            returnEnd: false,
                            contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                            subLanguage: 'xml',
                        },
                    };
                    const CSS_TEMPLATE = {
                        begin: 'css`',
                        end: '',
                        starts: {
                            end: '`',
                            returnEnd: false,
                            contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                            subLanguage: 'css',
                        },
                    };
                    const GRAPHQL_TEMPLATE = {
                        begin: 'gql`',
                        end: '',
                        starts: {
                            end: '`',
                            returnEnd: false,
                            contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                            subLanguage: 'graphql',
                        },
                    };
                    const TEMPLATE_STRING = {
                        className: 'string',
                        begin: '`',
                        end: '`',
                        contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                    };
                    const JSDOC_COMMENT = hljs2.COMMENT(
                        /\/\*\*(?!\/)/,
                        '\\*/',
                        {
                            relevance: 0,
                            contains: [
                                {
                                    begin: '(?=@[A-Za-z]+)',
                                    relevance: 0,
                                    contains: [
                                        {
                                            className: 'doctag',
                                            begin: '@[A-Za-z]+',
                                        },
                                        {
                                            className: 'type',
                                            begin: '\\{',
                                            end: '\\}',
                                            excludeEnd: true,
                                            excludeBegin: true,
                                            relevance: 0,
                                        },
                                        {
                                            className: 'variable',
                                            begin: IDENT_RE$1 + '(?=\\s*(-)|$)',
                                            endsParent: true,
                                            relevance: 0,
                                        },
                                        // eat spaces (not newlines) so we can find
                                        // types or variables
                                        {
                                            begin: /(?=[^\n])\s/,
                                            relevance: 0,
                                        },
                                    ],
                                },
                            ],
                        }
                    );
                    const COMMENT2 = {
                        className: 'comment',
                        variants: [
                            JSDOC_COMMENT,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            hljs2.C_LINE_COMMENT_MODE,
                        ],
                    };
                    const SUBST_INTERNALS = [
                        hljs2.APOS_STRING_MODE,
                        hljs2.QUOTE_STRING_MODE,
                        HTML_TEMPLATE,
                        CSS_TEMPLATE,
                        GRAPHQL_TEMPLATE,
                        TEMPLATE_STRING,
                        // Skip numbers when they are part of a variable name
                        { match: /\$\d+/ },
                        NUMBER,
                        // This is intentional:
                        // See https://github.com/highlightjs/highlight.js/issues/3288
                        // hljs.REGEXP_MODE
                    ];
                    SUBST.contains = SUBST_INTERNALS.concat({
                        // we need to pair up {} inside our subst to prevent
                        // it from ending too early by matching another }
                        begin: /\{/,
                        end: /\}/,
                        keywords: KEYWORDS$1,
                        contains: ['self'].concat(SUBST_INTERNALS),
                    });
                    const SUBST_AND_COMMENTS = [].concat(
                        COMMENT2,
                        SUBST.contains
                    );
                    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
                        // eat recursive parens in sub expressions
                        {
                            begin: /\(/,
                            end: /\)/,
                            keywords: KEYWORDS$1,
                            contains: ['self'].concat(SUBST_AND_COMMENTS),
                        },
                    ]);
                    const PARAMS = {
                        className: 'params',
                        begin: /\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS$1,
                        contains: PARAMS_CONTAINS,
                    };
                    const CLASS_OR_EXTENDS = {
                        variants: [
                            // class Car extends vehicle
                            {
                                match: [
                                    /class/,
                                    /\s+/,
                                    IDENT_RE$1,
                                    /\s+/,
                                    /extends/,
                                    /\s+/,
                                    regex.concat(
                                        IDENT_RE$1,
                                        '(',
                                        regex.concat(/\./, IDENT_RE$1),
                                        ')*'
                                    ),
                                ],
                                scope: {
                                    1: 'keyword',
                                    3: 'title.class',
                                    5: 'keyword',
                                    7: 'title.class.inherited',
                                },
                            },
                            // class Car
                            {
                                match: [/class/, /\s+/, IDENT_RE$1],
                                scope: {
                                    1: 'keyword',
                                    3: 'title.class',
                                },
                            },
                        ],
                    };
                    const CLASS_REFERENCE = {
                        relevance: 0,
                        match: regex.either(
                            // Hard coded exceptions
                            /\bJSON/,
                            // Float32Array, OutT
                            /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
                            // CSSFactory, CSSFactoryT
                            /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
                            // FPs, FPsT
                            /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
                            // P
                            // single letters are not highlighted
                            // BLAH
                            // this will be flagged as a UPPER_CASE_CONSTANT instead
                        ),
                        className: 'title.class',
                        keywords: {
                            _: [
                                // se we still get relevance credit for JS library classes
                                ...TYPES,
                                ...ERROR_TYPES,
                            ],
                        },
                    };
                    const USE_STRICT = {
                        label: 'use_strict',
                        className: 'meta',
                        relevance: 10,
                        begin: /^\s*['"]use (strict|asm)['"]/,
                    };
                    const FUNCTION_DEFINITION = {
                        variants: [
                            {
                                match: [
                                    /function/,
                                    /\s+/,
                                    IDENT_RE$1,
                                    /(?=\s*\()/,
                                ],
                            },
                            // anonymous function
                            {
                                match: [/function/, /\s*(?=\()/],
                            },
                        ],
                        className: {
                            1: 'keyword',
                            3: 'title.function',
                        },
                        label: 'func.def',
                        contains: [PARAMS],
                        illegal: /%/,
                    };
                    const UPPER_CASE_CONSTANT = {
                        relevance: 0,
                        match: /\b[A-Z][A-Z_0-9]+\b/,
                        className: 'variable.constant',
                    };
                    function noneOf(list2) {
                        return regex.concat('(?!', list2.join('|'), ')');
                    }
                    const FUNCTION_CALL = {
                        match: regex.concat(
                            /\b/,
                            noneOf([...BUILT_IN_GLOBALS, 'super', 'import']),
                            IDENT_RE$1,
                            regex.lookahead(/\(/)
                        ),
                        className: 'title.function',
                        relevance: 0,
                    };
                    const PROPERTY_ACCESS = {
                        begin: regex.concat(
                            /\./,
                            regex.lookahead(
                                regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
                            )
                        ),
                        end: IDENT_RE$1,
                        excludeBegin: true,
                        keywords: 'prototype',
                        className: 'property',
                        relevance: 0,
                    };
                    const GETTER_OR_SETTER = {
                        match: [/get|set/, /\s+/, IDENT_RE$1, /(?=\()/],
                        className: {
                            1: 'keyword',
                            3: 'title.function',
                        },
                        contains: [
                            {
                                // eat to avoid empty params
                                begin: /\(\)/,
                            },
                            PARAMS,
                        ],
                    };
                    const FUNC_LEAD_IN_RE =
                        '(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|' +
                        hljs2.UNDERSCORE_IDENT_RE +
                        ')\\s*=>';
                    const FUNCTION_VARIABLE = {
                        match: [
                            /const|var|let/,
                            /\s+/,
                            IDENT_RE$1,
                            /\s*/,
                            /=\s*/,
                            /(async\s*)?/,
                            // async is optional
                            regex.lookahead(FUNC_LEAD_IN_RE),
                        ],
                        keywords: 'async',
                        className: {
                            1: 'keyword',
                            3: 'title.function',
                        },
                        contains: [PARAMS],
                    };
                    return {
                        name: 'JavaScript',
                        aliases: ['js', 'jsx', 'mjs', 'cjs'],
                        keywords: KEYWORDS$1,
                        // this will be extended by TypeScript
                        exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
                        illegal: /#(?![$_A-z])/,
                        contains: [
                            hljs2.SHEBANG({
                                label: 'shebang',
                                binary: 'node',
                                relevance: 5,
                            }),
                            USE_STRICT,
                            hljs2.APOS_STRING_MODE,
                            hljs2.QUOTE_STRING_MODE,
                            HTML_TEMPLATE,
                            CSS_TEMPLATE,
                            GRAPHQL_TEMPLATE,
                            TEMPLATE_STRING,
                            COMMENT2,
                            // Skip numbers when they are part of a variable name
                            { match: /\$\d+/ },
                            NUMBER,
                            CLASS_REFERENCE,
                            {
                                className: 'attr',
                                begin: IDENT_RE$1 + regex.lookahead(':'),
                                relevance: 0,
                            },
                            FUNCTION_VARIABLE,
                            {
                                // "value" container
                                begin:
                                    '(' +
                                    hljs2.RE_STARTERS_RE +
                                    '|\\b(case|return|throw)\\b)\\s*',
                                keywords: 'return throw case',
                                relevance: 0,
                                contains: [
                                    COMMENT2,
                                    hljs2.REGEXP_MODE,
                                    {
                                        className: 'function',
                                        // we have to count the parens to make sure we actually have the
                                        // correct bounding ( ) before the =>.  There could be any number of
                                        // sub-expressions inside also surrounded by parens.
                                        begin: FUNC_LEAD_IN_RE,
                                        returnBegin: true,
                                        end: '\\s*=>',
                                        contains: [
                                            {
                                                className: 'params',
                                                variants: [
                                                    {
                                                        begin: hljs2.UNDERSCORE_IDENT_RE,
                                                        relevance: 0,
                                                    },
                                                    {
                                                        className: null,
                                                        begin: /\(\s*\)/,
                                                        skip: true,
                                                    },
                                                    {
                                                        begin: /\(/,
                                                        end: /\)/,
                                                        excludeBegin: true,
                                                        excludeEnd: true,
                                                        keywords: KEYWORDS$1,
                                                        contains:
                                                            PARAMS_CONTAINS,
                                                    },
                                                ],
                                            },
                                        ],
                                    },
                                    {
                                        // could be a comma delimited list of params to a function call
                                        begin: /,/,
                                        relevance: 0,
                                    },
                                    {
                                        match: /\s+/,
                                        relevance: 0,
                                    },
                                    {
                                        // JSX
                                        variants: [
                                            {
                                                begin: FRAGMENT.begin,
                                                end: FRAGMENT.end,
                                            },
                                            { match: XML_SELF_CLOSING },
                                            {
                                                begin: XML_TAG.begin,
                                                // we carefully check the opening tag to see if it truly
                                                // is a tag and not a false positive
                                                'on:begin':
                                                    XML_TAG.isTrulyOpeningTag,
                                                end: XML_TAG.end,
                                            },
                                        ],
                                        subLanguage: 'xml',
                                        contains: [
                                            {
                                                begin: XML_TAG.begin,
                                                end: XML_TAG.end,
                                                skip: true,
                                                contains: ['self'],
                                            },
                                        ],
                                    },
                                ],
                            },
                            FUNCTION_DEFINITION,
                            {
                                // prevent this from getting swallowed up by function
                                // since they appear "function like"
                                beginKeywords: 'while if switch catch for',
                            },
                            {
                                // we have to count the parens to make sure we actually have the correct
                                // bounding ( ).  There could be any number of sub-expressions inside
                                // also surrounded by parens.
                                begin:
                                    '\\b(?!function)' +
                                    hljs2.UNDERSCORE_IDENT_RE +
                                    '\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{',
                                // end parens
                                returnBegin: true,
                                label: 'func.def',
                                contains: [
                                    PARAMS,
                                    hljs2.inherit(hljs2.TITLE_MODE, {
                                        begin: IDENT_RE$1,
                                        className: 'title.function',
                                    }),
                                ],
                            },
                            // catch ... so it won't trigger the property rule below
                            {
                                match: /\.\.\./,
                                relevance: 0,
                            },
                            PROPERTY_ACCESS,
                            // hack: prevents detection of keywords in some circumstances
                            // .keyword()
                            // $keyword = x
                            {
                                match: '\\$' + IDENT_RE$1,
                                relevance: 0,
                            },
                            {
                                match: [/\bconstructor(?=\s*\()/],
                                className: { 1: 'title.function' },
                                contains: [PARAMS],
                            },
                            FUNCTION_CALL,
                            UPPER_CASE_CONSTANT,
                            CLASS_OR_EXTENDS,
                            GETTER_OR_SETTER,
                            {
                                match: /\$[(.]/,
                                // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
                            },
                        ],
                    };
                }
                javascript_1 = javascript;
                return javascript_1;
            }
            var json_1;
            var hasRequiredJson;
            function requireJson() {
                if (hasRequiredJson) return json_1;
                hasRequiredJson = 1;
                function json(hljs2) {
                    const ATTRIBUTE = {
                        className: 'attr',
                        begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
                        relevance: 1.01,
                    };
                    const PUNCTUATION = {
                        match: /[{}[\],:]/,
                        className: 'punctuation',
                        relevance: 0,
                    };
                    const LITERALS = ['true', 'false', 'null'];
                    const LITERALS_MODE = {
                        scope: 'literal',
                        beginKeywords: LITERALS.join(' '),
                    };
                    return {
                        name: 'JSON',
                        keywords: {
                            literal: LITERALS,
                        },
                        contains: [
                            ATTRIBUTE,
                            PUNCTUATION,
                            hljs2.QUOTE_STRING_MODE,
                            LITERALS_MODE,
                            hljs2.C_NUMBER_MODE,
                            hljs2.C_LINE_COMMENT_MODE,
                            hljs2.C_BLOCK_COMMENT_MODE,
                        ],
                        illegal: '\\S',
                    };
                }
                json_1 = json;
                return json_1;
            }
            var kotlin_1;
            var hasRequiredKotlin;
            function requireKotlin() {
                if (hasRequiredKotlin) return kotlin_1;
                hasRequiredKotlin = 1;
                var decimalDigits = '[0-9](_*[0-9])*';
                var frac = `\\.(${decimalDigits})`;
                var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';
                var NUMERIC = {
                    className: 'number',
                    variants: [
                        // DecimalFloatingPointLiteral
                        // including ExponentPart
                        {
                            begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})[fFdD]?\\b`,
                        },
                        // excluding ExponentPart
                        {
                            begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)`,
                        },
                        { begin: `(${frac})[fFdD]?\\b` },
                        { begin: `\\b(${decimalDigits})[fFdD]\\b` },
                        // HexadecimalFloatingPointLiteral
                        {
                            begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))[pP][+-]?(${decimalDigits})[fFdD]?\\b`,
                        },
                        // DecimalIntegerLiteral
                        { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
                        // HexIntegerLiteral
                        { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
                        // OctalIntegerLiteral
                        { begin: '\\b0(_*[0-7])*[lL]?\\b' },
                        // BinaryIntegerLiteral
                        { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
                    ],
                    relevance: 0,
                };
                function kotlin(hljs2) {
                    const KEYWORDS = {
                        keyword:
                            'abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual',
                        built_in:
                            'Byte Short Char Int Long Boolean Float Double Void Unit Nothing',
                        literal: 'true false null',
                    };
                    const KEYWORDS_WITH_LABEL = {
                        className: 'keyword',
                        begin: /\b(break|continue|return|this)\b/,
                        starts: {
                            contains: [
                                {
                                    className: 'symbol',
                                    begin: /@\w+/,
                                },
                            ],
                        },
                    };
                    const LABEL = {
                        className: 'symbol',
                        begin: hljs2.UNDERSCORE_IDENT_RE + '@',
                    };
                    const SUBST = {
                        className: 'subst',
                        begin: /\$\{/,
                        end: /\}/,
                        contains: [hljs2.C_NUMBER_MODE],
                    };
                    const VARIABLE = {
                        className: 'variable',
                        begin: '\\$' + hljs2.UNDERSCORE_IDENT_RE,
                    };
                    const STRING = {
                        className: 'string',
                        variants: [
                            {
                                begin: '"""',
                                end: '"""(?=[^"])',
                                contains: [VARIABLE, SUBST],
                            },
                            // Can't use built-in modes easily, as we want to use STRING in the meta
                            // context as 'meta-string' and there's no syntax to remove explicitly set
                            // classNames in built-in modes.
                            {
                                begin: "'",
                                end: "'",
                                illegal: /\n/,
                                contains: [hljs2.BACKSLASH_ESCAPE],
                            },
                            {
                                begin: '"',
                                end: '"',
                                illegal: /\n/,
                                contains: [
                                    hljs2.BACKSLASH_ESCAPE,
                                    VARIABLE,
                                    SUBST,
                                ],
                            },
                        ],
                    };
                    SUBST.contains.push(STRING);
                    const ANNOTATION_USE_SITE = {
                        className: 'meta',
                        begin:
                            '@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*' +
                            hljs2.UNDERSCORE_IDENT_RE +
                            ')?',
                    };
                    const ANNOTATION = {
                        className: 'meta',
                        begin: '@' + hljs2.UNDERSCORE_IDENT_RE,
                        contains: [
                            {
                                begin: /\(/,
                                end: /\)/,
                                contains: [
                                    hljs2.inherit(STRING, {
                                        className: 'string',
                                    }),
                                    'self',
                                ],
                            },
                        ],
                    };
                    const KOTLIN_NUMBER_MODE = NUMERIC;
                    const KOTLIN_NESTED_COMMENT = hljs2.COMMENT(
                        '/\\*',
                        '\\*/',
                        { contains: [hljs2.C_BLOCK_COMMENT_MODE] }
                    );
                    const KOTLIN_PAREN_TYPE = {
                        variants: [
                            {
                                className: 'type',
                                begin: hljs2.UNDERSCORE_IDENT_RE,
                            },
                            {
                                begin: /\(/,
                                end: /\)/,
                                contains: [],
                                // defined later
                            },
                        ],
                    };
                    const KOTLIN_PAREN_TYPE2 = KOTLIN_PAREN_TYPE;
                    KOTLIN_PAREN_TYPE2.variants[1].contains = [
                        KOTLIN_PAREN_TYPE,
                    ];
                    KOTLIN_PAREN_TYPE.variants[1].contains = [
                        KOTLIN_PAREN_TYPE2,
                    ];
                    return {
                        name: 'Kotlin',
                        aliases: ['kt', 'kts'],
                        keywords: KEYWORDS,
                        contains: [
                            hljs2.COMMENT('/\\*\\*', '\\*/', {
                                relevance: 0,
                                contains: [
                                    {
                                        className: 'doctag',
                                        begin: '@[A-Za-z]+',
                                    },
                                ],
                            }),
                            hljs2.C_LINE_COMMENT_MODE,
                            KOTLIN_NESTED_COMMENT,
                            KEYWORDS_WITH_LABEL,
                            LABEL,
                            ANNOTATION_USE_SITE,
                            ANNOTATION,
                            {
                                className: 'function',
                                beginKeywords: 'fun',
                                end: '[(]|$',
                                returnBegin: true,
                                excludeEnd: true,
                                keywords: KEYWORDS,
                                relevance: 5,
                                contains: [
                                    {
                                        begin:
                                            hljs2.UNDERSCORE_IDENT_RE +
                                            '\\s*\\(',
                                        returnBegin: true,
                                        relevance: 0,
                                        contains: [hljs2.UNDERSCORE_TITLE_MODE],
                                    },
                                    {
                                        className: 'type',
                                        begin: /</,
                                        end: />/,
                                        keywords: 'reified',
                                        relevance: 0,
                                    },
                                    {
                                        className: 'params',
                                        begin: /\(/,
                                        end: /\)/,
                                        endsParent: true,
                                        keywords: KEYWORDS,
                                        relevance: 0,
                                        contains: [
                                            {
                                                begin: /:/,
                                                end: /[=,\/]/,
                                                endsWithParent: true,
                                                contains: [
                                                    KOTLIN_PAREN_TYPE,
                                                    hljs2.C_LINE_COMMENT_MODE,
                                                    KOTLIN_NESTED_COMMENT,
                                                ],
                                                relevance: 0,
                                            },
                                            hljs2.C_LINE_COMMENT_MODE,
                                            KOTLIN_NESTED_COMMENT,
                                            ANNOTATION_USE_SITE,
                                            ANNOTATION,
                                            STRING,
                                            hljs2.C_NUMBER_MODE,
                                        ],
                                    },
                                    KOTLIN_NESTED_COMMENT,
                                ],
                            },
                            {
                                begin: [
                                    /class|interface|trait/,
                                    /\s+/,
                                    hljs2.UNDERSCORE_IDENT_RE,
                                ],
                                beginScope: {
                                    3: 'title.class',
                                },
                                keywords: 'class interface trait',
                                end: /[:\{(]|$/,
                                excludeEnd: true,
                                illegal: 'extends implements',
                                contains: [
                                    {
                                        beginKeywords:
                                            'public protected internal private constructor',
                                    },
                                    hljs2.UNDERSCORE_TITLE_MODE,
                                    {
                                        className: 'type',
                                        begin: /</,
                                        end: />/,
                                        excludeBegin: true,
                                        excludeEnd: true,
                                        relevance: 0,
                                    },
                                    {
                                        className: 'type',
                                        begin: /[,:]\s*/,
                                        end: /[<\(,){\s]|$/,
                                        excludeBegin: true,
                                        returnEnd: true,
                                    },
                                    ANNOTATION_USE_SITE,
                                    ANNOTATION,
                                ],
                            },
                            STRING,
                            {
                                className: 'meta',
                                begin: '^#!/usr/bin/env',
                                end: '$',
                                illegal: '\n',
                            },
                            KOTLIN_NUMBER_MODE,
                        ],
                    };
                }
                kotlin_1 = kotlin;
                return kotlin_1;
            }
            var less_1;
            var hasRequiredLess;
            function requireLess() {
                if (hasRequiredLess) return less_1;
                hasRequiredLess = 1;
                const MODES2 = (hljs2) => {
                    return {
                        IMPORTANT: {
                            scope: 'meta',
                            begin: '!important',
                        },
                        BLOCK_COMMENT: hljs2.C_BLOCK_COMMENT_MODE,
                        HEXCOLOR: {
                            scope: 'number',
                            begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/,
                        },
                        FUNCTION_DISPATCH: {
                            className: 'built_in',
                            begin: /[\w-]+(?=\()/,
                        },
                        ATTRIBUTE_SELECTOR_MODE: {
                            scope: 'selector-attr',
                            begin: /\[/,
                            end: /\]/,
                            illegal: '$',
                            contains: [
                                hljs2.APOS_STRING_MODE,
                                hljs2.QUOTE_STRING_MODE,
                            ],
                        },
                        CSS_NUMBER_MODE: {
                            scope: 'number',
                            begin:
                                hljs2.NUMBER_RE +
                                '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
                            relevance: 0,
                        },
                        CSS_VARIABLE: {
                            className: 'attr',
                            begin: /--[A-Za-z_][A-Za-z0-9_-]*/,
                        },
                    };
                };
                const TAGS = [
                    'a',
                    'abbr',
                    'address',
                    'article',
                    'aside',
                    'audio',
                    'b',
                    'blockquote',
                    'body',
                    'button',
                    'canvas',
                    'caption',
                    'cite',
                    'code',
                    'dd',
                    'del',
                    'details',
                    'dfn',
                    'div',
                    'dl',
                    'dt',
                    'em',
                    'fieldset',
                    'figcaption',
                    'figure',
                    'footer',
                    'form',
                    'h1',
                    'h2',
                    'h3',
                    'h4',
                    'h5',
                    'h6',
                    'header',
                    'hgroup',
                    'html',
                    'i',
                    'iframe',
                    'img',
                    'input',
                    'ins',
                    'kbd',
                    'label',
                    'legend',
                    'li',
                    'main',
                    'mark',
                    'menu',
                    'nav',
                    'object',
                    'ol',
                    'p',
                    'q',
                    'quote',
                    'samp',
                    'section',
                    'span',
                    'strong',
                    'summary',
                    'sup',
                    'table',
                    'tbody',
                    'td',
                    'textarea',
                    'tfoot',
                    'th',
                    'thead',
                    'time',
                    'tr',
                    'ul',
                    'var',
                    'video',
                ];
                const MEDIA_FEATURES = [
                    'any-hover',
                    'any-pointer',
                    'aspect-ratio',
                    'color',
                    'color-gamut',
                    'color-index',
                    'device-aspect-ratio',
                    'device-height',
                    'device-width',
                    'display-mode',
                    'forced-colors',
                    'grid',
                    'height',
                    'hover',
                    'inverted-colors',
                    'monochrome',
                    'orientation',
                    'overflow-block',
                    'overflow-inline',
                    'pointer',
                    'prefers-color-scheme',
                    'prefers-contrast',
                    'prefers-reduced-motion',
                    'prefers-reduced-transparency',
                    'resolution',
                    'scan',
                    'scripting',
                    'update',
                    'width',
                    // TODO: find a better solution?
                    'min-width',
                    'max-width',
                    'min-height',
                    'max-height',
                ];
                const PSEUDO_CLASSES = [
                    'active',
                    'any-link',
                    'blank',
                    'checked',
                    'current',
                    'default',
                    'defined',
                    'dir',
                    // dir()
                    'disabled',
                    'drop',
                    'empty',
                    'enabled',
                    'first',
                    'first-child',
                    'first-of-type',
                    'fullscreen',
                    'future',
                    'focus',
                    'focus-visible',
                    'focus-within',
                    'has',
                    // has()
                    'host',
                    // host or host()
                    'host-context',
                    // host-context()
                    'hover',
                    'indeterminate',
                    'in-range',
                    'invalid',
                    'is',
                    // is()
                    'lang',
                    // lang()
                    'last-child',
                    'last-of-type',
                    'left',
                    'link',
                    'local-link',
                    'not',
                    // not()
                    'nth-child',
                    // nth-child()
                    'nth-col',
                    // nth-col()
                    'nth-last-child',
                    // nth-last-child()
                    'nth-last-col',
                    // nth-last-col()
                    'nth-last-of-type',
                    //nth-last-of-type()
                    'nth-of-type',
                    //nth-of-type()
                    'only-child',
                    'only-of-type',
                    'optional',
                    'out-of-range',
                    'past',
                    'placeholder-shown',
                    'read-only',
                    'read-write',
                    'required',
                    'right',
                    'root',
                    'scope',
                    'target',
                    'target-within',
                    'user-invalid',
                    'valid',
                    'visited',
                    'where',
                    // where()
                ];
                const PSEUDO_ELEMENTS = [
                    'after',
                    'backdrop',
                    'before',
                    'cue',
                    'cue-region',
                    'first-letter',
                    'first-line',
                    'grammar-error',
                    'marker',
                    'part',
                    'placeholder',
                    'selection',
                    'slotted',
                    'spelling-error',
                ];
                const ATTRIBUTES = [
                    'align-content',
                    'align-items',
                    'align-self',
                    'all',
                    'animation',
                    'animation-delay',
                    'animation-direction',
                    'animation-duration',
                    'animation-fill-mode',
                    'animation-iteration-count',
                    'animation-name',
                    'animation-play-state',
                    'animation-timing-function',
                    'backface-visibility',
                    'background',
                    'background-attachment',
                    'background-blend-mode',
                    'background-clip',
                    'background-color',
                    'background-image',
                    'background-origin',
                    'background-position',
                    'background-repeat',
                    'background-size',
                    'block-size',
                    'border',
                    'border-block',
                    'border-block-color',
                    'border-block-end',
                    'border-block-end-color',
                    'border-block-end-style',
                    'border-block-end-width',
                    'border-block-start',
                    'border-block-start-color',
                    'border-block-start-style',
                    'border-block-start-width',
                    'border-block-style',
                    'border-block-width',
                    'border-bottom',
                    'border-bottom-color',
                    'border-bottom-left-radius',
                    'border-bottom-right-radius',
                    'border-bottom-style',
                    'border-bottom-width',
                    'border-collapse',
                    'border-color',
                    'border-image',
                    'border-image-outset',
                    'border-image-repeat',
                    'border-image-slice',
                    'border-image-source',
                    'border-image-width',
                    'border-inline',
                    'border-inline-color',
                    'border-inline-end',
                    'border-inline-end-color',
                    'border-inline-end-style',
                    'border-inline-end-width',
                    'border-inline-start',
                    'border-inline-start-color',
                    'border-inline-start-style',
                    'border-inline-start-width',
                    'border-inline-style',
                    'border-inline-width',
                    'border-left',
                    'border-left-color',
                    'border-left-style',
                    'border-left-width',
                    'border-radius',
                    'border-right',
                    'border-right-color',
                    'border-right-style',
                    'border-right-width',
                    'border-spacing',
                    'border-style',
                    'border-top',
                    'border-top-color',
                    'border-top-left-radius',
                    'border-top-right-radius',
                    'border-top-style',
                    'border-top-width',
                    'border-width',
                    'bottom',
                    'box-decoration-break',
                    'box-shadow',
                    'box-sizing',
                    'break-after',
                    'break-before',
                    'break-inside',
                    'caption-side',
                    'caret-color',
                    'clear',
                    'clip',
                    'clip-path',
                    'clip-rule',
                    'color',
                    'column-count',
                    'column-fill',
                    'column-gap',
                    'column-rule',
                    'column-rule-color',
                    'column-rule-style',
                    'column-rule-width',
                    'column-span',
                    'column-width',
                    'columns',
                    'contain',
                    'content',
                    'content-visibility',
                    'counter-increment',
                    'counter-reset',
                    'cue',
                    'cue-after',
                    'cue-before',
                    'cursor',
                    'direction',
                    'display',
                    'empty-cells',
                    'filter',
                    'flex',
                    'flex-basis',
                    'flex-direction',
                    'flex-flow',
                    'flex-grow',
                    'flex-shrink',
                    'flex-wrap',
                    'float',
                    'flow',
                    'font',
                    'font-display',
                    'font-family',
                    'font-feature-settings',
                    'font-kerning',
                    'font-language-override',
                    'font-size',
                    'font-size-adjust',
                    'font-smoothing',
                    'font-stretch',
                    'font-style',
                    'font-synthesis',
                    'font-variant',
                    'font-variant-caps',
                    'font-variant-east-asian',
                    'font-variant-ligatures',
                    'font-variant-numeric',
                    'font-variant-position',
                    'font-variation-settings',
                    'font-weight',
                    'gap',
                    'glyph-orientation-vertical',
                    'grid',
                    'grid-area',
                    'grid-auto-columns',
                    'grid-auto-flow',
                    'grid-auto-rows',
                    'grid-column',
                    'grid-column-end',
                    'grid-column-start',
                    'grid-gap',
                    'grid-row',
                    'grid-row-end',
                    'grid-row-start',
                    'grid-template',
                    'grid-template-areas',
                    'grid-template-columns',
                    'grid-template-rows',
                    'hanging-punctuation',
                    'height',
                    'hyphens',
                    'icon',
                    'image-orientation',
                    'image-rendering',
                    'image-resolution',
                    'ime-mode',
                    'inline-size',
                    'isolation',
                    'justify-content',
                    'left',
                    'letter-spacing',
                    'line-break',
                    'line-height',
                    'list-style',
                    'list-style-image',
                    'list-style-position',
                    'list-style-type',
                    'margin',
                    'margin-block',
                    'margin-block-end',
                    'margin-block-start',
                    'margin-bottom',
                    'margin-inline',
                    'margin-inline-end',
                    'margin-inline-start',
                    'margin-left',
                    'margin-right',
                    'margin-top',
                    'marks',
                    'mask',
                    'mask-border',
                    'mask-border-mode',
                    'mask-border-outset',
                    'mask-border-repeat',
                    'mask-border-slice',
                    'mask-border-source',
                    'mask-border-width',
                    'mask-clip',
                    'mask-composite',
                    'mask-image',
                    'mask-mode',
                    'mask-origin',
                    'mask-position',
                    'mask-repeat',
                    'mask-size',
                    'mask-type',
                    'max-block-size',
                    'max-height',
                    'max-inline-size',
                    'max-width',
                    'min-block-size',
                    'min-height',
                    'min-inline-size',
                    'min-width',
                    'mix-blend-mode',
                    'nav-down',
                    'nav-index',
                    'nav-left',
                    'nav-right',
                    'nav-up',
                    'none',
                    'normal',
                    'object-fit',
                    'object-position',
                    'opacity',
                    'order',
                    'orphans',
                    'outline',
                    'outline-color',
                    'outline-offset',
                    'outline-style',
                    'outline-width',
                    'overflow',
                    'overflow-wrap',
                    'overflow-x',
                    'overflow-y',
                    'padding',
                    'padding-block',
                    'padding-block-end',
                    'padding-block-start',
                    'padding-bottom',
                    'padding-inline',
                    'padding-inline-end',
                    'padding-inline-start',
                    'padding-left',
                    'padding-right',
                    'padding-top',
                    'page-break-after',
                    'page-break-before',
                    'page-break-inside',
                    'pause',
                    'pause-after',
                    'pause-before',
                    'perspective',
                    'perspective-origin',
                    'pointer-events',
                    'position',
                    'quotes',
                    'resize',
                    'rest',
                    'rest-after',
                    'rest-before',
                    'right',
                    'row-gap',
                    'scroll-margin',
                    'scroll-margin-block',
                    'scroll-margin-block-end',
                    'scroll-margin-block-start',
                    'scroll-margin-bottom',
                    'scroll-margin-inline',
                    'scroll-margin-inline-end',
                    'scroll-margin-inline-start',
                    'scroll-margin-left',
                    'scroll-margin-right',
                    'scroll-margin-top',
                    'scroll-padding',
                    'scroll-padding-block',
                    'scroll-padding-block-end',
                    'scroll-padding-block-start',
                    'scroll-padding-bottom',
                    'scroll-padding-inline',
                    'scroll-padding-inline-end',
                    'scroll-padding-inline-start',
                    'scroll-padding-left',
                    'scroll-padding-right',
                    'scroll-padding-top',
                    'scroll-snap-align',
                    'scroll-snap-stop',
                    'scroll-snap-type',
                    'scrollbar-color',
                    'scrollbar-gutter',
                    'scrollbar-width',
                    'shape-image-threshold',
                    'shape-margin',
                    'shape-outside',
                    'speak',
                    'speak-as',
                    'src',
                    // @font-face
                    'tab-size',
                    'table-layout',
                    'text-align',
                    'text-align-all',
                    'text-align-last',
                    'text-combine-upright',
                    'text-decoration',
                    'text-decoration-color',
                    'text-decoration-line',
                    'text-decoration-style',
                    'text-emphasis',
                    'text-emphasis-color',
                    'text-emphasis-position',
                    'text-emphasis-style',
                    'text-indent',
                    'text-justify',
                    'text-orientation',
                    'text-overflow',
                    'text-rendering',
                    'text-shadow',
                    'text-transform',
                    'text-underline-position',
                    'top',
                    'transform',
                    'transform-box',
                    'transform-origin',
                    'transform-style',
                    'transition',
                    'transition-delay',
                    'transition-duration',
                    'transition-property',
                    'transition-timing-function',
                    'unicode-bidi',
                    'vertical-align',
                    'visibility',
                    'voice-balance',
                    'voice-duration',
                    'voice-family',
                    'voice-pitch',
                    'voice-range',
                    'voice-rate',
                    'voice-stress',
                    'voice-volume',
                    'white-space',
                    'widows',
                    'width',
                    'will-change',
                    'word-break',
                    'word-spacing',
                    'word-wrap',
                    'writing-mode',
                    'z-index',
                    // reverse makes sure longer attributes `font-weight` are matched fully
                    // instead of getting false positives on say `font`
                ].reverse();
                const PSEUDO_SELECTORS = PSEUDO_CLASSES.concat(PSEUDO_ELEMENTS);
                function less(hljs2) {
                    const modes = MODES2(hljs2);
                    const PSEUDO_SELECTORS$1 = PSEUDO_SELECTORS;
                    const AT_MODIFIERS = 'and or not only';
                    const IDENT_RE2 = '[\\w-]+';
                    const INTERP_IDENT_RE =
                        '(' + IDENT_RE2 + '|@\\{' + IDENT_RE2 + '\\})';
                    const RULES = [];
                    const VALUE_MODES = [];
                    const STRING_MODE = function (c) {
                        return {
                            // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
                            className: 'string',
                            begin: '~?' + c + '.*?' + c,
                        };
                    };
                    const IDENT_MODE = function (name, begin, relevance) {
                        return {
                            className: name,
                            begin,
                            relevance,
                        };
                    };
                    const AT_KEYWORDS = {
                        $pattern: /[a-z-]+/,
                        keyword: AT_MODIFIERS,
                        attribute: MEDIA_FEATURES.join(' '),
                    };
                    const PARENS_MODE = {
                        // used only to properly balance nested parens inside mixin call, def. arg list
                        begin: '\\(',
                        end: '\\)',
                        contains: VALUE_MODES,
                        keywords: AT_KEYWORDS,
                        relevance: 0,
                    };
                    VALUE_MODES.push(
                        hljs2.C_LINE_COMMENT_MODE,
                        hljs2.C_BLOCK_COMMENT_MODE,
                        STRING_MODE("'"),
                        STRING_MODE('"'),
                        modes.CSS_NUMBER_MODE,
                        // fixme: it does not include dot for numbers like .5em :(
                        {
                            begin: '(url|data-uri)\\(',
                            starts: {
                                className: 'string',
                                end: '[\\)\\n]',
                                excludeEnd: true,
                            },
                        },
                        modes.HEXCOLOR,
                        PARENS_MODE,
                        IDENT_MODE('variable', '@@?' + IDENT_RE2, 10),
                        IDENT_MODE('variable', '@\\{' + IDENT_RE2 + '\\}'),
                        IDENT_MODE('built_in', '~?`[^`]*?`'),
                        // inline javascript (or whatever host language) *multiline* string
                        {
                            // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
                            className: 'attribute',
                            begin: IDENT_RE2 + '\\s*:',
                            end: ':',
                            returnBegin: true,
                            excludeEnd: true,
                        },
                        modes.IMPORTANT,
                        { beginKeywords: 'and not' },
                        modes.FUNCTION_DISPATCH
                    );
                    const VALUE_WITH_RULESETS = VALUE_MODES.concat({
                        begin: /\{/,
                        end: /\}/,
                        contains: RULES,
                    });
                    const MIXIN_GUARD_MODE = {
                        beginKeywords: 'when',
                        endsWithParent: true,
                        contains: [{ beginKeywords: 'and not' }].concat(
                            VALUE_MODES
                        ),
                        // using this form to override VALUE’s 'function' match
                    };
                    const RULE_MODE = {
                        begin: INTERP_IDENT_RE + '\\s*:',
                        returnBegin: true,
                        end: /[;}]/,
                        relevance: 0,
                        contains: [
                            { begin: /-(webkit|moz|ms|o)-/ },
                            modes.CSS_VARIABLE,
                            {
                                className: 'attribute',
                                begin: '\\b(' + ATTRIBUTES.join('|') + ')\\b',
                                end: /(?=:)/,
                                starts: {
                                    endsWithParent: true,
                                    illegal: '[<=$]',
                                    relevance: 0,
                                    contains: VALUE_MODES,
                                },
                            },
                        ],
                    };
                    const AT_RULE_MODE = {
                        className: 'keyword',
                        begin: '@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b',
                        starts: {
                            end: '[;{}]',
                            keywords: AT_KEYWORDS,
                            returnEnd: true,
                            contains: VALUE_MODES,
                            relevance: 0,
                        },
                    };
                    const VAR_RULE_MODE = {
                        className: 'variable',
                        variants: [
                            // using more strict pattern for higher relevance to increase chances of Less detection.
                            // this is *the only* Less specific statement used in most of the sources, so...
                            // (we’ll still often loose to the css-parser unless there's '//' comment,
                            // simply because 1 variable just can't beat 99 properties :)
                            {
                                begin: '@' + IDENT_RE2 + '\\s*:',
                                relevance: 15,
                            },
                            { begin: '@' + IDENT_RE2 },
                        ],
                        starts: {
                            end: '[;}]',
                            returnEnd: true,
                            contains: VALUE_WITH_RULESETS,
                        },
                    };
                    const SELECTOR_MODE = {
                        // first parse unambiguous selectors (i.e. those not starting with tag)
                        // then fall into the scary lookahead-discriminator variant.
                        // this mode also handles mixin definitions and calls
                        variants: [
                            {
                                begin: '[\\.#:&\\[>]',
                                end: '[;{}]',
                                // mixin calls end with ';'
                            },
                            {
                                begin: INTERP_IDENT_RE,
                                end: /\{/,
                            },
                        ],
                        returnBegin: true,
                        returnEnd: true,
                        illegal: `[<='$"]`,
                        relevance: 0,
                        contains: [
                            hljs2.C_LINE_COMMENT_MODE,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            MIXIN_GUARD_MODE,
                            IDENT_MODE('keyword', 'all\\b'),
                            IDENT_MODE('variable', '@\\{' + IDENT_RE2 + '\\}'),
                            // otherwise it’s identified as tag
                            {
                                begin: '\\b(' + TAGS.join('|') + ')\\b',
                                className: 'selector-tag',
                            },
                            modes.CSS_NUMBER_MODE,
                            IDENT_MODE('selector-tag', INTERP_IDENT_RE, 0),
                            IDENT_MODE('selector-id', '#' + INTERP_IDENT_RE),
                            IDENT_MODE(
                                'selector-class',
                                '\\.' + INTERP_IDENT_RE,
                                0
                            ),
                            IDENT_MODE('selector-tag', '&', 0),
                            modes.ATTRIBUTE_SELECTOR_MODE,
                            {
                                className: 'selector-pseudo',
                                begin: ':(' + PSEUDO_CLASSES.join('|') + ')',
                            },
                            {
                                className: 'selector-pseudo',
                                begin:
                                    ':(:)?(' + PSEUDO_ELEMENTS.join('|') + ')',
                            },
                            {
                                begin: /\(/,
                                end: /\)/,
                                relevance: 0,
                                contains: VALUE_WITH_RULESETS,
                            },
                            // argument list of parametric mixins
                            { begin: '!important' },
                            // eat !important after mixin call or it will be colored as tag
                            modes.FUNCTION_DISPATCH,
                        ],
                    };
                    const PSEUDO_SELECTOR_MODE = {
                        begin:
                            IDENT_RE2 +
                            `:(:)?(${PSEUDO_SELECTORS$1.join('|')})`,
                        returnBegin: true,
                        contains: [SELECTOR_MODE],
                    };
                    RULES.push(
                        hljs2.C_LINE_COMMENT_MODE,
                        hljs2.C_BLOCK_COMMENT_MODE,
                        AT_RULE_MODE,
                        VAR_RULE_MODE,
                        PSEUDO_SELECTOR_MODE,
                        RULE_MODE,
                        SELECTOR_MODE,
                        MIXIN_GUARD_MODE,
                        modes.FUNCTION_DISPATCH
                    );
                    return {
                        name: 'Less',
                        case_insensitive: true,
                        illegal: `[=>'/<($"]`,
                        contains: RULES,
                    };
                }
                less_1 = less;
                return less_1;
            }
            var lua_1;
            var hasRequiredLua;
            function requireLua() {
                if (hasRequiredLua) return lua_1;
                hasRequiredLua = 1;
                function lua(hljs2) {
                    const OPENING_LONG_BRACKET = '\\[=*\\[';
                    const CLOSING_LONG_BRACKET = '\\]=*\\]';
                    const LONG_BRACKETS = {
                        begin: OPENING_LONG_BRACKET,
                        end: CLOSING_LONG_BRACKET,
                        contains: ['self'],
                    };
                    const COMMENTS = [
                        hljs2.COMMENT(
                            '--(?!' + OPENING_LONG_BRACKET + ')',
                            '$'
                        ),
                        hljs2.COMMENT(
                            '--' + OPENING_LONG_BRACKET,
                            CLOSING_LONG_BRACKET,
                            {
                                contains: [LONG_BRACKETS],
                                relevance: 10,
                            }
                        ),
                    ];
                    return {
                        name: 'Lua',
                        keywords: {
                            $pattern: hljs2.UNDERSCORE_IDENT_RE,
                            literal: 'true false nil',
                            keyword:
                                'and break do else elseif end for goto if in local not or repeat return then until while',
                            built_in:
                                // Metatags and globals:
                                '_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove',
                        },
                        contains: COMMENTS.concat([
                            {
                                className: 'function',
                                beginKeywords: 'function',
                                end: '\\)',
                                contains: [
                                    hljs2.inherit(hljs2.TITLE_MODE, {
                                        begin: '([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*',
                                    }),
                                    {
                                        className: 'params',
                                        begin: '\\(',
                                        endsWithParent: true,
                                        contains: COMMENTS,
                                    },
                                ].concat(COMMENTS),
                            },
                            hljs2.C_NUMBER_MODE,
                            hljs2.APOS_STRING_MODE,
                            hljs2.QUOTE_STRING_MODE,
                            {
                                className: 'string',
                                begin: OPENING_LONG_BRACKET,
                                end: CLOSING_LONG_BRACKET,
                                contains: [LONG_BRACKETS],
                                relevance: 5,
                            },
                        ]),
                    };
                }
                lua_1 = lua;
                return lua_1;
            }
            var makefile_1;
            var hasRequiredMakefile;
            function requireMakefile() {
                if (hasRequiredMakefile) return makefile_1;
                hasRequiredMakefile = 1;
                function makefile(hljs2) {
                    const VARIABLE = {
                        className: 'variable',
                        variants: [
                            {
                                begin:
                                    '\\$\\(' +
                                    hljs2.UNDERSCORE_IDENT_RE +
                                    '\\)',
                                contains: [hljs2.BACKSLASH_ESCAPE],
                            },
                            { begin: /\$[@%<?\^\+\*]/ },
                        ],
                    };
                    const QUOTE_STRING = {
                        className: 'string',
                        begin: /"/,
                        end: /"/,
                        contains: [hljs2.BACKSLASH_ESCAPE, VARIABLE],
                    };
                    const FUNC = {
                        className: 'variable',
                        begin: /\$\([\w-]+\s/,
                        end: /\)/,
                        keywords: {
                            built_in:
                                'subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value',
                        },
                        contains: [VARIABLE],
                    };
                    const ASSIGNMENT = {
                        begin:
                            '^' + hljs2.UNDERSCORE_IDENT_RE + '\\s*(?=[:+?]?=)',
                    };
                    const META = {
                        className: 'meta',
                        begin: /^\.PHONY:/,
                        end: /$/,
                        keywords: {
                            $pattern: /[\.\w]+/,
                            keyword: '.PHONY',
                        },
                    };
                    const TARGET = {
                        className: 'section',
                        begin: /^[^\s]+:/,
                        end: /$/,
                        contains: [VARIABLE],
                    };
                    return {
                        name: 'Makefile',
                        aliases: ['mk', 'mak', 'make'],
                        keywords: {
                            $pattern: /[\w-]+/,
                            keyword:
                                'define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath',
                        },
                        contains: [
                            hljs2.HASH_COMMENT_MODE,
                            VARIABLE,
                            QUOTE_STRING,
                            FUNC,
                            ASSIGNMENT,
                            META,
                            TARGET,
                        ],
                    };
                }
                makefile_1 = makefile;
                return makefile_1;
            }
            var perl_1;
            var hasRequiredPerl;
            function requirePerl() {
                if (hasRequiredPerl) return perl_1;
                hasRequiredPerl = 1;
                function perl(hljs2) {
                    const regex = hljs2.regex;
                    const KEYWORDS = [
                        'abs',
                        'accept',
                        'alarm',
                        'and',
                        'atan2',
                        'bind',
                        'binmode',
                        'bless',
                        'break',
                        'caller',
                        'chdir',
                        'chmod',
                        'chomp',
                        'chop',
                        'chown',
                        'chr',
                        'chroot',
                        'close',
                        'closedir',
                        'connect',
                        'continue',
                        'cos',
                        'crypt',
                        'dbmclose',
                        'dbmopen',
                        'defined',
                        'delete',
                        'die',
                        'do',
                        'dump',
                        'each',
                        'else',
                        'elsif',
                        'endgrent',
                        'endhostent',
                        'endnetent',
                        'endprotoent',
                        'endpwent',
                        'endservent',
                        'eof',
                        'eval',
                        'exec',
                        'exists',
                        'exit',
                        'exp',
                        'fcntl',
                        'fileno',
                        'flock',
                        'for',
                        'foreach',
                        'fork',
                        'format',
                        'formline',
                        'getc',
                        'getgrent',
                        'getgrgid',
                        'getgrnam',
                        'gethostbyaddr',
                        'gethostbyname',
                        'gethostent',
                        'getlogin',
                        'getnetbyaddr',
                        'getnetbyname',
                        'getnetent',
                        'getpeername',
                        'getpgrp',
                        'getpriority',
                        'getprotobyname',
                        'getprotobynumber',
                        'getprotoent',
                        'getpwent',
                        'getpwnam',
                        'getpwuid',
                        'getservbyname',
                        'getservbyport',
                        'getservent',
                        'getsockname',
                        'getsockopt',
                        'given',
                        'glob',
                        'gmtime',
                        'goto',
                        'grep',
                        'gt',
                        'hex',
                        'if',
                        'index',
                        'int',
                        'ioctl',
                        'join',
                        'keys',
                        'kill',
                        'last',
                        'lc',
                        'lcfirst',
                        'length',
                        'link',
                        'listen',
                        'local',
                        'localtime',
                        'log',
                        'lstat',
                        'lt',
                        'ma',
                        'map',
                        'mkdir',
                        'msgctl',
                        'msgget',
                        'msgrcv',
                        'msgsnd',
                        'my',
                        'ne',
                        'next',
                        'no',
                        'not',
                        'oct',
                        'open',
                        'opendir',
                        'or',
                        'ord',
                        'our',
                        'pack',
                        'package',
                        'pipe',
                        'pop',
                        'pos',
                        'print',
                        'printf',
                        'prototype',
                        'push',
                        'q|0',
                        'qq',
                        'quotemeta',
                        'qw',
                        'qx',
                        'rand',
                        'read',
                        'readdir',
                        'readline',
                        'readlink',
                        'readpipe',
                        'recv',
                        'redo',
                        'ref',
                        'rename',
                        'require',
                        'reset',
                        'return',
                        'reverse',
                        'rewinddir',
                        'rindex',
                        'rmdir',
                        'say',
                        'scalar',
                        'seek',
                        'seekdir',
                        'select',
                        'semctl',
                        'semget',
                        'semop',
                        'send',
                        'setgrent',
                        'sethostent',
                        'setnetent',
                        'setpgrp',
                        'setpriority',
                        'setprotoent',
                        'setpwent',
                        'setservent',
                        'setsockopt',
                        'shift',
                        'shmctl',
                        'shmget',
                        'shmread',
                        'shmwrite',
                        'shutdown',
                        'sin',
                        'sleep',
                        'socket',
                        'socketpair',
                        'sort',
                        'splice',
                        'split',
                        'sprintf',
                        'sqrt',
                        'srand',
                        'stat',
                        'state',
                        'study',
                        'sub',
                        'substr',
                        'symlink',
                        'syscall',
                        'sysopen',
                        'sysread',
                        'sysseek',
                        'system',
                        'syswrite',
                        'tell',
                        'telldir',
                        'tie',
                        'tied',
                        'time',
                        'times',
                        'tr',
                        'truncate',
                        'uc',
                        'ucfirst',
                        'umask',
                        'undef',
                        'unless',
                        'unlink',
                        'unpack',
                        'unshift',
                        'untie',
                        'until',
                        'use',
                        'utime',
                        'values',
                        'vec',
                        'wait',
                        'waitpid',
                        'wantarray',
                        'warn',
                        'when',
                        'while',
                        'write',
                        'x|0',
                        'xor',
                        'y|0',
                    ];
                    const REGEX_MODIFIERS = /[dualxmsipngr]{0,12}/;
                    const PERL_KEYWORDS = {
                        $pattern: /[\w.]+/,
                        keyword: KEYWORDS.join(' '),
                    };
                    const SUBST = {
                        className: 'subst',
                        begin: '[$@]\\{',
                        end: '\\}',
                        keywords: PERL_KEYWORDS,
                    };
                    const METHOD = {
                        begin: /->\{/,
                        end: /\}/,
                        // contains defined later
                    };
                    const VAR = {
                        variants: [
                            { begin: /\$\d/ },
                            {
                                begin: regex.concat(
                                    /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
                                    // negative look-ahead tries to avoid matching patterns that are not
                                    // Perl at all like $ident$, @ident@, etc.
                                    `(?![A-Za-z])(?![@$%])`
                                ),
                            },
                            {
                                begin: /[$%@][^\s\w{]/,
                                relevance: 0,
                            },
                        ],
                    };
                    const STRING_CONTAINS = [
                        hljs2.BACKSLASH_ESCAPE,
                        SUBST,
                        VAR,
                    ];
                    const REGEX_DELIMS = [
                        /!/,
                        /\//,
                        /\|/,
                        /\?/,
                        /'/,
                        /"/,
                        // valid but infrequent and weird
                        /#/,
                        // valid but infrequent and weird
                    ];
                    const PAIRED_DOUBLE_RE = (prefix, open, close = '\\1') => {
                        const middle =
                            close === '\\1' ? close : regex.concat(close, open);
                        return regex.concat(
                            regex.concat('(?:', prefix, ')'),
                            open,
                            /(?:\\.|[^\\\/])*?/,
                            middle,
                            /(?:\\.|[^\\\/])*?/,
                            close,
                            REGEX_MODIFIERS
                        );
                    };
                    const PAIRED_RE = (prefix, open, close) => {
                        return regex.concat(
                            regex.concat('(?:', prefix, ')'),
                            open,
                            /(?:\\.|[^\\\/])*?/,
                            close,
                            REGEX_MODIFIERS
                        );
                    };
                    const PERL_DEFAULT_CONTAINS = [
                        VAR,
                        hljs2.HASH_COMMENT_MODE,
                        hljs2.COMMENT(/^=\w/, /=cut/, { endsWithParent: true }),
                        METHOD,
                        {
                            className: 'string',
                            contains: STRING_CONTAINS,
                            variants: [
                                {
                                    begin: 'q[qwxr]?\\s*\\(',
                                    end: '\\)',
                                    relevance: 5,
                                },
                                {
                                    begin: 'q[qwxr]?\\s*\\[',
                                    end: '\\]',
                                    relevance: 5,
                                },
                                {
                                    begin: 'q[qwxr]?\\s*\\{',
                                    end: '\\}',
                                    relevance: 5,
                                },
                                {
                                    begin: 'q[qwxr]?\\s*\\|',
                                    end: '\\|',
                                    relevance: 5,
                                },
                                {
                                    begin: 'q[qwxr]?\\s*<',
                                    end: '>',
                                    relevance: 5,
                                },
                                {
                                    begin: 'qw\\s+q',
                                    end: 'q',
                                    relevance: 5,
                                },
                                {
                                    begin: "'",
                                    end: "'",
                                    contains: [hljs2.BACKSLASH_ESCAPE],
                                },
                                {
                                    begin: '"',
                                    end: '"',
                                },
                                {
                                    begin: '`',
                                    end: '`',
                                    contains: [hljs2.BACKSLASH_ESCAPE],
                                },
                                {
                                    begin: /\{\w+\}/,
                                    relevance: 0,
                                },
                                {
                                    begin: '-?\\w+\\s*=>',
                                    relevance: 0,
                                },
                            ],
                        },
                        {
                            className: 'number',
                            begin: '(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b',
                            relevance: 0,
                        },
                        {
                            // regexp container
                            begin:
                                '(\\/\\/|' +
                                hljs2.RE_STARTERS_RE +
                                '|\\b(split|return|print|reverse|grep)\\b)\\s*',
                            keywords: 'split return print reverse grep',
                            relevance: 0,
                            contains: [
                                hljs2.HASH_COMMENT_MODE,
                                {
                                    className: 'regexp',
                                    variants: [
                                        // allow matching common delimiters
                                        {
                                            begin: PAIRED_DOUBLE_RE(
                                                's|tr|y',
                                                regex.either(...REGEX_DELIMS, {
                                                    capture: true,
                                                })
                                            ),
                                        },
                                        // and then paired delmis
                                        {
                                            begin: PAIRED_DOUBLE_RE(
                                                's|tr|y',
                                                '\\(',
                                                '\\)'
                                            ),
                                        },
                                        {
                                            begin: PAIRED_DOUBLE_RE(
                                                's|tr|y',
                                                '\\[',
                                                '\\]'
                                            ),
                                        },
                                        {
                                            begin: PAIRED_DOUBLE_RE(
                                                's|tr|y',
                                                '\\{',
                                                '\\}'
                                            ),
                                        },
                                    ],
                                    relevance: 2,
                                },
                                {
                                    className: 'regexp',
                                    variants: [
                                        {
                                            // could be a comment in many languages so do not count
                                            // as relevant
                                            begin: /(m|qr)\/\//,
                                            relevance: 0,
                                        },
                                        // prefix is optional with /regex/
                                        {
                                            begin: PAIRED_RE(
                                                '(?:m|qr)?',
                                                /\//,
                                                /\//
                                            ),
                                        },
                                        // allow matching common delimiters
                                        {
                                            begin: PAIRED_RE(
                                                'm|qr',
                                                regex.either(...REGEX_DELIMS, {
                                                    capture: true,
                                                }),
                                                /\1/
                                            ),
                                        },
                                        // allow common paired delmins
                                        {
                                            begin: PAIRED_RE(
                                                'm|qr',
                                                /\(/,
                                                /\)/
                                            ),
                                        },
                                        {
                                            begin: PAIRED_RE(
                                                'm|qr',
                                                /\[/,
                                                /\]/
                                            ),
                                        },
                                        {
                                            begin: PAIRED_RE(
                                                'm|qr',
                                                /\{/,
                                                /\}/
                                            ),
                                        },
                                    ],
                                },
                            ],
                        },
                        {
                            className: 'function',
                            beginKeywords: 'sub',
                            end: '(\\s*\\(.*?\\))?[;{]',
                            excludeEnd: true,
                            relevance: 5,
                            contains: [hljs2.TITLE_MODE],
                        },
                        {
                            begin: '-\\w\\b',
                            relevance: 0,
                        },
                        {
                            begin: '^__DATA__$',
                            end: '^__END__$',
                            subLanguage: 'mojolicious',
                            contains: [
                                {
                                    begin: '^@@.*',
                                    end: '$',
                                    className: 'comment',
                                },
                            ],
                        },
                    ];
                    SUBST.contains = PERL_DEFAULT_CONTAINS;
                    METHOD.contains = PERL_DEFAULT_CONTAINS;
                    return {
                        name: 'Perl',
                        aliases: ['pl', 'pm'],
                        keywords: PERL_KEYWORDS,
                        contains: PERL_DEFAULT_CONTAINS,
                    };
                }
                perl_1 = perl;
                return perl_1;
            }
            var objectivec_1;
            var hasRequiredObjectivec;
            function requireObjectivec() {
                if (hasRequiredObjectivec) return objectivec_1;
                hasRequiredObjectivec = 1;
                function objectivec(hljs2) {
                    const API_CLASS = {
                        className: 'built_in',
                        begin: '\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+',
                    };
                    const IDENTIFIER_RE = /[a-zA-Z@][a-zA-Z0-9_]*/;
                    const TYPES = [
                        'int',
                        'float',
                        'char',
                        'unsigned',
                        'signed',
                        'short',
                        'long',
                        'double',
                        'wchar_t',
                        'unichar',
                        'void',
                        'bool',
                        'BOOL',
                        'id|0',
                        '_Bool',
                    ];
                    const KWS = [
                        'while',
                        'export',
                        'sizeof',
                        'typedef',
                        'const',
                        'struct',
                        'for',
                        'union',
                        'volatile',
                        'static',
                        'mutable',
                        'if',
                        'do',
                        'return',
                        'goto',
                        'enum',
                        'else',
                        'break',
                        'extern',
                        'asm',
                        'case',
                        'default',
                        'register',
                        'explicit',
                        'typename',
                        'switch',
                        'continue',
                        'inline',
                        'readonly',
                        'assign',
                        'readwrite',
                        'self',
                        '@synchronized',
                        'id',
                        'typeof',
                        'nonatomic',
                        'IBOutlet',
                        'IBAction',
                        'strong',
                        'weak',
                        'copy',
                        'in',
                        'out',
                        'inout',
                        'bycopy',
                        'byref',
                        'oneway',
                        '__strong',
                        '__weak',
                        '__block',
                        '__autoreleasing',
                        '@private',
                        '@protected',
                        '@public',
                        '@try',
                        '@property',
                        '@end',
                        '@throw',
                        '@catch',
                        '@finally',
                        '@autoreleasepool',
                        '@synthesize',
                        '@dynamic',
                        '@selector',
                        '@optional',
                        '@required',
                        '@encode',
                        '@package',
                        '@import',
                        '@defs',
                        '@compatibility_alias',
                        '__bridge',
                        '__bridge_transfer',
                        '__bridge_retained',
                        '__bridge_retain',
                        '__covariant',
                        '__contravariant',
                        '__kindof',
                        '_Nonnull',
                        '_Nullable',
                        '_Null_unspecified',
                        '__FUNCTION__',
                        '__PRETTY_FUNCTION__',
                        '__attribute__',
                        'getter',
                        'setter',
                        'retain',
                        'unsafe_unretained',
                        'nonnull',
                        'nullable',
                        'null_unspecified',
                        'null_resettable',
                        'class',
                        'instancetype',
                        'NS_DESIGNATED_INITIALIZER',
                        'NS_UNAVAILABLE',
                        'NS_REQUIRES_SUPER',
                        'NS_RETURNS_INNER_POINTER',
                        'NS_INLINE',
                        'NS_AVAILABLE',
                        'NS_DEPRECATED',
                        'NS_ENUM',
                        'NS_OPTIONS',
                        'NS_SWIFT_UNAVAILABLE',
                        'NS_ASSUME_NONNULL_BEGIN',
                        'NS_ASSUME_NONNULL_END',
                        'NS_REFINED_FOR_SWIFT',
                        'NS_SWIFT_NAME',
                        'NS_SWIFT_NOTHROW',
                        'NS_DURING',
                        'NS_HANDLER',
                        'NS_ENDHANDLER',
                        'NS_VALUERETURN',
                        'NS_VOIDRETURN',
                    ];
                    const LITERALS = [
                        'false',
                        'true',
                        'FALSE',
                        'TRUE',
                        'nil',
                        'YES',
                        'NO',
                        'NULL',
                    ];
                    const BUILT_INS = [
                        'dispatch_once_t',
                        'dispatch_queue_t',
                        'dispatch_sync',
                        'dispatch_async',
                        'dispatch_once',
                    ];
                    const KEYWORDS = {
                        'variable.language': ['this', 'super'],
                        $pattern: IDENTIFIER_RE,
                        keyword: KWS,
                        literal: LITERALS,
                        built_in: BUILT_INS,
                        type: TYPES,
                    };
                    const CLASS_KEYWORDS = {
                        $pattern: IDENTIFIER_RE,
                        keyword: [
                            '@interface',
                            '@class',
                            '@protocol',
                            '@implementation',
                        ],
                    };
                    return {
                        name: 'Objective-C',
                        aliases: [
                            'mm',
                            'objc',
                            'obj-c',
                            'obj-c++',
                            'objective-c++',
                        ],
                        keywords: KEYWORDS,
                        illegal: '</',
                        contains: [
                            API_CLASS,
                            hljs2.C_LINE_COMMENT_MODE,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            hljs2.C_NUMBER_MODE,
                            hljs2.QUOTE_STRING_MODE,
                            hljs2.APOS_STRING_MODE,
                            {
                                className: 'string',
                                variants: [
                                    {
                                        begin: '@"',
                                        end: '"',
                                        illegal: '\\n',
                                        contains: [hljs2.BACKSLASH_ESCAPE],
                                    },
                                ],
                            },
                            {
                                className: 'meta',
                                begin: /#\s*[a-z]+\b/,
                                end: /$/,
                                keywords: {
                                    keyword:
                                        'if else elif endif define undef warning error line pragma ifdef ifndef include',
                                },
                                contains: [
                                    {
                                        begin: /\\\n/,
                                        relevance: 0,
                                    },
                                    hljs2.inherit(hljs2.QUOTE_STRING_MODE, {
                                        className: 'string',
                                    }),
                                    {
                                        className: 'string',
                                        begin: /<.*?>/,
                                        end: /$/,
                                        illegal: '\\n',
                                    },
                                    hljs2.C_LINE_COMMENT_MODE,
                                    hljs2.C_BLOCK_COMMENT_MODE,
                                ],
                            },
                            {
                                className: 'class',
                                begin:
                                    '(' +
                                    CLASS_KEYWORDS.keyword.join('|') +
                                    ')\\b',
                                end: /(\{|$)/,
                                excludeEnd: true,
                                keywords: CLASS_KEYWORDS,
                                contains: [hljs2.UNDERSCORE_TITLE_MODE],
                            },
                            {
                                begin: '\\.' + hljs2.UNDERSCORE_IDENT_RE,
                                relevance: 0,
                            },
                        ],
                    };
                }
                objectivec_1 = objectivec;
                return objectivec_1;
            }
            var php_1;
            var hasRequiredPhp;
            function requirePhp() {
                if (hasRequiredPhp) return php_1;
                hasRequiredPhp = 1;
                function php(hljs2) {
                    const regex = hljs2.regex;
                    const NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/;
                    const IDENT_RE2 = regex.concat(
                        /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
                        NOT_PERL_ETC
                    );
                    const PASCAL_CASE_CLASS_NAME_RE = regex.concat(
                        /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
                        NOT_PERL_ETC
                    );
                    const VARIABLE = {
                        scope: 'variable',
                        match: '\\$+' + IDENT_RE2,
                    };
                    const PREPROCESSOR = {
                        scope: 'meta',
                        variants: [
                            { begin: /<\?php/, relevance: 10 },
                            // boost for obvious PHP
                            { begin: /<\?=/ },
                            // less relevant per PSR-1 which says not to use short-tags
                            { begin: /<\?/, relevance: 0.1 },
                            { begin: /\?>/ },
                            // end php tag
                        ],
                    };
                    const SUBST = {
                        scope: 'subst',
                        variants: [
                            { begin: /\$\w+/ },
                            {
                                begin: /\{\$/,
                                end: /\}/,
                            },
                        ],
                    };
                    const SINGLE_QUOTED = hljs2.inherit(
                        hljs2.APOS_STRING_MODE,
                        { illegal: null }
                    );
                    const DOUBLE_QUOTED = hljs2.inherit(
                        hljs2.QUOTE_STRING_MODE,
                        {
                            illegal: null,
                            contains:
                                hljs2.QUOTE_STRING_MODE.contains.concat(SUBST),
                        }
                    );
                    const HEREDOC = {
                        begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
                        end: /[ \t]*(\w+)\b/,
                        contains:
                            hljs2.QUOTE_STRING_MODE.contains.concat(SUBST),
                        'on:begin': (m, resp) => {
                            resp.data._beginMatch = m[1] || m[2];
                        },
                        'on:end': (m, resp) => {
                            if (resp.data._beginMatch !== m[1])
                                resp.ignoreMatch();
                        },
                    };
                    const NOWDOC = hljs2.END_SAME_AS_BEGIN({
                        begin: /<<<[ \t]*'(\w+)'\n/,
                        end: /[ \t]*(\w+)\b/,
                    });
                    const WHITESPACE = '[ 	\n]';
                    const STRING = {
                        scope: 'string',
                        variants: [
                            DOUBLE_QUOTED,
                            SINGLE_QUOTED,
                            HEREDOC,
                            NOWDOC,
                        ],
                    };
                    const NUMBER = {
                        scope: 'number',
                        variants: [
                            { begin: `\\b0[bB][01]+(?:_[01]+)*\\b` },
                            // Binary w/ underscore support
                            { begin: `\\b0[oO][0-7]+(?:_[0-7]+)*\\b` },
                            // Octals w/ underscore support
                            {
                                begin: `\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b`,
                            },
                            // Hex w/ underscore support
                            // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
                            {
                                begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?`,
                            },
                        ],
                        relevance: 0,
                    };
                    const LITERALS = ['false', 'null', 'true'];
                    const KWS = [
                        // Magic constants:
                        // <https://www.php.net/manual/en/language.constants.predefined.php>
                        '__CLASS__',
                        '__DIR__',
                        '__FILE__',
                        '__FUNCTION__',
                        '__COMPILER_HALT_OFFSET__',
                        '__LINE__',
                        '__METHOD__',
                        '__NAMESPACE__',
                        '__TRAIT__',
                        // Function that look like language construct or language construct that look like function:
                        // List of keywords that may not require parenthesis
                        'die',
                        'echo',
                        'exit',
                        'include',
                        'include_once',
                        'print',
                        'require',
                        'require_once',
                        // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
                        // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
                        // Other keywords:
                        // <https://www.php.net/manual/en/reserved.php>
                        // <https://www.php.net/manual/en/language.types.type-juggling.php>
                        'array',
                        'abstract',
                        'and',
                        'as',
                        'binary',
                        'bool',
                        'boolean',
                        'break',
                        'callable',
                        'case',
                        'catch',
                        'class',
                        'clone',
                        'const',
                        'continue',
                        'declare',
                        'default',
                        'do',
                        'double',
                        'else',
                        'elseif',
                        'empty',
                        'enddeclare',
                        'endfor',
                        'endforeach',
                        'endif',
                        'endswitch',
                        'endwhile',
                        'enum',
                        'eval',
                        'extends',
                        'final',
                        'finally',
                        'float',
                        'for',
                        'foreach',
                        'from',
                        'global',
                        'goto',
                        'if',
                        'implements',
                        'instanceof',
                        'insteadof',
                        'int',
                        'integer',
                        'interface',
                        'isset',
                        'iterable',
                        'list',
                        'match|0',
                        'mixed',
                        'new',
                        'never',
                        'object',
                        'or',
                        'private',
                        'protected',
                        'public',
                        'readonly',
                        'real',
                        'return',
                        'string',
                        'switch',
                        'throw',
                        'trait',
                        'try',
                        'unset',
                        'use',
                        'var',
                        'void',
                        'while',
                        'xor',
                        'yield',
                    ];
                    const BUILT_INS = [
                        // Standard PHP library:
                        // <https://www.php.net/manual/en/book.spl.php>
                        'Error|0',
                        'AppendIterator',
                        'ArgumentCountError',
                        'ArithmeticError',
                        'ArrayIterator',
                        'ArrayObject',
                        'AssertionError',
                        'BadFunctionCallException',
                        'BadMethodCallException',
                        'CachingIterator',
                        'CallbackFilterIterator',
                        'CompileError',
                        'Countable',
                        'DirectoryIterator',
                        'DivisionByZeroError',
                        'DomainException',
                        'EmptyIterator',
                        'ErrorException',
                        'Exception',
                        'FilesystemIterator',
                        'FilterIterator',
                        'GlobIterator',
                        'InfiniteIterator',
                        'InvalidArgumentException',
                        'IteratorIterator',
                        'LengthException',
                        'LimitIterator',
                        'LogicException',
                        'MultipleIterator',
                        'NoRewindIterator',
                        'OutOfBoundsException',
                        'OutOfRangeException',
                        'OuterIterator',
                        'OverflowException',
                        'ParentIterator',
                        'ParseError',
                        'RangeException',
                        'RecursiveArrayIterator',
                        'RecursiveCachingIterator',
                        'RecursiveCallbackFilterIterator',
                        'RecursiveDirectoryIterator',
                        'RecursiveFilterIterator',
                        'RecursiveIterator',
                        'RecursiveIteratorIterator',
                        'RecursiveRegexIterator',
                        'RecursiveTreeIterator',
                        'RegexIterator',
                        'RuntimeException',
                        'SeekableIterator',
                        'SplDoublyLinkedList',
                        'SplFileInfo',
                        'SplFileObject',
                        'SplFixedArray',
                        'SplHeap',
                        'SplMaxHeap',
                        'SplMinHeap',
                        'SplObjectStorage',
                        'SplObserver',
                        'SplPriorityQueue',
                        'SplQueue',
                        'SplStack',
                        'SplSubject',
                        'SplTempFileObject',
                        'TypeError',
                        'UnderflowException',
                        'UnexpectedValueException',
                        'UnhandledMatchError',
                        // Reserved interfaces:
                        // <https://www.php.net/manual/en/reserved.interfaces.php>
                        'ArrayAccess',
                        'BackedEnum',
                        'Closure',
                        'Fiber',
                        'Generator',
                        'Iterator',
                        'IteratorAggregate',
                        'Serializable',
                        'Stringable',
                        'Throwable',
                        'Traversable',
                        'UnitEnum',
                        'WeakReference',
                        'WeakMap',
                        // Reserved classes:
                        // <https://www.php.net/manual/en/reserved.classes.php>
                        'Directory',
                        '__PHP_Incomplete_Class',
                        'parent',
                        'php_user_filter',
                        'self',
                        'static',
                        'stdClass',
                    ];
                    const dualCase = (items) => {
                        const result = [];
                        items.forEach((item) => {
                            result.push(item);
                            if (item.toLowerCase() === item) {
                                result.push(item.toUpperCase());
                            } else {
                                result.push(item.toLowerCase());
                            }
                        });
                        return result;
                    };
                    const KEYWORDS = {
                        keyword: KWS,
                        literal: dualCase(LITERALS),
                        built_in: BUILT_INS,
                    };
                    const normalizeKeywords = (items) => {
                        return items.map((item) => {
                            return item.replace(/\|\d+$/, '');
                        });
                    };
                    const CONSTRUCTOR_CALL = {
                        variants: [
                            {
                                match: [
                                    /new/,
                                    regex.concat(WHITESPACE, '+'),
                                    // to prevent built ins from being confused as the class constructor call
                                    regex.concat(
                                        '(?!',
                                        normalizeKeywords(BUILT_INS).join(
                                            '\\b|'
                                        ),
                                        '\\b)'
                                    ),
                                    PASCAL_CASE_CLASS_NAME_RE,
                                ],
                                scope: {
                                    1: 'keyword',
                                    4: 'title.class',
                                },
                            },
                        ],
                    };
                    const CONSTANT_REFERENCE = regex.concat(
                        IDENT_RE2,
                        '\\b(?!\\()'
                    );
                    const LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = {
                        variants: [
                            {
                                match: [
                                    regex.concat(
                                        /::/,
                                        regex.lookahead(/(?!class\b)/)
                                    ),
                                    CONSTANT_REFERENCE,
                                ],
                                scope: { 2: 'variable.constant' },
                            },
                            {
                                match: [/::/, /class/],
                                scope: { 2: 'variable.language' },
                            },
                            {
                                match: [
                                    PASCAL_CASE_CLASS_NAME_RE,
                                    regex.concat(
                                        /::/,
                                        regex.lookahead(/(?!class\b)/)
                                    ),
                                    CONSTANT_REFERENCE,
                                ],
                                scope: {
                                    1: 'title.class',
                                    3: 'variable.constant',
                                },
                            },
                            {
                                match: [
                                    PASCAL_CASE_CLASS_NAME_RE,
                                    regex.concat(
                                        '::',
                                        regex.lookahead(/(?!class\b)/)
                                    ),
                                ],
                                scope: { 1: 'title.class' },
                            },
                            {
                                match: [
                                    PASCAL_CASE_CLASS_NAME_RE,
                                    /::/,
                                    /class/,
                                ],
                                scope: {
                                    1: 'title.class',
                                    3: 'variable.language',
                                },
                            },
                        ],
                    };
                    const NAMED_ARGUMENT = {
                        scope: 'attr',
                        match: regex.concat(
                            IDENT_RE2,
                            regex.lookahead(':'),
                            regex.lookahead(/(?!::)/)
                        ),
                    };
                    const PARAMS_MODE = {
                        relevance: 0,
                        begin: /\(/,
                        end: /\)/,
                        keywords: KEYWORDS,
                        contains: [
                            NAMED_ARGUMENT,
                            VARIABLE,
                            LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            STRING,
                            NUMBER,
                            CONSTRUCTOR_CALL,
                        ],
                    };
                    const FUNCTION_INVOKE = {
                        relevance: 0,
                        match: [
                            /\b/,
                            // to prevent keywords from being confused as the function title
                            regex.concat(
                                '(?!fn\\b|function\\b|',
                                normalizeKeywords(KWS).join('\\b|'),
                                '|',
                                normalizeKeywords(BUILT_INS).join('\\b|'),
                                '\\b)'
                            ),
                            IDENT_RE2,
                            regex.concat(WHITESPACE, '*'),
                            regex.lookahead(/(?=\()/),
                        ],
                        scope: { 3: 'title.function.invoke' },
                        contains: [PARAMS_MODE],
                    };
                    PARAMS_MODE.contains.push(FUNCTION_INVOKE);
                    const ATTRIBUTE_CONTAINS = [
                        NAMED_ARGUMENT,
                        LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
                        hljs2.C_BLOCK_COMMENT_MODE,
                        STRING,
                        NUMBER,
                        CONSTRUCTOR_CALL,
                    ];
                    const ATTRIBUTES = {
                        begin: regex.concat(
                            /#\[\s*/,
                            PASCAL_CASE_CLASS_NAME_RE
                        ),
                        beginScope: 'meta',
                        end: /]/,
                        endScope: 'meta',
                        keywords: {
                            literal: LITERALS,
                            keyword: ['new', 'array'],
                        },
                        contains: [
                            {
                                begin: /\[/,
                                end: /]/,
                                keywords: {
                                    literal: LITERALS,
                                    keyword: ['new', 'array'],
                                },
                                contains: ['self', ...ATTRIBUTE_CONTAINS],
                            },
                            ...ATTRIBUTE_CONTAINS,
                            {
                                scope: 'meta',
                                match: PASCAL_CASE_CLASS_NAME_RE,
                            },
                        ],
                    };
                    return {
                        case_insensitive: false,
                        keywords: KEYWORDS,
                        contains: [
                            ATTRIBUTES,
                            hljs2.HASH_COMMENT_MODE,
                            hljs2.COMMENT('//', '$'),
                            hljs2.COMMENT('/\\*', '\\*/', {
                                contains: [
                                    {
                                        scope: 'doctag',
                                        match: '@[A-Za-z]+',
                                    },
                                ],
                            }),
                            {
                                match: /__halt_compiler\(\);/,
                                keywords: '__halt_compiler',
                                starts: {
                                    scope: 'comment',
                                    end: hljs2.MATCH_NOTHING_RE,
                                    contains: [
                                        {
                                            match: /\?>/,
                                            scope: 'meta',
                                            endsParent: true,
                                        },
                                    ],
                                },
                            },
                            PREPROCESSOR,
                            {
                                scope: 'variable.language',
                                match: /\$this\b/,
                            },
                            VARIABLE,
                            FUNCTION_INVOKE,
                            LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
                            {
                                match: [/const/, /\s/, IDENT_RE2],
                                scope: {
                                    1: 'keyword',
                                    3: 'variable.constant',
                                },
                            },
                            CONSTRUCTOR_CALL,
                            {
                                scope: 'function',
                                relevance: 0,
                                beginKeywords: 'fn function',
                                end: /[;{]/,
                                excludeEnd: true,
                                illegal: '[$%\\[]',
                                contains: [
                                    { beginKeywords: 'use' },
                                    hljs2.UNDERSCORE_TITLE_MODE,
                                    {
                                        begin: '=>',
                                        // No markup, just a relevance booster
                                        endsParent: true,
                                    },
                                    {
                                        scope: 'params',
                                        begin: '\\(',
                                        end: '\\)',
                                        excludeBegin: true,
                                        excludeEnd: true,
                                        keywords: KEYWORDS,
                                        contains: [
                                            'self',
                                            VARIABLE,
                                            LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,
                                            hljs2.C_BLOCK_COMMENT_MODE,
                                            STRING,
                                            NUMBER,
                                        ],
                                    },
                                ],
                            },
                            {
                                scope: 'class',
                                variants: [
                                    {
                                        beginKeywords: 'enum',
                                        illegal: /[($"]/,
                                    },
                                    {
                                        beginKeywords: 'class interface trait',
                                        illegal: /[:($"]/,
                                    },
                                ],
                                relevance: 0,
                                end: /\{/,
                                excludeEnd: true,
                                contains: [
                                    { beginKeywords: 'extends implements' },
                                    hljs2.UNDERSCORE_TITLE_MODE,
                                ],
                            },
                            // both use and namespace still use "old style" rules (vs multi-match)
                            // because the namespace name can include `\` and we still want each
                            // element to be treated as its own *individual* title
                            {
                                beginKeywords: 'namespace',
                                relevance: 0,
                                end: ';',
                                illegal: /[.']/,
                                contains: [
                                    hljs2.inherit(hljs2.UNDERSCORE_TITLE_MODE, {
                                        scope: 'title.class',
                                    }),
                                ],
                            },
                            {
                                beginKeywords: 'use',
                                relevance: 0,
                                end: ';',
                                contains: [
                                    // TODO: title.function vs title.class
                                    {
                                        match: /\b(as|const|function)\b/,
                                        scope: 'keyword',
                                    },
                                    // TODO: could be title.class or title.function
                                    hljs2.UNDERSCORE_TITLE_MODE,
                                ],
                            },
                            STRING,
                            NUMBER,
                        ],
                    };
                }
                php_1 = php;
                return php_1;
            }
            var phpTemplate_1;
            var hasRequiredPhpTemplate;
            function requirePhpTemplate() {
                if (hasRequiredPhpTemplate) return phpTemplate_1;
                hasRequiredPhpTemplate = 1;
                function phpTemplate(hljs2) {
                    return {
                        name: 'PHP template',
                        subLanguage: 'xml',
                        contains: [
                            {
                                begin: /<\?(php|=)?/,
                                end: /\?>/,
                                subLanguage: 'php',
                                contains: [
                                    // We don't want the php closing tag ?> to close the PHP block when
                                    // inside any of the following blocks:
                                    {
                                        begin: '/\\*',
                                        end: '\\*/',
                                        skip: true,
                                    },
                                    {
                                        begin: 'b"',
                                        end: '"',
                                        skip: true,
                                    },
                                    {
                                        begin: "b'",
                                        end: "'",
                                        skip: true,
                                    },
                                    hljs2.inherit(hljs2.APOS_STRING_MODE, {
                                        illegal: null,
                                        className: null,
                                        contains: null,
                                        skip: true,
                                    }),
                                    hljs2.inherit(hljs2.QUOTE_STRING_MODE, {
                                        illegal: null,
                                        className: null,
                                        contains: null,
                                        skip: true,
                                    }),
                                ],
                            },
                        ],
                    };
                }
                phpTemplate_1 = phpTemplate;
                return phpTemplate_1;
            }
            var plaintext_1;
            var hasRequiredPlaintext;
            function requirePlaintext() {
                if (hasRequiredPlaintext) return plaintext_1;
                hasRequiredPlaintext = 1;
                function plaintext(hljs2) {
                    return {
                        name: 'Plain text',
                        aliases: ['text', 'txt'],
                        disableAutodetect: true,
                    };
                }
                plaintext_1 = plaintext;
                return plaintext_1;
            }
            var python_1;
            var hasRequiredPython;
            function requirePython() {
                if (hasRequiredPython) return python_1;
                hasRequiredPython = 1;
                function python(hljs2) {
                    const regex = hljs2.regex;
                    const IDENT_RE2 = /[\p{XID_Start}_]\p{XID_Continue}*/u;
                    const RESERVED_WORDS = [
                        'and',
                        'as',
                        'assert',
                        'async',
                        'await',
                        'break',
                        'case',
                        'class',
                        'continue',
                        'def',
                        'del',
                        'elif',
                        'else',
                        'except',
                        'finally',
                        'for',
                        'from',
                        'global',
                        'if',
                        'import',
                        'in',
                        'is',
                        'lambda',
                        'match',
                        'nonlocal|10',
                        'not',
                        'or',
                        'pass',
                        'raise',
                        'return',
                        'try',
                        'while',
                        'with',
                        'yield',
                    ];
                    const BUILT_INS = [
                        '__import__',
                        'abs',
                        'all',
                        'any',
                        'ascii',
                        'bin',
                        'bool',
                        'breakpoint',
                        'bytearray',
                        'bytes',
                        'callable',
                        'chr',
                        'classmethod',
                        'compile',
                        'complex',
                        'delattr',
                        'dict',
                        'dir',
                        'divmod',
                        'enumerate',
                        'eval',
                        'exec',
                        'filter',
                        'float',
                        'format',
                        'frozenset',
                        'getattr',
                        'globals',
                        'hasattr',
                        'hash',
                        'help',
                        'hex',
                        'id',
                        'input',
                        'int',
                        'isinstance',
                        'issubclass',
                        'iter',
                        'len',
                        'list',
                        'locals',
                        'map',
                        'max',
                        'memoryview',
                        'min',
                        'next',
                        'object',
                        'oct',
                        'open',
                        'ord',
                        'pow',
                        'print',
                        'property',
                        'range',
                        'repr',
                        'reversed',
                        'round',
                        'set',
                        'setattr',
                        'slice',
                        'sorted',
                        'staticmethod',
                        'str',
                        'sum',
                        'super',
                        'tuple',
                        'type',
                        'vars',
                        'zip',
                    ];
                    const LITERALS = [
                        '__debug__',
                        'Ellipsis',
                        'False',
                        'None',
                        'NotImplemented',
                        'True',
                    ];
                    const TYPES = [
                        'Any',
                        'Callable',
                        'Coroutine',
                        'Dict',
                        'List',
                        'Literal',
                        'Generic',
                        'Optional',
                        'Sequence',
                        'Set',
                        'Tuple',
                        'Type',
                        'Union',
                    ];
                    const KEYWORDS = {
                        $pattern: /[A-Za-z]\w+|__\w+__/,
                        keyword: RESERVED_WORDS,
                        built_in: BUILT_INS,
                        literal: LITERALS,
                        type: TYPES,
                    };
                    const PROMPT = {
                        className: 'meta',
                        begin: /^(>>>|\.\.\.) /,
                    };
                    const SUBST = {
                        className: 'subst',
                        begin: /\{/,
                        end: /\}/,
                        keywords: KEYWORDS,
                        illegal: /#/,
                    };
                    const LITERAL_BRACKET = {
                        begin: /\{\{/,
                        relevance: 0,
                    };
                    const STRING = {
                        className: 'string',
                        contains: [hljs2.BACKSLASH_ESCAPE],
                        variants: [
                            {
                                begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
                                end: /'''/,
                                contains: [hljs2.BACKSLASH_ESCAPE, PROMPT],
                                relevance: 10,
                            },
                            {
                                begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
                                end: /"""/,
                                contains: [hljs2.BACKSLASH_ESCAPE, PROMPT],
                                relevance: 10,
                            },
                            {
                                begin: /([fF][rR]|[rR][fF]|[fF])'''/,
                                end: /'''/,
                                contains: [
                                    hljs2.BACKSLASH_ESCAPE,
                                    PROMPT,
                                    LITERAL_BRACKET,
                                    SUBST,
                                ],
                            },
                            {
                                begin: /([fF][rR]|[rR][fF]|[fF])"""/,
                                end: /"""/,
                                contains: [
                                    hljs2.BACKSLASH_ESCAPE,
                                    PROMPT,
                                    LITERAL_BRACKET,
                                    SUBST,
                                ],
                            },
                            {
                                begin: /([uU]|[rR])'/,
                                end: /'/,
                                relevance: 10,
                            },
                            {
                                begin: /([uU]|[rR])"/,
                                end: /"/,
                                relevance: 10,
                            },
                            {
                                begin: /([bB]|[bB][rR]|[rR][bB])'/,
                                end: /'/,
                            },
                            {
                                begin: /([bB]|[bB][rR]|[rR][bB])"/,
                                end: /"/,
                            },
                            {
                                begin: /([fF][rR]|[rR][fF]|[fF])'/,
                                end: /'/,
                                contains: [
                                    hljs2.BACKSLASH_ESCAPE,
                                    LITERAL_BRACKET,
                                    SUBST,
                                ],
                            },
                            {
                                begin: /([fF][rR]|[rR][fF]|[fF])"/,
                                end: /"/,
                                contains: [
                                    hljs2.BACKSLASH_ESCAPE,
                                    LITERAL_BRACKET,
                                    SUBST,
                                ],
                            },
                            hljs2.APOS_STRING_MODE,
                            hljs2.QUOTE_STRING_MODE,
                        ],
                    };
                    const digitpart = '[0-9](_?[0-9])*';
                    const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
                    const lookahead2 = `\\b|${RESERVED_WORDS.join('|')}`;
                    const NUMBER = {
                        className: 'number',
                        relevance: 0,
                        variants: [
                            // exponentfloat, pointfloat
                            // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
                            // optionally imaginary
                            // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
                            // Note: no leading \b because floats can start with a decimal point
                            // and we don't want to mishandle e.g. `fn(.5)`,
                            // no trailing \b for pointfloat because it can end with a decimal point
                            // and we don't want to mishandle e.g. `0..hex()`; this should be safe
                            // because both MUST contain a decimal point and so cannot be confused with
                            // the interior part of an identifier
                            {
                                begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?(?=${lookahead2})`,
                            },
                            {
                                begin: `(${pointfloat})[jJ]?`,
                            },
                            // decinteger, bininteger, octinteger, hexinteger
                            // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
                            // optionally "long" in Python 2
                            // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
                            // decinteger is optionally imaginary
                            // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
                            {
                                begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${lookahead2})`,
                            },
                            {
                                begin: `\\b0[bB](_?[01])+[lL]?(?=${lookahead2})`,
                            },
                            {
                                begin: `\\b0[oO](_?[0-7])+[lL]?(?=${lookahead2})`,
                            },
                            {
                                begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${lookahead2})`,
                            },
                            // imagnumber (digitpart-based)
                            // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
                            {
                                begin: `\\b(${digitpart})[jJ](?=${lookahead2})`,
                            },
                        ],
                    };
                    const COMMENT_TYPE = {
                        className: 'comment',
                        begin: regex.lookahead(/# type:/),
                        end: /$/,
                        keywords: KEYWORDS,
                        contains: [
                            {
                                // prevent keywords from coloring `type`
                                begin: /# type:/,
                            },
                            // comment within a datatype comment includes no keywords
                            {
                                begin: /#/,
                                end: /\b\B/,
                                endsWithParent: true,
                            },
                        ],
                    };
                    const PARAMS = {
                        className: 'params',
                        variants: [
                            // Exclude params in functions without params
                            {
                                className: '',
                                begin: /\(\s*\)/,
                                skip: true,
                            },
                            {
                                begin: /\(/,
                                end: /\)/,
                                excludeBegin: true,
                                excludeEnd: true,
                                keywords: KEYWORDS,
                                contains: [
                                    'self',
                                    PROMPT,
                                    NUMBER,
                                    STRING,
                                    hljs2.HASH_COMMENT_MODE,
                                ],
                            },
                        ],
                    };
                    SUBST.contains = [STRING, NUMBER, PROMPT];
                    return {
                        name: 'Python',
                        aliases: ['py', 'gyp', 'ipython'],
                        unicodeRegex: true,
                        keywords: KEYWORDS,
                        illegal: /(<\/|\?)|=>/,
                        contains: [
                            PROMPT,
                            NUMBER,
                            {
                                // very common convention
                                begin: /\bself\b/,
                            },
                            {
                                // eat "if" prior to string so that it won't accidentally be
                                // labeled as an f-string
                                beginKeywords: 'if',
                                relevance: 0,
                            },
                            STRING,
                            COMMENT_TYPE,
                            hljs2.HASH_COMMENT_MODE,
                            {
                                match: [/\bdef/, /\s+/, IDENT_RE2],
                                scope: {
                                    1: 'keyword',
                                    3: 'title.function',
                                },
                                contains: [PARAMS],
                            },
                            {
                                variants: [
                                    {
                                        match: [
                                            /\bclass/,
                                            /\s+/,
                                            IDENT_RE2,
                                            /\s*/,
                                            /\(\s*/,
                                            IDENT_RE2,
                                            /\s*\)/,
                                        ],
                                    },
                                    {
                                        match: [/\bclass/, /\s+/, IDENT_RE2],
                                    },
                                ],
                                scope: {
                                    1: 'keyword',
                                    3: 'title.class',
                                    6: 'title.class.inherited',
                                },
                            },
                            {
                                className: 'meta',
                                begin: /^[\t ]*@/,
                                end: /(?=#)|$/,
                                contains: [NUMBER, PARAMS, STRING],
                            },
                        ],
                    };
                }
                python_1 = python;
                return python_1;
            }
            var pythonRepl_1;
            var hasRequiredPythonRepl;
            function requirePythonRepl() {
                if (hasRequiredPythonRepl) return pythonRepl_1;
                hasRequiredPythonRepl = 1;
                function pythonRepl(hljs2) {
                    return {
                        aliases: ['pycon'],
                        contains: [
                            {
                                className: 'meta.prompt',
                                starts: {
                                    // a space separates the REPL prefix from the actual code
                                    // this is purely for cleaner HTML output
                                    end: / |$/,
                                    starts: {
                                        end: '$',
                                        subLanguage: 'python',
                                    },
                                },
                                variants: [
                                    { begin: /^>>>(?=[ ]|$)/ },
                                    { begin: /^\.\.\.(?=[ ]|$)/ },
                                ],
                            },
                        ],
                    };
                }
                pythonRepl_1 = pythonRepl;
                return pythonRepl_1;
            }
            var r_1;
            var hasRequiredR;
            function requireR() {
                if (hasRequiredR) return r_1;
                hasRequiredR = 1;
                function r(hljs2) {
                    const regex = hljs2.regex;
                    const IDENT_RE2 =
                        /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/;
                    const NUMBER_TYPES_RE = regex.either(
                        // Special case: only hexadecimal binary powers can contain fractions
                        /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
                        // Hexadecimal numbers without fraction and optional binary power
                        /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
                        // Decimal numbers
                        /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
                    );
                    const OPERATORS_RE =
                        /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/;
                    const PUNCTUATION_RE = regex.either(
                        /[()]/,
                        /[{}]/,
                        /\[\[/,
                        /[[\]]/,
                        /\\/,
                        /,/
                    );
                    return {
                        name: 'R',
                        keywords: {
                            $pattern: IDENT_RE2,
                            keyword:
                                'function if in break next repeat else for while',
                            literal:
                                'NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10',
                            built_in:
                                // Builtin constants
                                'LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm',
                        },
                        contains: [
                            // Roxygen comments
                            hljs2.COMMENT(/#'/, /$/, {
                                contains: [
                                    {
                                        // Handle `@examples` separately to cause all subsequent code
                                        // until the next `@`-tag on its own line to be kept as-is,
                                        // preventing highlighting. This code is example R code, so nested
                                        // doctags shouldn’t be treated as such. See
                                        // `test/markup/r/roxygen.txt` for an example.
                                        scope: 'doctag',
                                        match: /@examples/,
                                        starts: {
                                            end: regex.lookahead(
                                                regex.either(
                                                    // end if another doc comment
                                                    /\n^#'\s*(?=@[a-zA-Z]+)/,
                                                    // or a line with no comment
                                                    /\n^(?!#')/
                                                )
                                            ),
                                            endsParent: true,
                                        },
                                    },
                                    {
                                        // Handle `@param` to highlight the parameter name following
                                        // after.
                                        scope: 'doctag',
                                        begin: '@param',
                                        end: /$/,
                                        contains: [
                                            {
                                                scope: 'variable',
                                                variants: [
                                                    { match: IDENT_RE2 },
                                                    {
                                                        match: /`(?:\\.|[^`\\])+`/,
                                                    },
                                                ],
                                                endsParent: true,
                                            },
                                        ],
                                    },
                                    {
                                        scope: 'doctag',
                                        match: /@[a-zA-Z]+/,
                                    },
                                    {
                                        scope: 'keyword',
                                        match: /\\[a-zA-Z]+/,
                                    },
                                ],
                            }),
                            hljs2.HASH_COMMENT_MODE,
                            {
                                scope: 'string',
                                contains: [hljs2.BACKSLASH_ESCAPE],
                                variants: [
                                    hljs2.END_SAME_AS_BEGIN({
                                        begin: /[rR]"(-*)\(/,
                                        end: /\)(-*)"/,
                                    }),
                                    hljs2.END_SAME_AS_BEGIN({
                                        begin: /[rR]"(-*)\{/,
                                        end: /\}(-*)"/,
                                    }),
                                    hljs2.END_SAME_AS_BEGIN({
                                        begin: /[rR]"(-*)\[/,
                                        end: /\](-*)"/,
                                    }),
                                    hljs2.END_SAME_AS_BEGIN({
                                        begin: /[rR]'(-*)\(/,
                                        end: /\)(-*)'/,
                                    }),
                                    hljs2.END_SAME_AS_BEGIN({
                                        begin: /[rR]'(-*)\{/,
                                        end: /\}(-*)'/,
                                    }),
                                    hljs2.END_SAME_AS_BEGIN({
                                        begin: /[rR]'(-*)\[/,
                                        end: /\](-*)'/,
                                    }),
                                    {
                                        begin: '"',
                                        end: '"',
                                        relevance: 0,
                                    },
                                    {
                                        begin: "'",
                                        end: "'",
                                        relevance: 0,
                                    },
                                ],
                            },
                            // Matching numbers immediately following punctuation and operators is
                            // tricky since we need to look at the character ahead of a number to
                            // ensure the number is not part of an identifier, and we cannot use
                            // negative look-behind assertions. So instead we explicitly handle all
                            // possible combinations of (operator|punctuation), number.
                            // TODO: replace with negative look-behind when available
                            // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
                            // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
                            // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
                            {
                                relevance: 0,
                                variants: [
                                    {
                                        scope: {
                                            1: 'operator',
                                            2: 'number',
                                        },
                                        match: [OPERATORS_RE, NUMBER_TYPES_RE],
                                    },
                                    {
                                        scope: {
                                            1: 'operator',
                                            2: 'number',
                                        },
                                        match: [/%[^%]*%/, NUMBER_TYPES_RE],
                                    },
                                    {
                                        scope: {
                                            1: 'punctuation',
                                            2: 'number',
                                        },
                                        match: [
                                            PUNCTUATION_RE,
                                            NUMBER_TYPES_RE,
                                        ],
                                    },
                                    {
                                        scope: { 2: 'number' },
                                        match: [
                                            /[^a-zA-Z0-9._]|^/,
                                            // not part of an identifier, or start of document
                                            NUMBER_TYPES_RE,
                                        ],
                                    },
                                ],
                            },
                            // Operators/punctuation when they're not directly followed by numbers
                            {
                                // Relevance boost for the most common assignment form.
                                scope: { 3: 'operator' },
                                match: [IDENT_RE2, /\s+/, /<-/, /\s+/],
                            },
                            {
                                scope: 'operator',
                                relevance: 0,
                                variants: [
                                    { match: OPERATORS_RE },
                                    { match: /%[^%]*%/ },
                                ],
                            },
                            {
                                scope: 'punctuation',
                                relevance: 0,
                                match: PUNCTUATION_RE,
                            },
                            {
                                // Escaped identifier
                                begin: '`',
                                end: '`',
                                contains: [{ begin: /\\./ }],
                            },
                        ],
                    };
                }
                r_1 = r;
                return r_1;
            }
            var rust_1;
            var hasRequiredRust;
            function requireRust() {
                if (hasRequiredRust) return rust_1;
                hasRequiredRust = 1;
                function rust(hljs2) {
                    const regex = hljs2.regex;
                    const FUNCTION_INVOKE = {
                        className: 'title.function.invoke',
                        relevance: 0,
                        begin: regex.concat(
                            /\b/,
                            /(?!let|for|while|if|else|match\b)/,
                            hljs2.IDENT_RE,
                            regex.lookahead(/\s*\(/)
                        ),
                    };
                    const NUMBER_SUFFIX =
                        '([ui](8|16|32|64|128|size)|f(32|64))?';
                    const KEYWORDS = [
                        'abstract',
                        'as',
                        'async',
                        'await',
                        'become',
                        'box',
                        'break',
                        'const',
                        'continue',
                        'crate',
                        'do',
                        'dyn',
                        'else',
                        'enum',
                        'extern',
                        'false',
                        'final',
                        'fn',
                        'for',
                        'if',
                        'impl',
                        'in',
                        'let',
                        'loop',
                        'macro',
                        'match',
                        'mod',
                        'move',
                        'mut',
                        'override',
                        'priv',
                        'pub',
                        'ref',
                        'return',
                        'self',
                        'Self',
                        'static',
                        'struct',
                        'super',
                        'trait',
                        'true',
                        'try',
                        'type',
                        'typeof',
                        'unsafe',
                        'unsized',
                        'use',
                        'virtual',
                        'where',
                        'while',
                        'yield',
                    ];
                    const LITERALS = [
                        'true',
                        'false',
                        'Some',
                        'None',
                        'Ok',
                        'Err',
                    ];
                    const BUILTINS = [
                        // functions
                        'drop ',
                        // traits
                        'Copy',
                        'Send',
                        'Sized',
                        'Sync',
                        'Drop',
                        'Fn',
                        'FnMut',
                        'FnOnce',
                        'ToOwned',
                        'Clone',
                        'Debug',
                        'PartialEq',
                        'PartialOrd',
                        'Eq',
                        'Ord',
                        'AsRef',
                        'AsMut',
                        'Into',
                        'From',
                        'Default',
                        'Iterator',
                        'Extend',
                        'IntoIterator',
                        'DoubleEndedIterator',
                        'ExactSizeIterator',
                        'SliceConcatExt',
                        'ToString',
                        // macros
                        'assert!',
                        'assert_eq!',
                        'bitflags!',
                        'bytes!',
                        'cfg!',
                        'col!',
                        'concat!',
                        'concat_idents!',
                        'debug_assert!',
                        'debug_assert_eq!',
                        'env!',
                        'eprintln!',
                        'panic!',
                        'file!',
                        'format!',
                        'format_args!',
                        'include_bytes!',
                        'include_str!',
                        'line!',
                        'local_data_key!',
                        'module_path!',
                        'option_env!',
                        'print!',
                        'println!',
                        'select!',
                        'stringify!',
                        'try!',
                        'unimplemented!',
                        'unreachable!',
                        'vec!',
                        'write!',
                        'writeln!',
                        'macro_rules!',
                        'assert_ne!',
                        'debug_assert_ne!',
                    ];
                    const TYPES = [
                        'i8',
                        'i16',
                        'i32',
                        'i64',
                        'i128',
                        'isize',
                        'u8',
                        'u16',
                        'u32',
                        'u64',
                        'u128',
                        'usize',
                        'f32',
                        'f64',
                        'str',
                        'char',
                        'bool',
                        'Box',
                        'Option',
                        'Result',
                        'String',
                        'Vec',
                    ];
                    return {
                        name: 'Rust',
                        aliases: ['rs'],
                        keywords: {
                            $pattern: hljs2.IDENT_RE + '!?',
                            type: TYPES,
                            keyword: KEYWORDS,
                            literal: LITERALS,
                            built_in: BUILTINS,
                        },
                        illegal: '</',
                        contains: [
                            hljs2.C_LINE_COMMENT_MODE,
                            hljs2.COMMENT('/\\*', '\\*/', {
                                contains: ['self'],
                            }),
                            hljs2.inherit(hljs2.QUOTE_STRING_MODE, {
                                begin: /b?"/,
                                illegal: null,
                            }),
                            {
                                className: 'string',
                                variants: [
                                    { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
                                    {
                                        begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/,
                                    },
                                ],
                            },
                            {
                                className: 'symbol',
                                begin: /'[a-zA-Z_][a-zA-Z0-9_]*/,
                            },
                            {
                                className: 'number',
                                variants: [
                                    { begin: '\\b0b([01_]+)' + NUMBER_SUFFIX },
                                    { begin: '\\b0o([0-7_]+)' + NUMBER_SUFFIX },
                                    {
                                        begin:
                                            '\\b0x([A-Fa-f0-9_]+)' +
                                            NUMBER_SUFFIX,
                                    },
                                    {
                                        begin:
                                            '\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)' +
                                            NUMBER_SUFFIX,
                                    },
                                ],
                                relevance: 0,
                            },
                            {
                                begin: [/fn/, /\s+/, hljs2.UNDERSCORE_IDENT_RE],
                                className: {
                                    1: 'keyword',
                                    3: 'title.function',
                                },
                            },
                            {
                                className: 'meta',
                                begin: '#!?\\[',
                                end: '\\]',
                                contains: [
                                    {
                                        className: 'string',
                                        begin: /"/,
                                        end: /"/,
                                    },
                                ],
                            },
                            {
                                begin: [
                                    /let/,
                                    /\s+/,
                                    /(?:mut\s+)?/,
                                    hljs2.UNDERSCORE_IDENT_RE,
                                ],
                                className: {
                                    1: 'keyword',
                                    3: 'keyword',
                                    4: 'variable',
                                },
                            },
                            // must come before impl/for rule later
                            {
                                begin: [
                                    /for/,
                                    /\s+/,
                                    hljs2.UNDERSCORE_IDENT_RE,
                                    /\s+/,
                                    /in/,
                                ],
                                className: {
                                    1: 'keyword',
                                    3: 'variable',
                                    5: 'keyword',
                                },
                            },
                            {
                                begin: [
                                    /type/,
                                    /\s+/,
                                    hljs2.UNDERSCORE_IDENT_RE,
                                ],
                                className: {
                                    1: 'keyword',
                                    3: 'title.class',
                                },
                            },
                            {
                                begin: [
                                    /(?:trait|enum|struct|union|impl|for)/,
                                    /\s+/,
                                    hljs2.UNDERSCORE_IDENT_RE,
                                ],
                                className: {
                                    1: 'keyword',
                                    3: 'title.class',
                                },
                            },
                            {
                                begin: hljs2.IDENT_RE + '::',
                                keywords: {
                                    keyword: 'Self',
                                    built_in: BUILTINS,
                                    type: TYPES,
                                },
                            },
                            {
                                className: 'punctuation',
                                begin: '->',
                            },
                            FUNCTION_INVOKE,
                        ],
                    };
                }
                rust_1 = rust;
                return rust_1;
            }
            var scss_1;
            var hasRequiredScss;
            function requireScss() {
                if (hasRequiredScss) return scss_1;
                hasRequiredScss = 1;
                const MODES2 = (hljs2) => {
                    return {
                        IMPORTANT: {
                            scope: 'meta',
                            begin: '!important',
                        },
                        BLOCK_COMMENT: hljs2.C_BLOCK_COMMENT_MODE,
                        HEXCOLOR: {
                            scope: 'number',
                            begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/,
                        },
                        FUNCTION_DISPATCH: {
                            className: 'built_in',
                            begin: /[\w-]+(?=\()/,
                        },
                        ATTRIBUTE_SELECTOR_MODE: {
                            scope: 'selector-attr',
                            begin: /\[/,
                            end: /\]/,
                            illegal: '$',
                            contains: [
                                hljs2.APOS_STRING_MODE,
                                hljs2.QUOTE_STRING_MODE,
                            ],
                        },
                        CSS_NUMBER_MODE: {
                            scope: 'number',
                            begin:
                                hljs2.NUMBER_RE +
                                '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
                            relevance: 0,
                        },
                        CSS_VARIABLE: {
                            className: 'attr',
                            begin: /--[A-Za-z_][A-Za-z0-9_-]*/,
                        },
                    };
                };
                const TAGS = [
                    'a',
                    'abbr',
                    'address',
                    'article',
                    'aside',
                    'audio',
                    'b',
                    'blockquote',
                    'body',
                    'button',
                    'canvas',
                    'caption',
                    'cite',
                    'code',
                    'dd',
                    'del',
                    'details',
                    'dfn',
                    'div',
                    'dl',
                    'dt',
                    'em',
                    'fieldset',
                    'figcaption',
                    'figure',
                    'footer',
                    'form',
                    'h1',
                    'h2',
                    'h3',
                    'h4',
                    'h5',
                    'h6',
                    'header',
                    'hgroup',
                    'html',
                    'i',
                    'iframe',
                    'img',
                    'input',
                    'ins',
                    'kbd',
                    'label',
                    'legend',
                    'li',
                    'main',
                    'mark',
                    'menu',
                    'nav',
                    'object',
                    'ol',
                    'p',
                    'q',
                    'quote',
                    'samp',
                    'section',
                    'span',
                    'strong',
                    'summary',
                    'sup',
                    'table',
                    'tbody',
                    'td',
                    'textarea',
                    'tfoot',
                    'th',
                    'thead',
                    'time',
                    'tr',
                    'ul',
                    'var',
                    'video',
                ];
                const MEDIA_FEATURES = [
                    'any-hover',
                    'any-pointer',
                    'aspect-ratio',
                    'color',
                    'color-gamut',
                    'color-index',
                    'device-aspect-ratio',
                    'device-height',
                    'device-width',
                    'display-mode',
                    'forced-colors',
                    'grid',
                    'height',
                    'hover',
                    'inverted-colors',
                    'monochrome',
                    'orientation',
                    'overflow-block',
                    'overflow-inline',
                    'pointer',
                    'prefers-color-scheme',
                    'prefers-contrast',
                    'prefers-reduced-motion',
                    'prefers-reduced-transparency',
                    'resolution',
                    'scan',
                    'scripting',
                    'update',
                    'width',
                    // TODO: find a better solution?
                    'min-width',
                    'max-width',
                    'min-height',
                    'max-height',
                ];
                const PSEUDO_CLASSES = [
                    'active',
                    'any-link',
                    'blank',
                    'checked',
                    'current',
                    'default',
                    'defined',
                    'dir',
                    // dir()
                    'disabled',
                    'drop',
                    'empty',
                    'enabled',
                    'first',
                    'first-child',
                    'first-of-type',
                    'fullscreen',
                    'future',
                    'focus',
                    'focus-visible',
                    'focus-within',
                    'has',
                    // has()
                    'host',
                    // host or host()
                    'host-context',
                    // host-context()
                    'hover',
                    'indeterminate',
                    'in-range',
                    'invalid',
                    'is',
                    // is()
                    'lang',
                    // lang()
                    'last-child',
                    'last-of-type',
                    'left',
                    'link',
                    'local-link',
                    'not',
                    // not()
                    'nth-child',
                    // nth-child()
                    'nth-col',
                    // nth-col()
                    'nth-last-child',
                    // nth-last-child()
                    'nth-last-col',
                    // nth-last-col()
                    'nth-last-of-type',
                    //nth-last-of-type()
                    'nth-of-type',
                    //nth-of-type()
                    'only-child',
                    'only-of-type',
                    'optional',
                    'out-of-range',
                    'past',
                    'placeholder-shown',
                    'read-only',
                    'read-write',
                    'required',
                    'right',
                    'root',
                    'scope',
                    'target',
                    'target-within',
                    'user-invalid',
                    'valid',
                    'visited',
                    'where',
                    // where()
                ];
                const PSEUDO_ELEMENTS = [
                    'after',
                    'backdrop',
                    'before',
                    'cue',
                    'cue-region',
                    'first-letter',
                    'first-line',
                    'grammar-error',
                    'marker',
                    'part',
                    'placeholder',
                    'selection',
                    'slotted',
                    'spelling-error',
                ];
                const ATTRIBUTES = [
                    'align-content',
                    'align-items',
                    'align-self',
                    'all',
                    'animation',
                    'animation-delay',
                    'animation-direction',
                    'animation-duration',
                    'animation-fill-mode',
                    'animation-iteration-count',
                    'animation-name',
                    'animation-play-state',
                    'animation-timing-function',
                    'backface-visibility',
                    'background',
                    'background-attachment',
                    'background-blend-mode',
                    'background-clip',
                    'background-color',
                    'background-image',
                    'background-origin',
                    'background-position',
                    'background-repeat',
                    'background-size',
                    'block-size',
                    'border',
                    'border-block',
                    'border-block-color',
                    'border-block-end',
                    'border-block-end-color',
                    'border-block-end-style',
                    'border-block-end-width',
                    'border-block-start',
                    'border-block-start-color',
                    'border-block-start-style',
                    'border-block-start-width',
                    'border-block-style',
                    'border-block-width',
                    'border-bottom',
                    'border-bottom-color',
                    'border-bottom-left-radius',
                    'border-bottom-right-radius',
                    'border-bottom-style',
                    'border-bottom-width',
                    'border-collapse',
                    'border-color',
                    'border-image',
                    'border-image-outset',
                    'border-image-repeat',
                    'border-image-slice',
                    'border-image-source',
                    'border-image-width',
                    'border-inline',
                    'border-inline-color',
                    'border-inline-end',
                    'border-inline-end-color',
                    'border-inline-end-style',
                    'border-inline-end-width',
                    'border-inline-start',
                    'border-inline-start-color',
                    'border-inline-start-style',
                    'border-inline-start-width',
                    'border-inline-style',
                    'border-inline-width',
                    'border-left',
                    'border-left-color',
                    'border-left-style',
                    'border-left-width',
                    'border-radius',
                    'border-right',
                    'border-right-color',
                    'border-right-style',
                    'border-right-width',
                    'border-spacing',
                    'border-style',
                    'border-top',
                    'border-top-color',
                    'border-top-left-radius',
                    'border-top-right-radius',
                    'border-top-style',
                    'border-top-width',
                    'border-width',
                    'bottom',
                    'box-decoration-break',
                    'box-shadow',
                    'box-sizing',
                    'break-after',
                    'break-before',
                    'break-inside',
                    'caption-side',
                    'caret-color',
                    'clear',
                    'clip',
                    'clip-path',
                    'clip-rule',
                    'color',
                    'column-count',
                    'column-fill',
                    'column-gap',
                    'column-rule',
                    'column-rule-color',
                    'column-rule-style',
                    'column-rule-width',
                    'column-span',
                    'column-width',
                    'columns',
                    'contain',
                    'content',
                    'content-visibility',
                    'counter-increment',
                    'counter-reset',
                    'cue',
                    'cue-after',
                    'cue-before',
                    'cursor',
                    'direction',
                    'display',
                    'empty-cells',
                    'filter',
                    'flex',
                    'flex-basis',
                    'flex-direction',
                    'flex-flow',
                    'flex-grow',
                    'flex-shrink',
                    'flex-wrap',
                    'float',
                    'flow',
                    'font',
                    'font-display',
                    'font-family',
                    'font-feature-settings',
                    'font-kerning',
                    'font-language-override',
                    'font-size',
                    'font-size-adjust',
                    'font-smoothing',
                    'font-stretch',
                    'font-style',
                    'font-synthesis',
                    'font-variant',
                    'font-variant-caps',
                    'font-variant-east-asian',
                    'font-variant-ligatures',
                    'font-variant-numeric',
                    'font-variant-position',
                    'font-variation-settings',
                    'font-weight',
                    'gap',
                    'glyph-orientation-vertical',
                    'grid',
                    'grid-area',
                    'grid-auto-columns',
                    'grid-auto-flow',
                    'grid-auto-rows',
                    'grid-column',
                    'grid-column-end',
                    'grid-column-start',
                    'grid-gap',
                    'grid-row',
                    'grid-row-end',
                    'grid-row-start',
                    'grid-template',
                    'grid-template-areas',
                    'grid-template-columns',
                    'grid-template-rows',
                    'hanging-punctuation',
                    'height',
                    'hyphens',
                    'icon',
                    'image-orientation',
                    'image-rendering',
                    'image-resolution',
                    'ime-mode',
                    'inline-size',
                    'isolation',
                    'justify-content',
                    'left',
                    'letter-spacing',
                    'line-break',
                    'line-height',
                    'list-style',
                    'list-style-image',
                    'list-style-position',
                    'list-style-type',
                    'margin',
                    'margin-block',
                    'margin-block-end',
                    'margin-block-start',
                    'margin-bottom',
                    'margin-inline',
                    'margin-inline-end',
                    'margin-inline-start',
                    'margin-left',
                    'margin-right',
                    'margin-top',
                    'marks',
                    'mask',
                    'mask-border',
                    'mask-border-mode',
                    'mask-border-outset',
                    'mask-border-repeat',
                    'mask-border-slice',
                    'mask-border-source',
                    'mask-border-width',
                    'mask-clip',
                    'mask-composite',
                    'mask-image',
                    'mask-mode',
                    'mask-origin',
                    'mask-position',
                    'mask-repeat',
                    'mask-size',
                    'mask-type',
                    'max-block-size',
                    'max-height',
                    'max-inline-size',
                    'max-width',
                    'min-block-size',
                    'min-height',
                    'min-inline-size',
                    'min-width',
                    'mix-blend-mode',
                    'nav-down',
                    'nav-index',
                    'nav-left',
                    'nav-right',
                    'nav-up',
                    'none',
                    'normal',
                    'object-fit',
                    'object-position',
                    'opacity',
                    'order',
                    'orphans',
                    'outline',
                    'outline-color',
                    'outline-offset',
                    'outline-style',
                    'outline-width',
                    'overflow',
                    'overflow-wrap',
                    'overflow-x',
                    'overflow-y',
                    'padding',
                    'padding-block',
                    'padding-block-end',
                    'padding-block-start',
                    'padding-bottom',
                    'padding-inline',
                    'padding-inline-end',
                    'padding-inline-start',
                    'padding-left',
                    'padding-right',
                    'padding-top',
                    'page-break-after',
                    'page-break-before',
                    'page-break-inside',
                    'pause',
                    'pause-after',
                    'pause-before',
                    'perspective',
                    'perspective-origin',
                    'pointer-events',
                    'position',
                    'quotes',
                    'resize',
                    'rest',
                    'rest-after',
                    'rest-before',
                    'right',
                    'row-gap',
                    'scroll-margin',
                    'scroll-margin-block',
                    'scroll-margin-block-end',
                    'scroll-margin-block-start',
                    'scroll-margin-bottom',
                    'scroll-margin-inline',
                    'scroll-margin-inline-end',
                    'scroll-margin-inline-start',
                    'scroll-margin-left',
                    'scroll-margin-right',
                    'scroll-margin-top',
                    'scroll-padding',
                    'scroll-padding-block',
                    'scroll-padding-block-end',
                    'scroll-padding-block-start',
                    'scroll-padding-bottom',
                    'scroll-padding-inline',
                    'scroll-padding-inline-end',
                    'scroll-padding-inline-start',
                    'scroll-padding-left',
                    'scroll-padding-right',
                    'scroll-padding-top',
                    'scroll-snap-align',
                    'scroll-snap-stop',
                    'scroll-snap-type',
                    'scrollbar-color',
                    'scrollbar-gutter',
                    'scrollbar-width',
                    'shape-image-threshold',
                    'shape-margin',
                    'shape-outside',
                    'speak',
                    'speak-as',
                    'src',
                    // @font-face
                    'tab-size',
                    'table-layout',
                    'text-align',
                    'text-align-all',
                    'text-align-last',
                    'text-combine-upright',
                    'text-decoration',
                    'text-decoration-color',
                    'text-decoration-line',
                    'text-decoration-style',
                    'text-emphasis',
                    'text-emphasis-color',
                    'text-emphasis-position',
                    'text-emphasis-style',
                    'text-indent',
                    'text-justify',
                    'text-orientation',
                    'text-overflow',
                    'text-rendering',
                    'text-shadow',
                    'text-transform',
                    'text-underline-position',
                    'top',
                    'transform',
                    'transform-box',
                    'transform-origin',
                    'transform-style',
                    'transition',
                    'transition-delay',
                    'transition-duration',
                    'transition-property',
                    'transition-timing-function',
                    'unicode-bidi',
                    'vertical-align',
                    'visibility',
                    'voice-balance',
                    'voice-duration',
                    'voice-family',
                    'voice-pitch',
                    'voice-range',
                    'voice-rate',
                    'voice-stress',
                    'voice-volume',
                    'white-space',
                    'widows',
                    'width',
                    'will-change',
                    'word-break',
                    'word-spacing',
                    'word-wrap',
                    'writing-mode',
                    'z-index',
                    // reverse makes sure longer attributes `font-weight` are matched fully
                    // instead of getting false positives on say `font`
                ].reverse();
                function scss(hljs2) {
                    const modes = MODES2(hljs2);
                    const PSEUDO_ELEMENTS$1 = PSEUDO_ELEMENTS;
                    const PSEUDO_CLASSES$1 = PSEUDO_CLASSES;
                    const AT_IDENTIFIER = '@[a-z-]+';
                    const AT_MODIFIERS = 'and or not only';
                    const IDENT_RE2 = '[a-zA-Z-][a-zA-Z0-9_-]*';
                    const VARIABLE = {
                        className: 'variable',
                        begin: '(\\$' + IDENT_RE2 + ')\\b',
                        relevance: 0,
                    };
                    return {
                        name: 'SCSS',
                        case_insensitive: true,
                        illegal: "[=/|']",
                        contains: [
                            hljs2.C_LINE_COMMENT_MODE,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            // to recognize keyframe 40% etc which are outside the scope of our
                            // attribute value mode
                            modes.CSS_NUMBER_MODE,
                            {
                                className: 'selector-id',
                                begin: '#[A-Za-z0-9_-]+',
                                relevance: 0,
                            },
                            {
                                className: 'selector-class',
                                begin: '\\.[A-Za-z0-9_-]+',
                                relevance: 0,
                            },
                            modes.ATTRIBUTE_SELECTOR_MODE,
                            {
                                className: 'selector-tag',
                                begin: '\\b(' + TAGS.join('|') + ')\\b',
                                // was there, before, but why?
                                relevance: 0,
                            },
                            {
                                className: 'selector-pseudo',
                                begin: ':(' + PSEUDO_CLASSES$1.join('|') + ')',
                            },
                            {
                                className: 'selector-pseudo',
                                begin:
                                    ':(:)?(' +
                                    PSEUDO_ELEMENTS$1.join('|') +
                                    ')',
                            },
                            VARIABLE,
                            {
                                // pseudo-selector params
                                begin: /\(/,
                                end: /\)/,
                                contains: [modes.CSS_NUMBER_MODE],
                            },
                            modes.CSS_VARIABLE,
                            {
                                className: 'attribute',
                                begin: '\\b(' + ATTRIBUTES.join('|') + ')\\b',
                            },
                            {
                                begin: '\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b',
                            },
                            {
                                begin: /:/,
                                end: /[;}{]/,
                                relevance: 0,
                                contains: [
                                    modes.BLOCK_COMMENT,
                                    VARIABLE,
                                    modes.HEXCOLOR,
                                    modes.CSS_NUMBER_MODE,
                                    hljs2.QUOTE_STRING_MODE,
                                    hljs2.APOS_STRING_MODE,
                                    modes.IMPORTANT,
                                    modes.FUNCTION_DISPATCH,
                                ],
                            },
                            // matching these here allows us to treat them more like regular CSS
                            // rules so everything between the {} gets regular rule highlighting,
                            // which is what we want for page and font-face
                            {
                                begin: '@(page|font-face)',
                                keywords: {
                                    $pattern: AT_IDENTIFIER,
                                    keyword: '@page @font-face',
                                },
                            },
                            {
                                begin: '@',
                                end: '[{;]',
                                returnBegin: true,
                                keywords: {
                                    $pattern: /[a-z-]+/,
                                    keyword: AT_MODIFIERS,
                                    attribute: MEDIA_FEATURES.join(' '),
                                },
                                contains: [
                                    {
                                        begin: AT_IDENTIFIER,
                                        className: 'keyword',
                                    },
                                    {
                                        begin: /[a-z-]+(?=:)/,
                                        className: 'attribute',
                                    },
                                    VARIABLE,
                                    hljs2.QUOTE_STRING_MODE,
                                    hljs2.APOS_STRING_MODE,
                                    modes.HEXCOLOR,
                                    modes.CSS_NUMBER_MODE,
                                ],
                            },
                            modes.FUNCTION_DISPATCH,
                        ],
                    };
                }
                scss_1 = scss;
                return scss_1;
            }
            var shell_1;
            var hasRequiredShell;
            function requireShell() {
                if (hasRequiredShell) return shell_1;
                hasRequiredShell = 1;
                function shell(hljs2) {
                    return {
                        name: 'Shell Session',
                        aliases: ['console', 'shellsession'],
                        contains: [
                            {
                                className: 'meta.prompt',
                                // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
                                // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
                                // echo /path/to/home > t.exe
                                begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
                                starts: {
                                    end: /[^\\](?=\s*$)/,
                                    subLanguage: 'bash',
                                },
                            },
                        ],
                    };
                }
                shell_1 = shell;
                return shell_1;
            }
            var sql_1;
            var hasRequiredSql;
            function requireSql() {
                if (hasRequiredSql) return sql_1;
                hasRequiredSql = 1;
                function sql(hljs2) {
                    const regex = hljs2.regex;
                    const COMMENT_MODE = hljs2.COMMENT('--', '$');
                    const STRING = {
                        className: 'string',
                        variants: [
                            {
                                begin: /'/,
                                end: /'/,
                                contains: [{ begin: /''/ }],
                            },
                        ],
                    };
                    const QUOTED_IDENTIFIER = {
                        begin: /"/,
                        end: /"/,
                        contains: [{ begin: /""/ }],
                    };
                    const LITERALS = [
                        'true',
                        'false',
                        // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
                        // "null",
                        'unknown',
                    ];
                    const MULTI_WORD_TYPES = [
                        'double precision',
                        'large object',
                        'with timezone',
                        'without timezone',
                    ];
                    const TYPES = [
                        'bigint',
                        'binary',
                        'blob',
                        'boolean',
                        'char',
                        'character',
                        'clob',
                        'date',
                        'dec',
                        'decfloat',
                        'decimal',
                        'float',
                        'int',
                        'integer',
                        'interval',
                        'nchar',
                        'nclob',
                        'national',
                        'numeric',
                        'real',
                        'row',
                        'smallint',
                        'time',
                        'timestamp',
                        'varchar',
                        'varying',
                        // modifier (character varying)
                        'varbinary',
                    ];
                    const NON_RESERVED_WORDS = [
                        'add',
                        'asc',
                        'collation',
                        'desc',
                        'final',
                        'first',
                        'last',
                        'view',
                    ];
                    const RESERVED_WORDS = [
                        'abs',
                        'acos',
                        'all',
                        'allocate',
                        'alter',
                        'and',
                        'any',
                        'are',
                        'array',
                        'array_agg',
                        'array_max_cardinality',
                        'as',
                        'asensitive',
                        'asin',
                        'asymmetric',
                        'at',
                        'atan',
                        'atomic',
                        'authorization',
                        'avg',
                        'begin',
                        'begin_frame',
                        'begin_partition',
                        'between',
                        'bigint',
                        'binary',
                        'blob',
                        'boolean',
                        'both',
                        'by',
                        'call',
                        'called',
                        'cardinality',
                        'cascaded',
                        'case',
                        'cast',
                        'ceil',
                        'ceiling',
                        'char',
                        'char_length',
                        'character',
                        'character_length',
                        'check',
                        'classifier',
                        'clob',
                        'close',
                        'coalesce',
                        'collate',
                        'collect',
                        'column',
                        'commit',
                        'condition',
                        'connect',
                        'constraint',
                        'contains',
                        'convert',
                        'copy',
                        'corr',
                        'corresponding',
                        'cos',
                        'cosh',
                        'count',
                        'covar_pop',
                        'covar_samp',
                        'create',
                        'cross',
                        'cube',
                        'cume_dist',
                        'current',
                        'current_catalog',
                        'current_date',
                        'current_default_transform_group',
                        'current_path',
                        'current_role',
                        'current_row',
                        'current_schema',
                        'current_time',
                        'current_timestamp',
                        'current_path',
                        'current_role',
                        'current_transform_group_for_type',
                        'current_user',
                        'cursor',
                        'cycle',
                        'date',
                        'day',
                        'deallocate',
                        'dec',
                        'decimal',
                        'decfloat',
                        'declare',
                        'default',
                        'define',
                        'delete',
                        'dense_rank',
                        'deref',
                        'describe',
                        'deterministic',
                        'disconnect',
                        'distinct',
                        'double',
                        'drop',
                        'dynamic',
                        'each',
                        'element',
                        'else',
                        'empty',
                        'end',
                        'end_frame',
                        'end_partition',
                        'end-exec',
                        'equals',
                        'escape',
                        'every',
                        'except',
                        'exec',
                        'execute',
                        'exists',
                        'exp',
                        'external',
                        'extract',
                        'false',
                        'fetch',
                        'filter',
                        'first_value',
                        'float',
                        'floor',
                        'for',
                        'foreign',
                        'frame_row',
                        'free',
                        'from',
                        'full',
                        'function',
                        'fusion',
                        'get',
                        'global',
                        'grant',
                        'group',
                        'grouping',
                        'groups',
                        'having',
                        'hold',
                        'hour',
                        'identity',
                        'in',
                        'indicator',
                        'initial',
                        'inner',
                        'inout',
                        'insensitive',
                        'insert',
                        'int',
                        'integer',
                        'intersect',
                        'intersection',
                        'interval',
                        'into',
                        'is',
                        'join',
                        'json_array',
                        'json_arrayagg',
                        'json_exists',
                        'json_object',
                        'json_objectagg',
                        'json_query',
                        'json_table',
                        'json_table_primitive',
                        'json_value',
                        'lag',
                        'language',
                        'large',
                        'last_value',
                        'lateral',
                        'lead',
                        'leading',
                        'left',
                        'like',
                        'like_regex',
                        'listagg',
                        'ln',
                        'local',
                        'localtime',
                        'localtimestamp',
                        'log',
                        'log10',
                        'lower',
                        'match',
                        'match_number',
                        'match_recognize',
                        'matches',
                        'max',
                        'member',
                        'merge',
                        'method',
                        'min',
                        'minute',
                        'mod',
                        'modifies',
                        'module',
                        'month',
                        'multiset',
                        'national',
                        'natural',
                        'nchar',
                        'nclob',
                        'new',
                        'no',
                        'none',
                        'normalize',
                        'not',
                        'nth_value',
                        'ntile',
                        'null',
                        'nullif',
                        'numeric',
                        'octet_length',
                        'occurrences_regex',
                        'of',
                        'offset',
                        'old',
                        'omit',
                        'on',
                        'one',
                        'only',
                        'open',
                        'or',
                        'order',
                        'out',
                        'outer',
                        'over',
                        'overlaps',
                        'overlay',
                        'parameter',
                        'partition',
                        'pattern',
                        'per',
                        'percent',
                        'percent_rank',
                        'percentile_cont',
                        'percentile_disc',
                        'period',
                        'portion',
                        'position',
                        'position_regex',
                        'power',
                        'precedes',
                        'precision',
                        'prepare',
                        'primary',
                        'procedure',
                        'ptf',
                        'range',
                        'rank',
                        'reads',
                        'real',
                        'recursive',
                        'ref',
                        'references',
                        'referencing',
                        'regr_avgx',
                        'regr_avgy',
                        'regr_count',
                        'regr_intercept',
                        'regr_r2',
                        'regr_slope',
                        'regr_sxx',
                        'regr_sxy',
                        'regr_syy',
                        'release',
                        'result',
                        'return',
                        'returns',
                        'revoke',
                        'right',
                        'rollback',
                        'rollup',
                        'row',
                        'row_number',
                        'rows',
                        'running',
                        'savepoint',
                        'scope',
                        'scroll',
                        'search',
                        'second',
                        'seek',
                        'select',
                        'sensitive',
                        'session_user',
                        'set',
                        'show',
                        'similar',
                        'sin',
                        'sinh',
                        'skip',
                        'smallint',
                        'some',
                        'specific',
                        'specifictype',
                        'sql',
                        'sqlexception',
                        'sqlstate',
                        'sqlwarning',
                        'sqrt',
                        'start',
                        'static',
                        'stddev_pop',
                        'stddev_samp',
                        'submultiset',
                        'subset',
                        'substring',
                        'substring_regex',
                        'succeeds',
                        'sum',
                        'symmetric',
                        'system',
                        'system_time',
                        'system_user',
                        'table',
                        'tablesample',
                        'tan',
                        'tanh',
                        'then',
                        'time',
                        'timestamp',
                        'timezone_hour',
                        'timezone_minute',
                        'to',
                        'trailing',
                        'translate',
                        'translate_regex',
                        'translation',
                        'treat',
                        'trigger',
                        'trim',
                        'trim_array',
                        'true',
                        'truncate',
                        'uescape',
                        'union',
                        'unique',
                        'unknown',
                        'unnest',
                        'update',
                        'upper',
                        'user',
                        'using',
                        'value',
                        'values',
                        'value_of',
                        'var_pop',
                        'var_samp',
                        'varbinary',
                        'varchar',
                        'varying',
                        'versioning',
                        'when',
                        'whenever',
                        'where',
                        'width_bucket',
                        'window',
                        'with',
                        'within',
                        'without',
                        'year',
                    ];
                    const RESERVED_FUNCTIONS = [
                        'abs',
                        'acos',
                        'array_agg',
                        'asin',
                        'atan',
                        'avg',
                        'cast',
                        'ceil',
                        'ceiling',
                        'coalesce',
                        'corr',
                        'cos',
                        'cosh',
                        'count',
                        'covar_pop',
                        'covar_samp',
                        'cume_dist',
                        'dense_rank',
                        'deref',
                        'element',
                        'exp',
                        'extract',
                        'first_value',
                        'floor',
                        'json_array',
                        'json_arrayagg',
                        'json_exists',
                        'json_object',
                        'json_objectagg',
                        'json_query',
                        'json_table',
                        'json_table_primitive',
                        'json_value',
                        'lag',
                        'last_value',
                        'lead',
                        'listagg',
                        'ln',
                        'log',
                        'log10',
                        'lower',
                        'max',
                        'min',
                        'mod',
                        'nth_value',
                        'ntile',
                        'nullif',
                        'percent_rank',
                        'percentile_cont',
                        'percentile_disc',
                        'position',
                        'position_regex',
                        'power',
                        'rank',
                        'regr_avgx',
                        'regr_avgy',
                        'regr_count',
                        'regr_intercept',
                        'regr_r2',
                        'regr_slope',
                        'regr_sxx',
                        'regr_sxy',
                        'regr_syy',
                        'row_number',
                        'sin',
                        'sinh',
                        'sqrt',
                        'stddev_pop',
                        'stddev_samp',
                        'substring',
                        'substring_regex',
                        'sum',
                        'tan',
                        'tanh',
                        'translate',
                        'translate_regex',
                        'treat',
                        'trim',
                        'trim_array',
                        'unnest',
                        'upper',
                        'value_of',
                        'var_pop',
                        'var_samp',
                        'width_bucket',
                    ];
                    const POSSIBLE_WITHOUT_PARENS = [
                        'current_catalog',
                        'current_date',
                        'current_default_transform_group',
                        'current_path',
                        'current_role',
                        'current_schema',
                        'current_transform_group_for_type',
                        'current_user',
                        'session_user',
                        'system_time',
                        'system_user',
                        'current_time',
                        'localtime',
                        'current_timestamp',
                        'localtimestamp',
                    ];
                    const COMBOS = [
                        'create table',
                        'insert into',
                        'primary key',
                        'foreign key',
                        'not null',
                        'alter table',
                        'add constraint',
                        'grouping sets',
                        'on overflow',
                        'character set',
                        'respect nulls',
                        'ignore nulls',
                        'nulls first',
                        'nulls last',
                        'depth first',
                        'breadth first',
                    ];
                    const FUNCTIONS = RESERVED_FUNCTIONS;
                    const KEYWORDS = [
                        ...RESERVED_WORDS,
                        ...NON_RESERVED_WORDS,
                    ].filter((keyword) => {
                        return !RESERVED_FUNCTIONS.includes(keyword);
                    });
                    const VARIABLE = {
                        className: 'variable',
                        begin: /@[a-z0-9][a-z0-9_]*/,
                    };
                    const OPERATOR = {
                        className: 'operator',
                        begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
                        relevance: 0,
                    };
                    const FUNCTION_CALL = {
                        begin: regex.concat(
                            /\b/,
                            regex.either(...FUNCTIONS),
                            /\s*\(/
                        ),
                        relevance: 0,
                        keywords: { built_in: FUNCTIONS },
                    };
                    function reduceRelevancy(list2, { exceptions, when } = {}) {
                        const qualifyFn = when;
                        exceptions = exceptions || [];
                        return list2.map((item) => {
                            if (
                                item.match(/\|\d+$/) ||
                                exceptions.includes(item)
                            ) {
                                return item;
                            } else if (qualifyFn(item)) {
                                return `${item}|0`;
                            } else {
                                return item;
                            }
                        });
                    }
                    return {
                        name: 'SQL',
                        case_insensitive: true,
                        // does not include {} or HTML tags `</`
                        illegal: /[{}]|<\//,
                        keywords: {
                            $pattern: /\b[\w\.]+/,
                            keyword: reduceRelevancy(KEYWORDS, {
                                when: (x) => x.length < 3,
                            }),
                            literal: LITERALS,
                            type: TYPES,
                            built_in: POSSIBLE_WITHOUT_PARENS,
                        },
                        contains: [
                            {
                                begin: regex.either(...COMBOS),
                                relevance: 0,
                                keywords: {
                                    $pattern: /[\w\.]+/,
                                    keyword: KEYWORDS.concat(COMBOS),
                                    literal: LITERALS,
                                    type: TYPES,
                                },
                            },
                            {
                                className: 'type',
                                begin: regex.either(...MULTI_WORD_TYPES),
                            },
                            FUNCTION_CALL,
                            VARIABLE,
                            STRING,
                            QUOTED_IDENTIFIER,
                            hljs2.C_NUMBER_MODE,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            COMMENT_MODE,
                            OPERATOR,
                        ],
                    };
                }
                sql_1 = sql;
                return sql_1;
            }
            var swift_1;
            var hasRequiredSwift;
            function requireSwift() {
                if (hasRequiredSwift) return swift_1;
                hasRequiredSwift = 1;
                function source2(re) {
                    if (!re) return null;
                    if (typeof re === 'string') return re;
                    return re.source;
                }
                function lookahead2(re) {
                    return concat2('(?=', re, ')');
                }
                function concat2(...args) {
                    const joined = args.map((x) => source2(x)).join('');
                    return joined;
                }
                function stripOptionsFromArgs2(args) {
                    const opts = args[args.length - 1];
                    if (
                        typeof opts === 'object' &&
                        opts.constructor === Object
                    ) {
                        args.splice(args.length - 1, 1);
                        return opts;
                    } else {
                        return {};
                    }
                }
                function either2(...args) {
                    const opts = stripOptionsFromArgs2(args);
                    const joined =
                        '(' +
                        (opts.capture ? '' : '?:') +
                        args.map((x) => source2(x)).join('|') +
                        ')';
                    return joined;
                }
                const keywordWrapper = (keyword) =>
                    concat2(/\b/, keyword, /\w$/.test(keyword) ? /\b/ : /\B/);
                const dotKeywords = [
                    'Protocol',
                    // contextual
                    'Type',
                    // contextual
                ].map(keywordWrapper);
                const optionalDotKeywords = ['init', 'self'].map(
                    keywordWrapper
                );
                const keywordTypes = ['Any', 'Self'];
                const keywords = [
                    // strings below will be fed into the regular `keywords` engine while regex
                    // will result in additional modes being created to scan for those keywords to
                    // avoid conflicts with other rules
                    'actor',
                    'any',
                    // contextual
                    'associatedtype',
                    'async',
                    'await',
                    /as\?/,
                    // operator
                    /as!/,
                    // operator
                    'as',
                    // operator
                    'borrowing',
                    // contextual
                    'break',
                    'case',
                    'catch',
                    'class',
                    'consume',
                    // contextual
                    'consuming',
                    // contextual
                    'continue',
                    'convenience',
                    // contextual
                    'copy',
                    // contextual
                    'default',
                    'defer',
                    'deinit',
                    'didSet',
                    // contextual
                    'distributed',
                    'do',
                    'dynamic',
                    // contextual
                    'each',
                    'else',
                    'enum',
                    'extension',
                    'fallthrough',
                    /fileprivate\(set\)/,
                    'fileprivate',
                    'final',
                    // contextual
                    'for',
                    'func',
                    'get',
                    // contextual
                    'guard',
                    'if',
                    'import',
                    'indirect',
                    // contextual
                    'infix',
                    // contextual
                    /init\?/,
                    /init!/,
                    'inout',
                    /internal\(set\)/,
                    'internal',
                    'in',
                    'is',
                    // operator
                    'isolated',
                    // contextual
                    'nonisolated',
                    // contextual
                    'lazy',
                    // contextual
                    'let',
                    'macro',
                    'mutating',
                    // contextual
                    'nonmutating',
                    // contextual
                    /open\(set\)/,
                    // contextual
                    'open',
                    // contextual
                    'operator',
                    'optional',
                    // contextual
                    'override',
                    // contextual
                    'postfix',
                    // contextual
                    'precedencegroup',
                    'prefix',
                    // contextual
                    /private\(set\)/,
                    'private',
                    'protocol',
                    /public\(set\)/,
                    'public',
                    'repeat',
                    'required',
                    // contextual
                    'rethrows',
                    'return',
                    'set',
                    // contextual
                    'some',
                    // contextual
                    'static',
                    'struct',
                    'subscript',
                    'super',
                    'switch',
                    'throws',
                    'throw',
                    /try\?/,
                    // operator
                    /try!/,
                    // operator
                    'try',
                    // operator
                    'typealias',
                    /unowned\(safe\)/,
                    // contextual
                    /unowned\(unsafe\)/,
                    // contextual
                    'unowned',
                    // contextual
                    'var',
                    'weak',
                    // contextual
                    'where',
                    'while',
                    'willSet',
                    // contextual
                ];
                const literals = ['false', 'nil', 'true'];
                const precedencegroupKeywords = [
                    'assignment',
                    'associativity',
                    'higherThan',
                    'left',
                    'lowerThan',
                    'none',
                    'right',
                ];
                const numberSignKeywords = [
                    '#colorLiteral',
                    '#column',
                    '#dsohandle',
                    '#else',
                    '#elseif',
                    '#endif',
                    '#error',
                    '#file',
                    '#fileID',
                    '#fileLiteral',
                    '#filePath',
                    '#function',
                    '#if',
                    '#imageLiteral',
                    '#keyPath',
                    '#line',
                    '#selector',
                    '#sourceLocation',
                    '#warning',
                ];
                const builtIns = [
                    'abs',
                    'all',
                    'any',
                    'assert',
                    'assertionFailure',
                    'debugPrint',
                    'dump',
                    'fatalError',
                    'getVaList',
                    'isKnownUniquelyReferenced',
                    'max',
                    'min',
                    'numericCast',
                    'pointwiseMax',
                    'pointwiseMin',
                    'precondition',
                    'preconditionFailure',
                    'print',
                    'readLine',
                    'repeatElement',
                    'sequence',
                    'stride',
                    'swap',
                    'swift_unboxFromSwiftValueWithType',
                    'transcode',
                    'type',
                    'unsafeBitCast',
                    'unsafeDowncast',
                    'withExtendedLifetime',
                    'withUnsafeMutablePointer',
                    'withUnsafePointer',
                    'withVaList',
                    'withoutActuallyEscaping',
                    'zip',
                ];
                const operatorHead = either2(
                    /[/=\-+!*%<>&|^~?]/,
                    /[\u00A1-\u00A7]/,
                    /[\u00A9\u00AB]/,
                    /[\u00AC\u00AE]/,
                    /[\u00B0\u00B1]/,
                    /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
                    /[\u2016-\u2017]/,
                    /[\u2020-\u2027]/,
                    /[\u2030-\u203E]/,
                    /[\u2041-\u2053]/,
                    /[\u2055-\u205E]/,
                    /[\u2190-\u23FF]/,
                    /[\u2500-\u2775]/,
                    /[\u2794-\u2BFF]/,
                    /[\u2E00-\u2E7F]/,
                    /[\u3001-\u3003]/,
                    /[\u3008-\u3020]/,
                    /[\u3030]/
                );
                const operatorCharacter = either2(
                    operatorHead,
                    /[\u0300-\u036F]/,
                    /[\u1DC0-\u1DFF]/,
                    /[\u20D0-\u20FF]/,
                    /[\uFE00-\uFE0F]/,
                    /[\uFE20-\uFE2F]/
                    // TODO: The following characters are also allowed, but the regex isn't supported yet.
                    // /[\u{E0100}-\u{E01EF}]/u
                );
                const operator = concat2(operatorHead, operatorCharacter, '*');
                const identifierHead = either2(
                    /[a-zA-Z_]/,
                    /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
                    /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
                    /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
                    /[\u1E00-\u1FFF]/,
                    /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
                    /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
                    /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
                    /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
                    /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
                    /[\uFE47-\uFEFE\uFF00-\uFFFD]/
                    // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
                    // The following characters are also allowed, but the regexes aren't supported yet.
                    // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
                    // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
                    // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
                    // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
                );
                const identifierCharacter = either2(
                    identifierHead,
                    /\d/,
                    /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
                );
                const identifier = concat2(
                    identifierHead,
                    identifierCharacter,
                    '*'
                );
                const typeIdentifier = concat2(
                    /[A-Z]/,
                    identifierCharacter,
                    '*'
                );
                const keywordAttributes = [
                    'attached',
                    'autoclosure',
                    concat2(
                        /convention\(/,
                        either2('swift', 'block', 'c'),
                        /\)/
                    ),
                    'discardableResult',
                    'dynamicCallable',
                    'dynamicMemberLookup',
                    'escaping',
                    'freestanding',
                    'frozen',
                    'GKInspectable',
                    'IBAction',
                    'IBDesignable',
                    'IBInspectable',
                    'IBOutlet',
                    'IBSegueAction',
                    'inlinable',
                    'main',
                    'nonobjc',
                    'NSApplicationMain',
                    'NSCopying',
                    'NSManaged',
                    concat2(/objc\(/, identifier, /\)/),
                    'objc',
                    'objcMembers',
                    'propertyWrapper',
                    'requires_stored_property_inits',
                    'resultBuilder',
                    'Sendable',
                    'testable',
                    'UIApplicationMain',
                    'unchecked',
                    'unknown',
                    'usableFromInline',
                    'warn_unqualified_access',
                ];
                const availabilityKeywords = [
                    'iOS',
                    'iOSApplicationExtension',
                    'macOS',
                    'macOSApplicationExtension',
                    'macCatalyst',
                    'macCatalystApplicationExtension',
                    'watchOS',
                    'watchOSApplicationExtension',
                    'tvOS',
                    'tvOSApplicationExtension',
                    'swift',
                ];
                function swift(hljs2) {
                    const WHITESPACE = {
                        match: /\s+/,
                        relevance: 0,
                    };
                    const BLOCK_COMMENT = hljs2.COMMENT('/\\*', '\\*/', {
                        contains: ['self'],
                    });
                    const COMMENTS = [hljs2.C_LINE_COMMENT_MODE, BLOCK_COMMENT];
                    const DOT_KEYWORD = {
                        match: [
                            /\./,
                            either2(...dotKeywords, ...optionalDotKeywords),
                        ],
                        className: { 2: 'keyword' },
                    };
                    const KEYWORD_GUARD = {
                        // Consume .keyword to prevent highlighting properties and methods as keywords.
                        match: concat2(/\./, either2(...keywords)),
                        relevance: 0,
                    };
                    const PLAIN_KEYWORDS = keywords
                        .filter((kw) => typeof kw === 'string')
                        .concat(['_|0']);
                    const REGEX_KEYWORDS = keywords
                        .filter((kw) => typeof kw !== 'string')
                        .concat(keywordTypes)
                        .map(keywordWrapper);
                    const KEYWORD = {
                        variants: [
                            {
                                className: 'keyword',
                                match: either2(
                                    ...REGEX_KEYWORDS,
                                    ...optionalDotKeywords
                                ),
                            },
                        ],
                    };
                    const KEYWORDS = {
                        $pattern: either2(
                            /\b\w+/,
                            // regular keywords
                            /#\w+/
                            // number keywords
                        ),
                        keyword: PLAIN_KEYWORDS.concat(numberSignKeywords),
                        literal: literals,
                    };
                    const KEYWORD_MODES = [DOT_KEYWORD, KEYWORD_GUARD, KEYWORD];
                    const BUILT_IN_GUARD = {
                        // Consume .built_in to prevent highlighting properties and methods.
                        match: concat2(/\./, either2(...builtIns)),
                        relevance: 0,
                    };
                    const BUILT_IN = {
                        className: 'built_in',
                        match: concat2(/\b/, either2(...builtIns), /(?=\()/),
                    };
                    const BUILT_INS = [BUILT_IN_GUARD, BUILT_IN];
                    const OPERATOR_GUARD = {
                        // Prevent -> from being highlighting as an operator.
                        match: /->/,
                        relevance: 0,
                    };
                    const OPERATOR = {
                        className: 'operator',
                        relevance: 0,
                        variants: [
                            { match: operator },
                            {
                                // dot-operator: only operators that start with a dot are allowed to use dots as
                                // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
                                // characters that may also include dots.
                                match: `\\.(\\.|${operatorCharacter})+`,
                            },
                        ],
                    };
                    const OPERATORS = [OPERATOR_GUARD, OPERATOR];
                    const decimalDigits = '([0-9]_*)+';
                    const hexDigits = '([0-9a-fA-F]_*)+';
                    const NUMBER = {
                        className: 'number',
                        relevance: 0,
                        variants: [
                            // decimal floating-point-literal (subsumes decimal-literal)
                            {
                                match: `\\b(${decimalDigits})(\\.(${decimalDigits}))?([eE][+-]?(${decimalDigits}))?\\b`,
                            },
                            // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
                            {
                                match: `\\b0x(${hexDigits})(\\.(${hexDigits}))?([pP][+-]?(${decimalDigits}))?\\b`,
                            },
                            // octal-literal
                            { match: /\b0o([0-7]_*)+\b/ },
                            // binary-literal
                            { match: /\b0b([01]_*)+\b/ },
                        ],
                    };
                    const ESCAPED_CHARACTER = (rawDelimiter = '') => ({
                        className: 'subst',
                        variants: [
                            {
                                match: concat2(
                                    /\\/,
                                    rawDelimiter,
                                    /[0\\tnr"']/
                                ),
                            },
                            {
                                match: concat2(
                                    /\\/,
                                    rawDelimiter,
                                    /u\{[0-9a-fA-F]{1,8}\}/
                                ),
                            },
                        ],
                    });
                    const ESCAPED_NEWLINE = (rawDelimiter = '') => ({
                        className: 'subst',
                        match: concat2(
                            /\\/,
                            rawDelimiter,
                            /[\t ]*(?:[\r\n]|\r\n)/
                        ),
                    });
                    const INTERPOLATION = (rawDelimiter = '') => ({
                        className: 'subst',
                        label: 'interpol',
                        begin: concat2(/\\/, rawDelimiter, /\(/),
                        end: /\)/,
                    });
                    const MULTILINE_STRING = (rawDelimiter = '') => ({
                        begin: concat2(rawDelimiter, /"""/),
                        end: concat2(/"""/, rawDelimiter),
                        contains: [
                            ESCAPED_CHARACTER(rawDelimiter),
                            ESCAPED_NEWLINE(rawDelimiter),
                            INTERPOLATION(rawDelimiter),
                        ],
                    });
                    const SINGLE_LINE_STRING = (rawDelimiter = '') => ({
                        begin: concat2(rawDelimiter, /"/),
                        end: concat2(/"/, rawDelimiter),
                        contains: [
                            ESCAPED_CHARACTER(rawDelimiter),
                            INTERPOLATION(rawDelimiter),
                        ],
                    });
                    const STRING = {
                        className: 'string',
                        variants: [
                            MULTILINE_STRING(),
                            MULTILINE_STRING('#'),
                            MULTILINE_STRING('##'),
                            MULTILINE_STRING('###'),
                            SINGLE_LINE_STRING(),
                            SINGLE_LINE_STRING('#'),
                            SINGLE_LINE_STRING('##'),
                            SINGLE_LINE_STRING('###'),
                        ],
                    };
                    const REGEXP_CONTENTS = [
                        hljs2.BACKSLASH_ESCAPE,
                        {
                            begin: /\[/,
                            end: /\]/,
                            relevance: 0,
                            contains: [hljs2.BACKSLASH_ESCAPE],
                        },
                    ];
                    const BARE_REGEXP_LITERAL = {
                        begin: /\/[^\s](?=[^/\n]*\/)/,
                        end: /\//,
                        contains: REGEXP_CONTENTS,
                    };
                    const EXTENDED_REGEXP_LITERAL = (rawDelimiter) => {
                        const begin = concat2(rawDelimiter, /\//);
                        const end = concat2(/\//, rawDelimiter);
                        return {
                            begin,
                            end,
                            contains: [
                                ...REGEXP_CONTENTS,
                                {
                                    scope: 'comment',
                                    begin: `#(?!.*${end})`,
                                    end: /$/,
                                },
                            ],
                        };
                    };
                    const REGEXP = {
                        scope: 'regexp',
                        variants: [
                            EXTENDED_REGEXP_LITERAL('###'),
                            EXTENDED_REGEXP_LITERAL('##'),
                            EXTENDED_REGEXP_LITERAL('#'),
                            BARE_REGEXP_LITERAL,
                        ],
                    };
                    const QUOTED_IDENTIFIER = {
                        match: concat2(/`/, identifier, /`/),
                    };
                    const IMPLICIT_PARAMETER = {
                        className: 'variable',
                        match: /\$\d+/,
                    };
                    const PROPERTY_WRAPPER_PROJECTION = {
                        className: 'variable',
                        match: `\\$${identifierCharacter}+`,
                    };
                    const IDENTIFIERS = [
                        QUOTED_IDENTIFIER,
                        IMPLICIT_PARAMETER,
                        PROPERTY_WRAPPER_PROJECTION,
                    ];
                    const AVAILABLE_ATTRIBUTE = {
                        match: /(@|#(un)?)available/,
                        scope: 'keyword',
                        starts: {
                            contains: [
                                {
                                    begin: /\(/,
                                    end: /\)/,
                                    keywords: availabilityKeywords,
                                    contains: [...OPERATORS, NUMBER, STRING],
                                },
                            ],
                        },
                    };
                    const KEYWORD_ATTRIBUTE = {
                        scope: 'keyword',
                        match: concat2(/@/, either2(...keywordAttributes)),
                    };
                    const USER_DEFINED_ATTRIBUTE = {
                        scope: 'meta',
                        match: concat2(/@/, identifier),
                    };
                    const ATTRIBUTES = [
                        AVAILABLE_ATTRIBUTE,
                        KEYWORD_ATTRIBUTE,
                        USER_DEFINED_ATTRIBUTE,
                    ];
                    const TYPE = {
                        match: lookahead2(/\b[A-Z]/),
                        relevance: 0,
                        contains: [
                            {
                                // Common Apple frameworks, for relevance boost
                                className: 'type',
                                match: concat2(
                                    /(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/,
                                    identifierCharacter,
                                    '+'
                                ),
                            },
                            {
                                // Type identifier
                                className: 'type',
                                match: typeIdentifier,
                                relevance: 0,
                            },
                            {
                                // Optional type
                                match: /[?!]+/,
                                relevance: 0,
                            },
                            {
                                // Variadic parameter
                                match: /\.\.\./,
                                relevance: 0,
                            },
                            {
                                // Protocol composition
                                match: concat2(
                                    /\s+&\s+/,
                                    lookahead2(typeIdentifier)
                                ),
                                relevance: 0,
                            },
                        ],
                    };
                    const GENERIC_ARGUMENTS = {
                        begin: /</,
                        end: />/,
                        keywords: KEYWORDS,
                        contains: [
                            ...COMMENTS,
                            ...KEYWORD_MODES,
                            ...ATTRIBUTES,
                            OPERATOR_GUARD,
                            TYPE,
                        ],
                    };
                    TYPE.contains.push(GENERIC_ARGUMENTS);
                    const TUPLE_ELEMENT_NAME = {
                        match: concat2(identifier, /\s*:/),
                        keywords: '_|0',
                        relevance: 0,
                    };
                    const TUPLE = {
                        begin: /\(/,
                        end: /\)/,
                        relevance: 0,
                        keywords: KEYWORDS,
                        contains: [
                            'self',
                            TUPLE_ELEMENT_NAME,
                            ...COMMENTS,
                            REGEXP,
                            ...KEYWORD_MODES,
                            ...BUILT_INS,
                            ...OPERATORS,
                            NUMBER,
                            STRING,
                            ...IDENTIFIERS,
                            ...ATTRIBUTES,
                            TYPE,
                        ],
                    };
                    const GENERIC_PARAMETERS = {
                        begin: /</,
                        end: />/,
                        keywords: 'repeat each',
                        contains: [...COMMENTS, TYPE],
                    };
                    const FUNCTION_PARAMETER_NAME = {
                        begin: either2(
                            lookahead2(concat2(identifier, /\s*:/)),
                            lookahead2(
                                concat2(identifier, /\s+/, identifier, /\s*:/)
                            )
                        ),
                        end: /:/,
                        relevance: 0,
                        contains: [
                            {
                                className: 'keyword',
                                match: /\b_\b/,
                            },
                            {
                                className: 'params',
                                match: identifier,
                            },
                        ],
                    };
                    const FUNCTION_PARAMETERS = {
                        begin: /\(/,
                        end: /\)/,
                        keywords: KEYWORDS,
                        contains: [
                            FUNCTION_PARAMETER_NAME,
                            ...COMMENTS,
                            ...KEYWORD_MODES,
                            ...OPERATORS,
                            NUMBER,
                            STRING,
                            ...ATTRIBUTES,
                            TYPE,
                            TUPLE,
                        ],
                        endsParent: true,
                        illegal: /["']/,
                    };
                    const FUNCTION_OR_MACRO = {
                        match: [
                            /(func|macro)/,
                            /\s+/,
                            either2(
                                QUOTED_IDENTIFIER.match,
                                identifier,
                                operator
                            ),
                        ],
                        className: {
                            1: 'keyword',
                            3: 'title.function',
                        },
                        contains: [
                            GENERIC_PARAMETERS,
                            FUNCTION_PARAMETERS,
                            WHITESPACE,
                        ],
                        illegal: [/\[/, /%/],
                    };
                    const INIT_SUBSCRIPT = {
                        match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
                        className: { 1: 'keyword' },
                        contains: [
                            GENERIC_PARAMETERS,
                            FUNCTION_PARAMETERS,
                            WHITESPACE,
                        ],
                        illegal: /\[|%/,
                    };
                    const OPERATOR_DECLARATION = {
                        match: [/operator/, /\s+/, operator],
                        className: {
                            1: 'keyword',
                            3: 'title',
                        },
                    };
                    const PRECEDENCEGROUP = {
                        begin: [/precedencegroup/, /\s+/, typeIdentifier],
                        className: {
                            1: 'keyword',
                            3: 'title',
                        },
                        contains: [TYPE],
                        keywords: [...precedencegroupKeywords, ...literals],
                        end: /}/,
                    };
                    for (const variant of STRING.variants) {
                        const interpolation = variant.contains.find(
                            (mode) => mode.label === 'interpol'
                        );
                        interpolation.keywords = KEYWORDS;
                        const submodes = [
                            ...KEYWORD_MODES,
                            ...BUILT_INS,
                            ...OPERATORS,
                            NUMBER,
                            STRING,
                            ...IDENTIFIERS,
                        ];
                        interpolation.contains = [
                            ...submodes,
                            {
                                begin: /\(/,
                                end: /\)/,
                                contains: ['self', ...submodes],
                            },
                        ];
                    }
                    return {
                        name: 'Swift',
                        keywords: KEYWORDS,
                        contains: [
                            ...COMMENTS,
                            FUNCTION_OR_MACRO,
                            INIT_SUBSCRIPT,
                            {
                                beginKeywords:
                                    'struct protocol class extension enum actor',
                                end: '\\{',
                                excludeEnd: true,
                                keywords: KEYWORDS,
                                contains: [
                                    hljs2.inherit(hljs2.TITLE_MODE, {
                                        className: 'title.class',
                                        begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/,
                                    }),
                                    ...KEYWORD_MODES,
                                ],
                            },
                            OPERATOR_DECLARATION,
                            PRECEDENCEGROUP,
                            {
                                beginKeywords: 'import',
                                end: /$/,
                                contains: [...COMMENTS],
                                relevance: 0,
                            },
                            REGEXP,
                            ...KEYWORD_MODES,
                            ...BUILT_INS,
                            ...OPERATORS,
                            NUMBER,
                            STRING,
                            ...IDENTIFIERS,
                            ...ATTRIBUTES,
                            TYPE,
                            TUPLE,
                        ],
                    };
                }
                swift_1 = swift;
                return swift_1;
            }
            var yaml_1;
            var hasRequiredYaml;
            function requireYaml() {
                if (hasRequiredYaml) return yaml_1;
                hasRequiredYaml = 1;
                function yaml(hljs2) {
                    const LITERALS = 'true false yes no null';
                    const URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
                    const KEY = {
                        className: 'attr',
                        variants: [
                            { begin: '\\w[\\w :\\/.-]*:(?=[ 	]|$)' },
                            {
                                // double quoted keys
                                begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)',
                            },
                            {
                                // single quoted keys
                                begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)",
                            },
                        ],
                    };
                    const TEMPLATE_VARIABLES = {
                        className: 'template-variable',
                        variants: [
                            {
                                // jinja templates Ansible
                                begin: /\{\{/,
                                end: /\}\}/,
                            },
                            {
                                // Ruby i18n
                                begin: /%\{/,
                                end: /\}/,
                            },
                        ],
                    };
                    const STRING = {
                        className: 'string',
                        relevance: 0,
                        variants: [
                            {
                                begin: /'/,
                                end: /'/,
                            },
                            {
                                begin: /"/,
                                end: /"/,
                            },
                            { begin: /\S+/ },
                        ],
                        contains: [hljs2.BACKSLASH_ESCAPE, TEMPLATE_VARIABLES],
                    };
                    const CONTAINER_STRING = hljs2.inherit(STRING, {
                        variants: [
                            {
                                begin: /'/,
                                end: /'/,
                            },
                            {
                                begin: /"/,
                                end: /"/,
                            },
                            { begin: /[^\s,{}[\]]+/ },
                        ],
                    });
                    const DATE_RE = '[0-9]{4}(-[0-9][0-9]){0,2}';
                    const TIME_RE = '([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?';
                    const FRACTION_RE = '(\\.[0-9]*)?';
                    const ZONE_RE =
                        '([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?';
                    const TIMESTAMP = {
                        className: 'number',
                        begin:
                            '\\b' +
                            DATE_RE +
                            TIME_RE +
                            FRACTION_RE +
                            ZONE_RE +
                            '\\b',
                    };
                    const VALUE_CONTAINER = {
                        end: ',',
                        endsWithParent: true,
                        excludeEnd: true,
                        keywords: LITERALS,
                        relevance: 0,
                    };
                    const OBJECT = {
                        begin: /\{/,
                        end: /\}/,
                        contains: [VALUE_CONTAINER],
                        illegal: '\\n',
                        relevance: 0,
                    };
                    const ARRAY = {
                        begin: '\\[',
                        end: '\\]',
                        contains: [VALUE_CONTAINER],
                        illegal: '\\n',
                        relevance: 0,
                    };
                    const MODES2 = [
                        KEY,
                        {
                            className: 'meta',
                            begin: '^---\\s*$',
                            relevance: 10,
                        },
                        {
                            // multi line string
                            // Blocks start with a | or > followed by a newline
                            //
                            // Indentation of subsequent lines must be the same to
                            // be considered part of the block
                            className: 'string',
                            begin: '[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*',
                        },
                        {
                            // Ruby/Rails erb
                            begin: '<%[%=-]?',
                            end: '[%-]?%>',
                            subLanguage: 'ruby',
                            excludeBegin: true,
                            excludeEnd: true,
                            relevance: 0,
                        },
                        {
                            // named tags
                            className: 'type',
                            begin: '!\\w+!' + URI_CHARACTERS,
                        },
                        // https://yaml.org/spec/1.2/spec.html#id2784064
                        {
                            // verbatim tags
                            className: 'type',
                            begin: '!<' + URI_CHARACTERS + '>',
                        },
                        {
                            // primary tags
                            className: 'type',
                            begin: '!' + URI_CHARACTERS,
                        },
                        {
                            // secondary tags
                            className: 'type',
                            begin: '!!' + URI_CHARACTERS,
                        },
                        {
                            // fragment id &ref
                            className: 'meta',
                            begin: '&' + hljs2.UNDERSCORE_IDENT_RE + '$',
                        },
                        {
                            // fragment reference *ref
                            className: 'meta',
                            begin: '\\*' + hljs2.UNDERSCORE_IDENT_RE + '$',
                        },
                        {
                            // array listing
                            className: 'bullet',
                            // TODO: remove |$ hack when we have proper look-ahead support
                            begin: '-(?=[ ]|$)',
                            relevance: 0,
                        },
                        hljs2.HASH_COMMENT_MODE,
                        {
                            beginKeywords: LITERALS,
                            keywords: { literal: LITERALS },
                        },
                        TIMESTAMP,
                        // numbers are any valid C-style number that
                        // sit isolated from other words
                        {
                            className: 'number',
                            begin: hljs2.C_NUMBER_RE + '\\b',
                            relevance: 0,
                        },
                        OBJECT,
                        ARRAY,
                        STRING,
                    ];
                    const VALUE_MODES = [...MODES2];
                    VALUE_MODES.pop();
                    VALUE_MODES.push(CONTAINER_STRING);
                    VALUE_CONTAINER.contains = VALUE_MODES;
                    return {
                        name: 'YAML',
                        case_insensitive: true,
                        aliases: ['yml'],
                        contains: MODES2,
                    };
                }
                yaml_1 = yaml;
                return yaml_1;
            }
            var typescript_1;
            var hasRequiredTypescript;
            function requireTypescript() {
                if (hasRequiredTypescript) return typescript_1;
                hasRequiredTypescript = 1;
                const IDENT_RE2 = '[A-Za-z$_][0-9A-Za-z$_]*';
                const KEYWORDS = [
                    'as',
                    // for exports
                    'in',
                    'of',
                    'if',
                    'for',
                    'while',
                    'finally',
                    'var',
                    'new',
                    'function',
                    'do',
                    'return',
                    'void',
                    'else',
                    'break',
                    'catch',
                    'instanceof',
                    'with',
                    'throw',
                    'case',
                    'default',
                    'try',
                    'switch',
                    'continue',
                    'typeof',
                    'delete',
                    'let',
                    'yield',
                    'const',
                    'class',
                    // JS handles these with a special rule
                    // "get",
                    // "set",
                    'debugger',
                    'async',
                    'await',
                    'static',
                    'import',
                    'from',
                    'export',
                    'extends',
                ];
                const LITERALS = [
                    'true',
                    'false',
                    'null',
                    'undefined',
                    'NaN',
                    'Infinity',
                ];
                const TYPES = [
                    // Fundamental objects
                    'Object',
                    'Function',
                    'Boolean',
                    'Symbol',
                    // numbers and dates
                    'Math',
                    'Date',
                    'Number',
                    'BigInt',
                    // text
                    'String',
                    'RegExp',
                    // Indexed collections
                    'Array',
                    'Float32Array',
                    'Float64Array',
                    'Int8Array',
                    'Uint8Array',
                    'Uint8ClampedArray',
                    'Int16Array',
                    'Int32Array',
                    'Uint16Array',
                    'Uint32Array',
                    'BigInt64Array',
                    'BigUint64Array',
                    // Keyed collections
                    'Set',
                    'Map',
                    'WeakSet',
                    'WeakMap',
                    // Structured data
                    'ArrayBuffer',
                    'SharedArrayBuffer',
                    'Atomics',
                    'DataView',
                    'JSON',
                    // Control abstraction objects
                    'Promise',
                    'Generator',
                    'GeneratorFunction',
                    'AsyncFunction',
                    // Reflection
                    'Reflect',
                    'Proxy',
                    // Internationalization
                    'Intl',
                    // WebAssembly
                    'WebAssembly',
                ];
                const ERROR_TYPES = [
                    'Error',
                    'EvalError',
                    'InternalError',
                    'RangeError',
                    'ReferenceError',
                    'SyntaxError',
                    'TypeError',
                    'URIError',
                ];
                const BUILT_IN_GLOBALS = [
                    'setInterval',
                    'setTimeout',
                    'clearInterval',
                    'clearTimeout',
                    'require',
                    'exports',
                    'eval',
                    'isFinite',
                    'isNaN',
                    'parseFloat',
                    'parseInt',
                    'decodeURI',
                    'decodeURIComponent',
                    'encodeURI',
                    'encodeURIComponent',
                    'escape',
                    'unescape',
                ];
                const BUILT_IN_VARIABLES = [
                    'arguments',
                    'this',
                    'super',
                    'console',
                    'window',
                    'document',
                    'localStorage',
                    'sessionStorage',
                    'module',
                    'global',
                    // Node.js
                ];
                const BUILT_INS = [].concat(
                    BUILT_IN_GLOBALS,
                    TYPES,
                    ERROR_TYPES
                );
                function javascript(hljs2) {
                    const regex = hljs2.regex;
                    const hasClosingTag = (match, { after }) => {
                        const tag = '</' + match[0].slice(1);
                        const pos = match.input.indexOf(tag, after);
                        return pos !== -1;
                    };
                    const IDENT_RE$1 = IDENT_RE2;
                    const FRAGMENT = {
                        begin: '<>',
                        end: '</>',
                    };
                    const XML_SELF_CLOSING = /<[A-Za-z0-9\\._:-]+\s*\/>/;
                    const XML_TAG = {
                        begin: /<[A-Za-z0-9\\._:-]+/,
                        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
                        /**
                         * @param {RegExpMatchArray} match
                         * @param {CallbackResponse} response
                         */
                        isTrulyOpeningTag: (match, response) => {
                            const afterMatchIndex =
                                match[0].length + match.index;
                            const nextChar = match.input[afterMatchIndex];
                            if (
                                // HTML should not include another raw `<` inside a tag
                                // nested type?
                                // `<Array<Array<number>>`, etc.
                                nextChar === '<' || // the , gives away that this is not HTML
                                // `<T, A extends keyof T, V>`
                                nextChar === ','
                            ) {
                                response.ignoreMatch();
                                return;
                            }
                            if (nextChar === '>') {
                                if (
                                    !hasClosingTag(match, {
                                        after: afterMatchIndex,
                                    })
                                ) {
                                    response.ignoreMatch();
                                }
                            }
                            let m;
                            const afterMatch =
                                match.input.substring(afterMatchIndex);
                            if ((m = afterMatch.match(/^\s*=/))) {
                                response.ignoreMatch();
                                return;
                            }
                            if ((m = afterMatch.match(/^\s+extends\s+/))) {
                                if (m.index === 0) {
                                    response.ignoreMatch();
                                    return;
                                }
                            }
                        },
                    };
                    const KEYWORDS$1 = {
                        $pattern: IDENT_RE2,
                        keyword: KEYWORDS,
                        literal: LITERALS,
                        built_in: BUILT_INS,
                        'variable.language': BUILT_IN_VARIABLES,
                    };
                    const decimalDigits = '[0-9](_?[0-9])*';
                    const frac = `\\.(${decimalDigits})`;
                    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
                    const NUMBER = {
                        className: 'number',
                        variants: [
                            // DecimalLiteral
                            {
                                begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b`,
                            },
                            {
                                begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b`,
                            },
                            // DecimalBigIntegerLiteral
                            { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
                            // NonDecimalIntegerLiteral
                            {
                                begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b',
                            },
                            { begin: '\\b0[bB][0-1](_?[0-1])*n?\\b' },
                            { begin: '\\b0[oO][0-7](_?[0-7])*n?\\b' },
                            // LegacyOctalIntegerLiteral (does not include underscore separators)
                            // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
                            { begin: '\\b0[0-7]+n?\\b' },
                        ],
                        relevance: 0,
                    };
                    const SUBST = {
                        className: 'subst',
                        begin: '\\$\\{',
                        end: '\\}',
                        keywords: KEYWORDS$1,
                        contains: [],
                        // defined later
                    };
                    const HTML_TEMPLATE = {
                        begin: 'html`',
                        end: '',
                        starts: {
                            end: '`',
                            returnEnd: false,
                            contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                            subLanguage: 'xml',
                        },
                    };
                    const CSS_TEMPLATE = {
                        begin: 'css`',
                        end: '',
                        starts: {
                            end: '`',
                            returnEnd: false,
                            contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                            subLanguage: 'css',
                        },
                    };
                    const GRAPHQL_TEMPLATE = {
                        begin: 'gql`',
                        end: '',
                        starts: {
                            end: '`',
                            returnEnd: false,
                            contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                            subLanguage: 'graphql',
                        },
                    };
                    const TEMPLATE_STRING = {
                        className: 'string',
                        begin: '`',
                        end: '`',
                        contains: [hljs2.BACKSLASH_ESCAPE, SUBST],
                    };
                    const JSDOC_COMMENT = hljs2.COMMENT(
                        /\/\*\*(?!\/)/,
                        '\\*/',
                        {
                            relevance: 0,
                            contains: [
                                {
                                    begin: '(?=@[A-Za-z]+)',
                                    relevance: 0,
                                    contains: [
                                        {
                                            className: 'doctag',
                                            begin: '@[A-Za-z]+',
                                        },
                                        {
                                            className: 'type',
                                            begin: '\\{',
                                            end: '\\}',
                                            excludeEnd: true,
                                            excludeBegin: true,
                                            relevance: 0,
                                        },
                                        {
                                            className: 'variable',
                                            begin: IDENT_RE$1 + '(?=\\s*(-)|$)',
                                            endsParent: true,
                                            relevance: 0,
                                        },
                                        // eat spaces (not newlines) so we can find
                                        // types or variables
                                        {
                                            begin: /(?=[^\n])\s/,
                                            relevance: 0,
                                        },
                                    ],
                                },
                            ],
                        }
                    );
                    const COMMENT2 = {
                        className: 'comment',
                        variants: [
                            JSDOC_COMMENT,
                            hljs2.C_BLOCK_COMMENT_MODE,
                            hljs2.C_LINE_COMMENT_MODE,
                        ],
                    };
                    const SUBST_INTERNALS = [
                        hljs2.APOS_STRING_MODE,
                        hljs2.QUOTE_STRING_MODE,
                        HTML_TEMPLATE,
                        CSS_TEMPLATE,
                        GRAPHQL_TEMPLATE,
                        TEMPLATE_STRING,
                        // Skip numbers when they are part of a variable name
                        { match: /\$\d+/ },
                        NUMBER,
                        // This is intentional:
                        // See https://github.com/highlightjs/highlight.js/issues/3288
                        // hljs.REGEXP_MODE
                    ];
                    SUBST.contains = SUBST_INTERNALS.concat({
                        // we need to pair up {} inside our subst to prevent
                        // it from ending too early by matching another }
                        begin: /\{/,
                        end: /\}/,
                        keywords: KEYWORDS$1,
                        contains: ['self'].concat(SUBST_INTERNALS),
                    });
                    const SUBST_AND_COMMENTS = [].concat(
                        COMMENT2,
                        SUBST.contains
                    );
                    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
                        // eat recursive parens in sub expressions
                        {
                            begin: /\(/,
                            end: /\)/,
                            keywords: KEYWORDS$1,
                            contains: ['self'].concat(SUBST_AND_COMMENTS),
                        },
                    ]);
                    const PARAMS = {
                        className: 'params',
                        begin: /\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS$1,
                        contains: PARAMS_CONTAINS,
                    };
                    const CLASS_OR_EXTENDS = {
                        variants: [
                            // class Car extends vehicle
                            {
                                match: [
                                    /class/,
                                    /\s+/,
                                    IDENT_RE$1,
                                    /\s+/,
                                    /extends/,
                                    /\s+/,
                                    regex.concat(
                                        IDENT_RE$1,
                                        '(',
                                        regex.concat(/\./, IDENT_RE$1),
                                        ')*'
                                    ),
                                ],
                                scope: {
                                    1: 'keyword',
                                    3: 'title.class',
                                    5: 'keyword',
                                    7: 'title.class.inherited',
                                },
                            },
                            // class Car
                            {
                                match: [/class/, /\s+/, IDENT_RE$1],
                                scope: {
                                    1: 'keyword',
                                    3: 'title.class',
                                },
                            },
                        ],
                    };
                    const CLASS_REFERENCE = {
                        relevance: 0,
                        match: regex.either(
                            // Hard coded exceptions
                            /\bJSON/,
                            // Float32Array, OutT
                            /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
                            // CSSFactory, CSSFactoryT
                            /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
                            // FPs, FPsT
                            /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
                            // P
                            // single letters are not highlighted
                            // BLAH
                            // this will be flagged as a UPPER_CASE_CONSTANT instead
                        ),
                        className: 'title.class',
                        keywords: {
                            _: [
                                // se we still get relevance credit for JS library classes
                                ...TYPES,
                                ...ERROR_TYPES,
                            ],
                        },
                    };
                    const USE_STRICT = {
                        label: 'use_strict',
                        className: 'meta',
                        relevance: 10,
                        begin: /^\s*['"]use (strict|asm)['"]/,
                    };
                    const FUNCTION_DEFINITION = {
                        variants: [
                            {
                                match: [
                                    /function/,
                                    /\s+/,
                                    IDENT_RE$1,
                                    /(?=\s*\()/,
                                ],
                            },
                            // anonymous function
                            {
                                match: [/function/, /\s*(?=\()/],
                            },
                        ],
                        className: {
                            1: 'keyword',
                            3: 'title.function',
                        },
                        label: 'func.def',
                        contains: [PARAMS],
                        illegal: /%/,
                    };
                    const UPPER_CASE_CONSTANT = {
                        relevance: 0,
                        match: /\b[A-Z][A-Z_0-9]+\b/,
                        className: 'variable.constant',
                    };
                    function noneOf(list2) {
                        return regex.concat('(?!', list2.join('|'), ')');
                    }
                    const FUNCTION_CALL = {
                        match: regex.concat(
                            /\b/,
                            noneOf([...BUILT_IN_GLOBALS, 'super', 'import']),
                            IDENT_RE$1,
                            regex.lookahead(/\(/)
                        ),
                        className: 'title.function',
                        relevance: 0,
                    };
                    const PROPERTY_ACCESS = {
                        begin: regex.concat(
                            /\./,
                            regex.lookahead(
                                regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)
                            )
                        ),
                        end: IDENT_RE$1,
                        excludeBegin: true,
                        keywords: 'prototype',
                        className: 'property',
                        relevance: 0,
                    };
                    const GETTER_OR_SETTER = {
                        match: [/get|set/, /\s+/, IDENT_RE$1, /(?=\()/],
                        className: {
                            1: 'keyword',
                            3: 'title.function',
                        },
                        contains: [
                            {
                                // eat to avoid empty params
                                begin: /\(\)/,
                            },
                            PARAMS,
                        ],
                    };
                    const FUNC_LEAD_IN_RE =
                        '(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|' +
                        hljs2.UNDERSCORE_IDENT_RE +
                        ')\\s*=>';
                    const FUNCTION_VARIABLE = {
                        match: [
                            /const|var|let/,
                            /\s+/,
                            IDENT_RE$1,
                            /\s*/,
                            /=\s*/,
                            /(async\s*)?/,
                            // async is optional
                            regex.lookahead(FUNC_LEAD_IN_RE),
                        ],
                        keywords: 'async',
                        className: {
                            1: 'keyword',
                            3: 'title.function',
                        },
                        contains: [PARAMS],
                    };
                    return {
                        name: 'JavaScript',
                        aliases: ['js', 'jsx', 'mjs', 'cjs'],
                        keywords: KEYWORDS$1,
                        // this will be extended by TypeScript
                        exports: { PARAMS_CONTAINS, CLASS_REFERENCE },
                        illegal: /#(?![$_A-z])/,
                        contains: [
                            hljs2.SHEBANG({
                                label: 'shebang',
                                binary: 'node',
                                relevance: 5,
                            }),
                            USE_STRICT,
                            hljs2.APOS_STRING_MODE,
                            hljs2.QUOTE_STRING_MODE,
                            HTML_TEMPLATE,
                            CSS_TEMPLATE,
                            GRAPHQL_TEMPLATE,
                            TEMPLATE_STRING,
                            COMMENT2,
                            // Skip numbers when they are part of a variable name
                            { match: /\$\d+/ },
                            NUMBER,
                            CLASS_REFERENCE,
                            {
                                className: 'attr',
                                begin: IDENT_RE$1 + regex.lookahead(':'),
                                relevance: 0,
                            },
                            FUNCTION_VARIABLE,
                            {
                                // "value" container
                                begin:
                                    '(' +
                                    hljs2.RE_STARTERS_RE +
                                    '|\\b(case|return|throw)\\b)\\s*',
                                keywords: 'return throw case',
                                relevance: 0,
                                contains: [
                                    COMMENT2,
                                    hljs2.REGEXP_MODE,
                                    {
                                        className: 'function',
                                        // we have to count the parens to make sure we actually have the
                                        // correct bounding ( ) before the =>.  There could be any number of
                                        // sub-expressions inside also surrounded by parens.
                                        begin: FUNC_LEAD_IN_RE,
                                        returnBegin: true,
                                        end: '\\s*=>',
                                        contains: [
                                            {
                                                className: 'params',
                                                variants: [
                                                    {
                                                        begin: hljs2.UNDERSCORE_IDENT_RE,
                                                        relevance: 0,
                                                    },
                                                    {
                                                        className: null,
                                                        begin: /\(\s*\)/,
                                                        skip: true,
                                                    },
                                                    {
                                                        begin: /\(/,
                                                        end: /\)/,
                                                        excludeBegin: true,
                                                        excludeEnd: true,
                                                        keywords: KEYWORDS$1,
                                                        contains:
                                                            PARAMS_CONTAINS,
                                                    },
                                                ],
                                            },
                                        ],
                                    },
                                    {
                                        // could be a comma delimited list of params to a function call
                                        begin: /,/,
                                        relevance: 0,
                                    },
                                    {
                                        match: /\s+/,
                                        relevance: 0,
                                    },
                                    {
                                        // JSX
                                        variants: [
                                            {
                                                begin: FRAGMENT.begin,
                                                end: FRAGMENT.end,
                                            },
                                            { match: XML_SELF_CLOSING },
                                            {
                                                begin: XML_TAG.begin,
                                                // we carefully check the opening tag to see if it truly
                                                // is a tag and not a false positive
                                                'on:begin':
                                                    XML_TAG.isTrulyOpeningTag,
                                                end: XML_TAG.end,
                                            },
                                        ],
                                        subLanguage: 'xml',
                                        contains: [
                                            {
                                                begin: XML_TAG.begin,
                                                end: XML_TAG.end,
                                                skip: true,
                                                contains: ['self'],
                                            },
                                        ],
                                    },
                                ],
                            },
                            FUNCTION_DEFINITION,
                            {
                                // prevent this from getting swallowed up by function
                                // since they appear "function like"
                                beginKeywords: 'while if switch catch for',
                            },
                            {
                                // we have to count the parens to make sure we actually have the correct
                                // bounding ( ).  There could be any number of sub-expressions inside
                                // also surrounded by parens.
                                begin:
                                    '\\b(?!function)' +
                                    hljs2.UNDERSCORE_IDENT_RE +
                                    '\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{',
                                // end parens
                                returnBegin: true,
                                label: 'func.def',
                                contains: [
                                    PARAMS,
                                    hljs2.inherit(hljs2.TITLE_MODE, {
                                        begin: IDENT_RE$1,
                                        className: 'title.function',
                                    }),
                                ],
                            },
                            // catch ... so it won't trigger the property rule below
                            {
                                match: /\.\.\./,
                                relevance: 0,
                            },
                            PROPERTY_ACCESS,
                            // hack: prevents detection of keywords in some circumstances
                            // .keyword()
                            // $keyword = x
                            {
                                match: '\\$' + IDENT_RE$1,
                                relevance: 0,
                            },
                            {
                                match: [/\bconstructor(?=\s*\()/],
                                className: { 1: 'title.function' },
                                contains: [PARAMS],
                            },
                            FUNCTION_CALL,
                            UPPER_CASE_CONSTANT,
                            CLASS_OR_EXTENDS,
                            GETTER_OR_SETTER,
                            {
                                match: /\$[(.]/,
                                // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
                            },
                        ],
                    };
                }
                function typescript(hljs2) {
                    const tsLanguage = javascript(hljs2);
                    const IDENT_RE$1 = IDENT_RE2;
                    const TYPES2 = [
                        'any',
                        'void',
                        'number',
                        'boolean',
                        'string',
                        'object',
                        'never',
                        'symbol',
                        'bigint',
                        'unknown',
                    ];
                    const NAMESPACE = {
                        beginKeywords: 'namespace',
                        end: /\{/,
                        excludeEnd: true,
                        contains: [tsLanguage.exports.CLASS_REFERENCE],
                    };
                    const INTERFACE = {
                        beginKeywords: 'interface',
                        end: /\{/,
                        excludeEnd: true,
                        keywords: {
                            keyword: 'interface extends',
                            built_in: TYPES2,
                        },
                        contains: [tsLanguage.exports.CLASS_REFERENCE],
                    };
                    const USE_STRICT = {
                        className: 'meta',
                        relevance: 10,
                        begin: /^\s*['"]use strict['"]/,
                    };
                    const TS_SPECIFIC_KEYWORDS = [
                        'type',
                        'namespace',
                        'interface',
                        'public',
                        'private',
                        'protected',
                        'implements',
                        'declare',
                        'abstract',
                        'readonly',
                        'enum',
                        'override',
                    ];
                    const KEYWORDS$1 = {
                        $pattern: IDENT_RE2,
                        keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),
                        literal: LITERALS,
                        built_in: BUILT_INS.concat(TYPES2),
                        'variable.language': BUILT_IN_VARIABLES,
                    };
                    const DECORATOR = {
                        className: 'meta',
                        begin: '@' + IDENT_RE$1,
                    };
                    const swapMode = (mode, label, replacement) => {
                        const indx = mode.contains.findIndex(
                            (m) => m.label === label
                        );
                        if (indx === -1) {
                            throw new Error('can not find mode to replace');
                        }
                        mode.contains.splice(indx, 1, replacement);
                    };
                    Object.assign(tsLanguage.keywords, KEYWORDS$1);
                    tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
                    tsLanguage.contains = tsLanguage.contains.concat([
                        DECORATOR,
                        NAMESPACE,
                        INTERFACE,
                    ]);
                    swapMode(tsLanguage, 'shebang', hljs2.SHEBANG());
                    swapMode(tsLanguage, 'use_strict', USE_STRICT);
                    const functionDeclaration = tsLanguage.contains.find(
                        (m) => m.label === 'func.def'
                    );
                    functionDeclaration.relevance = 0;
                    Object.assign(tsLanguage, {
                        name: 'TypeScript',
                        aliases: ['ts', 'tsx', 'mts', 'cts'],
                    });
                    return tsLanguage;
                }
                typescript_1 = typescript;
                return typescript_1;
            }
            var vbnet_1;
            var hasRequiredVbnet;
            function requireVbnet() {
                if (hasRequiredVbnet) return vbnet_1;
                hasRequiredVbnet = 1;
                function vbnet(hljs2) {
                    const regex = hljs2.regex;
                    const CHARACTER = {
                        className: 'string',
                        begin: /"(""|[^/n])"C\b/,
                    };
                    const STRING = {
                        className: 'string',
                        begin: /"/,
                        end: /"/,
                        illegal: /\n/,
                        contains: [
                            {
                                // double quote escape
                                begin: /""/,
                            },
                        ],
                    };
                    const MM_DD_YYYY = /\d{1,2}\/\d{1,2}\/\d{4}/;
                    const YYYY_MM_DD = /\d{4}-\d{1,2}-\d{1,2}/;
                    const TIME_12H = /(\d|1[012])(:\d+){0,2} *(AM|PM)/;
                    const TIME_24H = /\d{1,2}(:\d{1,2}){1,2}/;
                    const DATE = {
                        className: 'literal',
                        variants: [
                            {
                                // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
                                begin: regex.concat(
                                    /# */,
                                    regex.either(YYYY_MM_DD, MM_DD_YYYY),
                                    / *#/
                                ),
                            },
                            {
                                // #H:mm[:ss]# (24h Time)
                                begin: regex.concat(/# */, TIME_24H, / *#/),
                            },
                            {
                                // #h[:mm[:ss]] A# (12h Time)
                                begin: regex.concat(/# */, TIME_12H, / *#/),
                            },
                            {
                                // date plus time
                                begin: regex.concat(
                                    /# */,
                                    regex.either(YYYY_MM_DD, MM_DD_YYYY),
                                    / +/,
                                    regex.either(TIME_12H, TIME_24H),
                                    / *#/
                                ),
                            },
                        ],
                    };
                    const NUMBER = {
                        className: 'number',
                        relevance: 0,
                        variants: [
                            {
                                // Float
                                begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/,
                            },
                            {
                                // Integer (base 10)
                                begin: /\b\d[\d_]*((U?[SIL])|[%&])?/,
                            },
                            {
                                // Integer (base 16)
                                begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/,
                            },
                            {
                                // Integer (base 8)
                                begin: /&O[0-7_]+((U?[SIL])|[%&])?/,
                            },
                            {
                                // Integer (base 2)
                                begin: /&B[01_]+((U?[SIL])|[%&])?/,
                            },
                        ],
                    };
                    const LABEL = {
                        className: 'label',
                        begin: /^\w+:/,
                    };
                    const DOC_COMMENT = hljs2.COMMENT(/'''/, /$/, {
                        contains: [
                            {
                                className: 'doctag',
                                begin: /<\/?/,
                                end: />/,
                            },
                        ],
                    });
                    const COMMENT2 = hljs2.COMMENT(null, /$/, {
                        variants: [
                            { begin: /'/ },
                            {
                                // TODO: Use multi-class for leading spaces
                                begin: /([\t ]|^)REM(?=\s)/,
                            },
                        ],
                    });
                    const DIRECTIVES = {
                        className: 'meta',
                        // TODO: Use multi-class for indentation once available
                        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
                        end: /$/,
                        keywords: {
                            keyword:
                                'const disable else elseif enable end externalsource if region then',
                        },
                        contains: [COMMENT2],
                    };
                    return {
                        name: 'Visual Basic .NET',
                        aliases: ['vb'],
                        case_insensitive: true,
                        classNameAliases: { label: 'symbol' },
                        keywords: {
                            keyword:
                                'addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield',
                            built_in:
                                // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
                                'addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort',
                            type:
                                // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
                                'boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort',
                            literal: 'true false nothing',
                        },
                        illegal: '//|\\{|\\}|endif|gosub|variant|wend|^\\$ ',
                        contains: [
                            CHARACTER,
                            STRING,
                            DATE,
                            NUMBER,
                            LABEL,
                            DOC_COMMENT,
                            COMMENT2,
                            DIRECTIVES,
                        ],
                    };
                }
                vbnet_1 = vbnet;
                return vbnet_1;
            }
            var wasm_1;
            var hasRequiredWasm;
            function requireWasm() {
                if (hasRequiredWasm) return wasm_1;
                hasRequiredWasm = 1;
                function wasm(hljs2) {
                    hljs2.regex;
                    const BLOCK_COMMENT = hljs2.COMMENT(/\(;/, /;\)/);
                    BLOCK_COMMENT.contains.push('self');
                    const LINE_COMMENT = hljs2.COMMENT(/;;/, /$/);
                    const KWS = [
                        'anyfunc',
                        'block',
                        'br',
                        'br_if',
                        'br_table',
                        'call',
                        'call_indirect',
                        'data',
                        'drop',
                        'elem',
                        'else',
                        'end',
                        'export',
                        'func',
                        'global.get',
                        'global.set',
                        'local.get',
                        'local.set',
                        'local.tee',
                        'get_global',
                        'get_local',
                        'global',
                        'if',
                        'import',
                        'local',
                        'loop',
                        'memory',
                        'memory.grow',
                        'memory.size',
                        'module',
                        'mut',
                        'nop',
                        'offset',
                        'param',
                        'result',
                        'return',
                        'select',
                        'set_global',
                        'set_local',
                        'start',
                        'table',
                        'tee_local',
                        'then',
                        'type',
                        'unreachable',
                    ];
                    const FUNCTION_REFERENCE = {
                        begin: [
                            /(?:func|call|call_indirect)/,
                            /\s+/,
                            /\$[^\s)]+/,
                        ],
                        className: {
                            1: 'keyword',
                            3: 'title.function',
                        },
                    };
                    const ARGUMENT = {
                        className: 'variable',
                        begin: /\$[\w_]+/,
                    };
                    const PARENS = {
                        match: /(\((?!;)|\))+/,
                        className: 'punctuation',
                        relevance: 0,
                    };
                    const NUMBER = {
                        className: 'number',
                        relevance: 0,
                        // borrowed from Prism, TODO: split out into variants
                        match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
                    };
                    const TYPE = {
                        // look-ahead prevents us from gobbling up opcodes
                        match: /(i32|i64|f32|f64)(?!\.)/,
                        className: 'type',
                    };
                    const MATH_OPERATIONS = {
                        className: 'keyword',
                        // borrowed from Prism, TODO: split out into variants
                        match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/,
                    };
                    const OFFSET_ALIGN = {
                        match: [/(?:offset|align)/, /\s*/, /=/],
                        className: {
                            1: 'keyword',
                            3: 'operator',
                        },
                    };
                    return {
                        name: 'WebAssembly',
                        keywords: {
                            $pattern: /[\w.]+/,
                            keyword: KWS,
                        },
                        contains: [
                            LINE_COMMENT,
                            BLOCK_COMMENT,
                            OFFSET_ALIGN,
                            ARGUMENT,
                            PARENS,
                            FUNCTION_REFERENCE,
                            hljs2.QUOTE_STRING_MODE,
                            TYPE,
                            MATH_OPERATIONS,
                            NUMBER,
                        ],
                    };
                }
                wasm_1 = wasm;
                return wasm_1;
            }
            var hljs = core;
            hljs.registerLanguage('xml', requireXml());
            hljs.registerLanguage('bash', requireBash());
            hljs.registerLanguage('c', requireC());
            hljs.registerLanguage('cpp', requireCpp());
            hljs.registerLanguage('csharp', requireCsharp());
            hljs.registerLanguage('css', requireCss());
            hljs.registerLanguage('markdown', requireMarkdown());
            hljs.registerLanguage('diff', requireDiff());
            hljs.registerLanguage('ruby', requireRuby());
            hljs.registerLanguage('go', requireGo());
            hljs.registerLanguage('graphql', requireGraphql());
            hljs.registerLanguage('ini', requireIni());
            hljs.registerLanguage('java', requireJava());
            hljs.registerLanguage('javascript', requireJavascript());
            hljs.registerLanguage('json', requireJson());
            hljs.registerLanguage('kotlin', requireKotlin());
            hljs.registerLanguage('less', requireLess());
            hljs.registerLanguage('lua', requireLua());
            hljs.registerLanguage('makefile', requireMakefile());
            hljs.registerLanguage('perl', requirePerl());
            hljs.registerLanguage('objectivec', requireObjectivec());
            hljs.registerLanguage('php', requirePhp());
            hljs.registerLanguage('php-template', requirePhpTemplate());
            hljs.registerLanguage('plaintext', requirePlaintext());
            hljs.registerLanguage('python', requirePython());
            hljs.registerLanguage('python-repl', requirePythonRepl());
            hljs.registerLanguage('r', requireR());
            hljs.registerLanguage('rust', requireRust());
            hljs.registerLanguage('scss', requireScss());
            hljs.registerLanguage('shell', requireShell());
            hljs.registerLanguage('sql', requireSql());
            hljs.registerLanguage('swift', requireSwift());
            hljs.registerLanguage('yaml', requireYaml());
            hljs.registerLanguage('typescript', requireTypescript());
            hljs.registerLanguage('vbnet', requireVbnet());
            hljs.registerLanguage('wasm', requireWasm());
            hljs.HighlightJS = hljs;
            hljs.default = hljs;
            var common = hljs;
            const HighlightJS = /* @__PURE__ */ getDefaultExportFromCjs(common);
            const MAIN_GAP = 1;
            const BOX_PADDING = 1;
            const ARROW_SIZE = 3;
            const ADDITIONAL_SPACE =
                (BOX_PADDING * 2 + MAIN_GAP) * 2 + ARROW_SIZE;
            class CodeExplorerComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-code-explorer');
                    element2.innerHTML = `
            <div class="rio-code-explorer-source-code"></div>
            <div class="rio-code-explorer-arrow"></div>
            <div class="rio-code-explorer-build-result"></div>
        `;
                    this.sourceHighlighterElement =
                        document.createElement('div');
                    this.sourceHighlighterElement.classList.add(
                        'rio-code-explorer-highlighter'
                    );
                    this.resultHighlighterElement =
                        document.createElement('div');
                    this.resultHighlighterElement.classList.add(
                        'rio-code-explorer-highlighter'
                    );
                    [
                        this.sourceCodeElement,
                        this.arrowElement,
                        this.buildResultElement,
                    ] = Array.from(element2.children);
                    this.sourceCodeElement.style.padding = `${BOX_PADDING}rem`;
                    element2.style.gap = `${MAIN_GAP}rem`;
                    this.arrowElement.style.width = `${ARROW_SIZE}rem`;
                    this.arrowElement.style.height = `${ARROW_SIZE}rem`;
                    applyIcon(
                        this.arrowElement,
                        'material/arrow-right-alt:fill',
                        'var(--rio-global-secondary-bg)'
                    );
                    this.buildResultElement.addEventListener(
                        'mousemove',
                        this.onResultMouseMove.bind(this),
                        { capture: true }
                    );
                    this.buildResultElement.addEventListener(
                        'mouseleave',
                        () => {
                            this._highlightComponentByKey(null);
                        }
                    );
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.source_code !== void 0) {
                        let hlResult = HighlightJS.highlight(
                            deltaState.source_code,
                            {
                                language: 'python',
                                ignoreIllegals: true,
                            }
                        );
                        this.sourceCodeElement.innerHTML = hlResult.value;
                        this.sourceCodeDimensions = getElementDimensions(
                            this.sourceCodeElement
                        );
                        this._connectHighlightEventListeners();
                        this.sourceCodeElement.appendChild(
                            this.sourceHighlighterElement
                        );
                    }
                    if (deltaState.build_result !== void 0) {
                        this.resultHighlighterElement.remove();
                        this.replaceFirstChild(
                            latentComponents,
                            deltaState.build_result,
                            this.buildResultElement
                        );
                        let buildResultElement =
                            componentsById[deltaState.build_result];
                        buildResultElement.element.style.removeProperty('left');
                        buildResultElement.element.style.removeProperty('top');
                        this.buildResultElement.appendChild(
                            this.resultHighlighterElement
                        );
                    }
                }
                _connectHighlightEventListeners() {
                    let lineIndex = 0;
                    let elementsBefore = Array.from(
                        this.sourceCodeElement.childNodes
                    );
                    this.sourceCodeElement.innerHTML = '';
                    for (let element2 of elementsBefore) {
                        let multiSpan;
                        if (element2 instanceof Text) {
                            let span = document.createElement('span');
                            span.textContent = element2.textContent;
                            multiSpan = span;
                        } else {
                            console.assert(element2 instanceof HTMLSpanElement);
                            multiSpan = element2;
                        }
                        let lines = multiSpan.textContent.split('\n');
                        for (let ii = 0; ii < lines.length; ii++) {
                            if (ii !== 0) {
                                lineIndex += 1;
                                this.sourceCodeElement.appendChild(
                                    document.createTextNode('\n')
                                );
                            }
                            let singleSpan = multiSpan.cloneNode();
                            singleSpan.innerText = lines[ii];
                            singleSpan.dataset.lineIndex = lineIndex.toString();
                            this.sourceCodeElement.appendChild(singleSpan);
                            ((currentLineIndex) => {
                                singleSpan.addEventListener(
                                    'mouseenter',
                                    () => {
                                        this.onLineEntered(currentLineIndex);
                                    }
                                );
                            })(lineIndex);
                            singleSpan.addEventListener('mouseleave', () => {
                                this.onLineEntered(null);
                            });
                            singleSpan.style.cursor = 'crosshair';
                        }
                    }
                }
                onLineEntered(lineIndex) {
                    let key = null;
                    if (lineIndex !== null) {
                        key =
                            this.state.line_indices_to_component_keys[
                                lineIndex
                            ];
                    }
                    this._highlightComponentByKey(key);
                }
                onResultMouseMove(event) {
                    let curElement = event.target;
                    let targetComponent = void 0;
                    while (true) {
                        targetComponent = componentsByElement.get(curElement);
                        if (
                            targetComponent !== void 0 &&
                            targetComponent.state._key_ !== null
                        ) {
                            break;
                        }
                        curElement = curElement.parentElement;
                    }
                    this._highlightComponentByKey(targetComponent.state._key_);
                }
                _highlightComponentByKey(key) {
                    if (key === null) {
                        this.sourceHighlighterElement.style.opacity = '0';
                        this.resultHighlighterElement.style.opacity = '0';
                        return;
                    }
                    let firstLineIndex = 999999,
                        lastLineIndex = -1;
                    for (
                        let ii = 0;
                        ii < this.state.line_indices_to_component_keys.length;
                        ii++
                    ) {
                        if (
                            this.state.line_indices_to_component_keys[ii] ===
                            key
                        ) {
                            firstLineIndex = Math.min(firstLineIndex, ii);
                            lastLineIndex = Math.max(lastLineIndex, ii);
                        }
                    }
                    this._highlightLines(firstLineIndex, lastLineIndex);
                    this._highlightKey(key);
                }
                _highlightLines(firstLineIndex, lastLineIndex) {
                    let top = 99999,
                        bottom = -1;
                    for (let child of this.sourceCodeElement.children) {
                        if (!(child instanceof HTMLSpanElement)) {
                            continue;
                        }
                        let lineIndex = parseInt(child.dataset.lineIndex);
                        if (
                            lineIndex < firstLineIndex ||
                            lineIndex > lastLineIndex
                        ) {
                            continue;
                        }
                        let childRect = child.getBoundingClientRect();
                        top = Math.min(top, childRect.top);
                        bottom = Math.max(bottom, childRect.bottom);
                    }
                    let sourceCodeRect =
                        this.sourceCodeElement.getBoundingClientRect();
                    top -= sourceCodeRect.top;
                    bottom -= sourceCodeRect.top;
                    this.sourceHighlighterElement.style.left = `0`;
                    this.sourceHighlighterElement.style.top = `${top}px`;
                    this.sourceHighlighterElement.style.right = `0`;
                    this.sourceHighlighterElement.style.height = `${bottom - top}px`;
                    this.sourceHighlighterElement.style.opacity = '1';
                }
                _highlightKey(key) {
                    let targetComponent;
                    if (key !== null) {
                        targetComponent = this.findComponentByKey(
                            componentsById[this.state.build_result],
                            key
                        );
                        if (targetComponent === null) {
                            console.error(
                                `CodeExplorer could not find component with key ${key}`
                            );
                            return;
                        }
                    }
                    let rootRect =
                        this.buildResultElement.getBoundingClientRect();
                    let targetRect =
                        targetComponent.element.getBoundingClientRect();
                    getComputedStyle(this.resultHighlighterElement).opacity ==
                        '0';
                    this.resultHighlighterElement.style.left = `${targetRect.left - rootRect.left}px`;
                    this.resultHighlighterElement.style.top = `${targetRect.top - rootRect.top}px`;
                    this.resultHighlighterElement.style.width = `${targetRect.width}px`;
                    this.resultHighlighterElement.style.height = `${targetRect.height}px`;
                    this.resultHighlighterElement.style.opacity = '1';
                }
                findComponentByKey(currentComponent, key) {
                    if (currentComponent.state._key_ === key) {
                        return currentComponent;
                    }
                    for (let child of currentComponent.children) {
                        let result = this.findComponentByKey(child, key);
                        if (result !== null) {
                            return result;
                        }
                    }
                    return null;
                }
                updateNaturalWidth(ctx) {
                    let buildResultElement =
                        componentsById[this.state.build_result];
                    this.naturalWidth =
                        this.sourceCodeDimensions[0] +
                        ADDITIONAL_SPACE +
                        buildResultElement.requestedWidth;
                }
                updateAllocatedWidth(ctx) {
                    let buildResultElement =
                        componentsById[this.state.build_result];
                    buildResultElement.allocatedWidth =
                        buildResultElement.requestedWidth;
                }
                updateNaturalHeight(ctx) {
                    let buildResultElement =
                        componentsById[this.state.build_result];
                    this.naturalHeight = Math.max(
                        this.sourceCodeDimensions[1],
                        buildResultElement.requestedHeight
                    );
                }
                updateAllocatedHeight(ctx) {
                    let buildResultElement =
                        componentsById[this.state.build_result];
                    buildResultElement.allocatedHeight =
                        buildResultElement.requestedHeight;
                }
            }
            function hsvToRgb(h, s, v) {
                let i = Math.floor(h / 60);
                let f = h / 60 - i;
                let p = v * (1 - s);
                let q = v * (1 - f * s);
                let t = v * (1 - (1 - f) * s);
                let r, g, b;
                switch (i % 6) {
                    case 0:
                        (r = v), (g = t), (b = p);
                        break;
                    case 1:
                        (r = q), (g = v), (b = p);
                        break;
                    case 2:
                        (r = p), (g = v), (b = t);
                        break;
                    case 3:
                        (r = p), (g = q), (b = v);
                        break;
                    case 4:
                        (r = t), (g = p), (b = v);
                        break;
                    case 5:
                        (r = v), (g = p), (b = q);
                        break;
                }
                return [r, g, b];
            }
            function rgbToHsv(r, g, b) {
                let max = Math.max(r, g, b);
                let min = Math.min(r, g, b);
                let d = max - min;
                let s = max === 0 ? 0 : d / max;
                let h;
                switch (max) {
                    case min:
                        h = 0;
                        break;
                    case r:
                        h = g - b + d * (g < b ? 6 : 0);
                        h /= 6 * d;
                        break;
                    case g:
                        h = b - r + d * 2;
                        h /= 6 * d;
                        break;
                    case b:
                        h = r - g + d * 4;
                        h /= 6 * d;
                        break;
                }
                return [h * 360, s, max];
            }
            function rgbToHex(r, g, b) {
                const rHex = Math.floor(r * 255)
                    .toString(16)
                    .padStart(2, '0');
                const gHex = Math.floor(g * 255)
                    .toString(16)
                    .padStart(2, '0');
                const bHex = Math.floor(b * 255)
                    .toString(16)
                    .padStart(2, '0');
                return `${rHex}${gHex}${bHex}`;
            }
            function rgbaToHex(r, g, b, a) {
                const rHex = Math.floor(r * 255)
                    .toString(16)
                    .padStart(2, '0');
                const gHex = Math.floor(g * 255)
                    .toString(16)
                    .padStart(2, '0');
                const bHex = Math.floor(b * 255)
                    .toString(16)
                    .padStart(2, '0');
                const aHex = Math.floor(a * 255)
                    .toString(16)
                    .padStart(2, '0');
                return `${rHex}${gHex}${bHex}${aHex}`;
            }
            class ColorPickerComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.selectedHsv = [0, 0, 0];
                    this.latentEventHandlers = [];
                    this.isInitialized = false;
                }
                createElement() {
                    let containerElement = document.createElement('div');
                    containerElement.classList.add('rio-color-picker');
                    containerElement.innerHTML = `
        <div class="rio-color-picker-color-square">
            <div class="rio-color-picker-knob"></div>
        </div>

        <div class="rio-color-picker-hue-bar rio-color-picker-slider-outer">
            <div class="rio-color-slider-inner"></div>
            <div class="rio-color-picker-knob"></div>
        </div>

        <div class="rio-color-picker-opacity-bar rio-color-picker-slider-outer">
            <div class="rio-color-slider-inner"></div>
            <div class="rio-color-slider-inner rio-checkered"></div>
            <div class="rio-color-picker-knob"></div>
        </div>

        <div class="rio-color-picker-result-container">
            <div class="rio-color-picker-selected-color-circle">
                <div></div>
                <div class="rio-checkered"></div>
            </div>
            <input type='text' class="rio-color-picker-selected-color-label" value="dummy" />
        </div>`;
                    this.colorSquare = containerElement.querySelector(
                        '.rio-color-picker-color-square'
                    );
                    this.squareKnob = this.colorSquare.querySelector(
                        '.rio-color-picker-knob'
                    );
                    this.hueBarOuter = containerElement.querySelector(
                        '.rio-color-picker-hue-bar'
                    );
                    this.hueBarInner = this.hueBarOuter.querySelector(
                        '.rio-color-slider-inner'
                    );
                    this.hueIndicator = this.hueBarOuter.querySelector(
                        '.rio-color-picker-knob'
                    );
                    this.opacityBarOuter = containerElement.querySelector(
                        '.rio-color-picker-opacity-bar'
                    );
                    this.opacityBarInner = this.opacityBarOuter.querySelector(
                        '.rio-color-slider-inner'
                    );
                    this.opacityIndicator = this.opacityBarOuter.querySelector(
                        '.rio-color-picker-knob'
                    );
                    this.selectedColorLabel = containerElement.querySelector(
                        '.rio-color-picker-selected-color-label'
                    );
                    this.colorSquare.addEventListener(
                        'mousedown',
                        this.onSquareMouseDown.bind(this)
                    );
                    this.hueBarOuter.addEventListener(
                        'mousedown',
                        this.onHueBarMouseDown.bind(this)
                    );
                    this.opacityBarOuter.addEventListener(
                        'mousedown',
                        this.onOpacityBarMouseDown.bind(this)
                    );
                    this.selectedColorLabel.addEventListener(
                        'change',
                        this.setFromUserHex.bind(this)
                    );
                    return containerElement;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.color !== void 0) {
                        let rgbChanged =
                            deltaState.color[0] !== this.state.color[0] ||
                            deltaState.color[1] !== this.state.color[1] ||
                            deltaState.color[2] !== this.state.color[2];
                        if (rgbChanged || !this.isInitialized) {
                            this.selectedHsv = rgbToHsv(
                                deltaState.color[0],
                                deltaState.color[1],
                                deltaState.color[2]
                            );
                        }
                    }
                    if (deltaState.pick_opacity === true) {
                        this.opacityBarOuter.style.display = 'block';
                    } else if (deltaState.pick_opacity === false) {
                        this.opacityBarOuter.style.display = 'none';
                        if (this.state.color !== void 0) {
                            this.state.color[3] = 1;
                        }
                    }
                    this.matchComponentToSelectedHsv();
                    this.isInitialized = true;
                }
                matchComponentToSelectedHsv() {
                    let [r, g, b] = hsvToRgb(
                        this.selectedHsv[0],
                        this.selectedHsv[1],
                        this.selectedHsv[2]
                    );
                    this.state.color[0] = r;
                    this.state.color[1] = g;
                    this.state.color[2] = b;
                    let rgbHex = rgbToHex(r, g, b);
                    let rgbaHex = rgbaToHex(r, g, b, this.state.color[3]);
                    let element2 = this.element;
                    element2.style.setProperty(
                        '--chosen-color-opaque',
                        `#${rgbHex}`
                    );
                    element2.style.setProperty(
                        '--chosen-color-transparent',
                        `#${rgbaHex}`
                    );
                    let onlyHueRgb = hsvToRgb(this.selectedHsv[0], 1, 1);
                    let hueHex = rgbToHex(
                        onlyHueRgb[0],
                        onlyHueRgb[1],
                        onlyHueRgb[2]
                    );
                    this.colorSquare.style.background = `
            linear-gradient(
                to top,
                black,
                transparent
            ),
            linear-gradient(
                to right,
                white,
                #${hueHex}
            )`;
                    this.hueIndicator.style.background = `#${hueHex}`;
                    const saturationX = this.selectedHsv[1];
                    const brightnessY = 1 - this.selectedHsv[2];
                    this.squareKnob.style.left = `${saturationX * 100}%`;
                    this.squareKnob.style.top = `${brightnessY * 100}%`;
                    const hueX = this.selectedHsv[0] / 360;
                    this.hueIndicator.style.left = `${hueX * 100}%`;
                    const opacityX = this.state.color[3];
                    this.opacityIndicator.style.left = `${opacityX * 100}%`;
                    this.selectedColorLabel.value = this.state.pick_opacity
                        ? rgbaHex
                        : rgbHex;
                }
                updateSaturationBrightness(x, y) {
                    const boundingBox =
                        this.colorSquare.getBoundingClientRect();
                    this.selectedHsv[1] =
                        (x - boundingBox.left) / boundingBox.width;
                    this.selectedHsv[1] = Math.max(
                        0,
                        Math.min(1, this.selectedHsv[1])
                    );
                    this.selectedHsv[2] =
                        1 - (y - boundingBox.top) / boundingBox.height;
                    this.selectedHsv[2] = Math.max(
                        0,
                        Math.min(1, this.selectedHsv[2])
                    );
                    this.matchComponentToSelectedHsv();
                }
                updateHue(x) {
                    const boundingBox =
                        this.hueBarOuter.getBoundingClientRect();
                    this.selectedHsv[0] =
                        (360 * (x - boundingBox.left)) / boundingBox.width;
                    this.selectedHsv[0] = Math.max(
                        0,
                        Math.min(360, this.selectedHsv[0])
                    );
                    this.matchComponentToSelectedHsv();
                }
                updateOpacity(x) {
                    const boundingBox =
                        this.opacityBarOuter.getBoundingClientRect();
                    this.state.color[3] =
                        (x - boundingBox.left) / boundingBox.width;
                    this.state.color[3] = Math.max(
                        0,
                        Math.min(1, this.state.color[3])
                    );
                    this.matchComponentToSelectedHsv();
                }
                bindHandler(eventName, handler) {
                    let boundHandler = handler.bind(this);
                    document.addEventListener(eventName, boundHandler);
                    this.latentEventHandlers.push([eventName, boundHandler]);
                }
                onSquareMouseDown(event) {
                    this.updateSaturationBrightness(
                        event.clientX,
                        event.clientY
                    );
                    this.bindHandler('mousemove', this.onSquareMouseMove);
                    this.bindHandler('click', this.onSelectionFinished);
                    event.stopPropagation();
                    event.preventDefault();
                }
                onSquareMouseMove(event) {
                    this.updateSaturationBrightness(
                        event.clientX,
                        event.clientY
                    );
                    event.stopPropagation();
                    event.preventDefault();
                }
                onHueBarMouseDown(event) {
                    this.updateHue(event.clientX);
                    this.bindHandler('mousemove', this.onHueBarMouseMove);
                    this.bindHandler('click', this.onSelectionFinished);
                    event.stopPropagation();
                }
                onHueBarMouseMove(event) {
                    this.updateHue(event.clientX);
                    event.stopPropagation();
                    event.preventDefault();
                }
                onOpacityBarMouseDown(event) {
                    this.updateOpacity(event.clientX);
                    this.bindHandler('mousemove', this.onOpacityBarMouseMove);
                    this.bindHandler('click', this.onSelectionFinished);
                    event.stopPropagation();
                }
                onOpacityBarMouseMove(event) {
                    this.updateOpacity(event.clientX);
                    event.stopPropagation();
                    event.preventDefault();
                }
                onSelectionFinished(event) {
                    this.sendMessageToBackend({
                        color: this.state.color,
                    });
                    for (let handler of this.latentEventHandlers) {
                        let [eventName, boundHandler] = handler;
                        document.removeEventListener(eventName, boundHandler);
                    }
                    this.latentEventHandlers = [];
                    event.stopPropagation();
                }
                lenientlyParseColorHex(hex) {
                    hex = hex.trim();
                    hex = hex.startsWith('#') ? hex.slice(1).trim() : hex;
                    if (!/^[0-9a-fA-F]+$/.test(hex)) {
                        return null;
                    }
                    if (hex.length == 3) {
                        let [r, g, b] = hex;
                        return [
                            parseInt(r + r, 16) / 255,
                            parseInt(g + g, 16) / 255,
                            parseInt(b + b, 16) / 255,
                            1,
                        ];
                    }
                    if (hex.length == 4) {
                        let [r, g, b, a] = hex;
                        return [
                            parseInt(r + r, 16) / 255,
                            parseInt(g + g, 16) / 255,
                            parseInt(b + b, 16) / 255,
                            parseInt(a + a, 16) / 255,
                        ];
                    }
                    if (hex.length == 6) {
                        let [r, g, b] = hex.match(/.{2}/g);
                        return [
                            parseInt(r, 16) / 255,
                            parseInt(g, 16) / 255,
                            parseInt(b, 16) / 255,
                            1,
                        ];
                    }
                    if (hex.length == 8) {
                        let [r, g, b, a] = hex.match(/.{2}/g);
                        return [
                            parseInt(r, 16) / 255,
                            parseInt(g, 16) / 255,
                            parseInt(b, 16) / 255,
                            parseInt(a, 16) / 255,
                        ];
                    }
                    return null;
                }
                setFromUserHex(event) {
                    let color = this.lenientlyParseColorHex(event.target.value);
                    if (color === null) {
                        return;
                    }
                    let [h, s, l] = rgbToHsv(color[0], color[1], color[2]);
                    this.selectedHsv[0] = h;
                    this.selectedHsv[1] = s;
                    this.selectedHsv[2] = l;
                    this.state.color[3] = this.state.pick_opacity
                        ? color[3]
                        : 1;
                    this.matchComponentToSelectedHsv();
                    event.target.blur();
                    this.sendMessageToBackend({
                        color: this.state.color,
                    });
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 12;
                }
                updateAllocatedWidth(ctx) {}
                updateNaturalHeight(ctx) {
                    this.naturalHeight = this.state.pick_opacity ? 16 : 12;
                }
                updateAllocatedHeight(ctx) {
                    this.matchComponentToSelectedHsv();
                }
            }
            class LinearContainer extends ComponentBase {
                // Sum of all proportions, if there are proportions
                createElement() {
                    let element2 = document.createElement('div');
                    this.undef1 = document.createElement('div');
                    this.undef1.classList.add('rio-undefined-space');
                    element2.appendChild(this.undef1);
                    this.childContainer = document.createElement('div');
                    this.childContainer.classList.add(
                        'rio-linear-child-container'
                    );
                    element2.appendChild(this.childContainer);
                    this.undef2 = document.createElement('div');
                    this.undef2.classList.add('rio-undefined-space');
                    element2.appendChild(this.undef2);
                    if (globalThis.RIO_DEBUG_MODE) {
                        let undefinedSpaceMessage = `This ${this.state._python_type_} is larger than its content, so it's unclear how the content should be positioned. You can fix this by giving the component an alignment.`;
                        for (let elem of [this.undef1, this.undef2]) {
                            elem.title = undefinedSpaceMessage;
                            elem.style.pointerEvents = 'auto';
                        }
                    }
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.children !== void 0) {
                        this.replaceChildren(
                            latentComponents,
                            deltaState.children,
                            this.childContainer
                        );
                        for (let childElement of this.childContainer.children) {
                            childElement.style.left = '0';
                            childElement.style.top = '0';
                        }
                    }
                    if (deltaState.spacing !== void 0) {
                        this.childContainer.style.gap = `${deltaState.spacing}rem`;
                    }
                    if (
                        deltaState.proportions === void 0 ||
                        deltaState.proportions === null
                    );
                    else if (deltaState.proportions === 'homogeneous') {
                        this.totalProportions = this.children.size;
                    } else {
                        this.totalProportions = deltaState.proportions.reduce(
                            (a, b) => a + b
                        );
                    }
                    this.makeLayoutDirty();
                }
            }
            class RowComponent extends LinearContainer {
                createElement() {
                    let element2 = super.createElement();
                    element2.classList.add('rio-row');
                    return element2;
                }
                updateNaturalWidth(ctx) {
                    if (this.state.proportions === null) {
                        this.naturalWidth = 0;
                        this.nGrowers = 0;
                        for (let child of this.children) {
                            this.naturalWidth += child.requestedWidth;
                            this.nGrowers += child.state['_grow_'][0];
                        }
                    } else {
                        let proportions =
                            this.state.proportions === 'homogeneous'
                                ? Array(this.children.size).fill(1)
                                : this.state.proportions;
                        let maxProportionSize = 0;
                        for (let i = 0; i < proportions.length; i++) {
                            let child = componentsById[this.state.children[i]];
                            let proportion = proportions[i];
                            if (proportion !== 0) {
                                let proportionSize =
                                    child.requestedWidth / proportion;
                                maxProportionSize = Math.max(
                                    maxProportionSize,
                                    proportionSize
                                );
                            }
                        }
                        this.naturalWidth =
                            maxProportionSize * this.totalProportions;
                    }
                    this.naturalWidth +=
                        Math.max(this.children.size - 1, 0) *
                        this.state.spacing;
                }
                updateAllocatedWidth(ctx) {
                    if (this.state.proportions === null) {
                        let additionalSpace =
                            this.allocatedWidth - this.naturalWidth;
                        let additionalSpacePerGrower =
                            this.nGrowers === 0
                                ? 0
                                : additionalSpace / this.nGrowers;
                        for (let child of this.children) {
                            child.allocatedWidth = child.requestedWidth;
                            if (child.state['_grow_'][0]) {
                                child.allocatedWidth +=
                                    additionalSpacePerGrower;
                            }
                        }
                    } else {
                        let proportions =
                            this.state.proportions === 'homogeneous'
                                ? Array(this.children.size).fill(1)
                                : this.state.proportions;
                        let spacing =
                            Math.max(this.children.size - 1, 0) *
                            this.state.spacing;
                        let proportionSize =
                            (this.allocatedWidth - spacing) /
                            this.totalProportions;
                        for (let i = 0; i < proportions.length; i++) {
                            let child = componentsById[this.state.children[i]];
                            child.allocatedWidth =
                                proportionSize * proportions[i];
                        }
                    }
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 0;
                    for (let child of this.children) {
                        this.naturalHeight = Math.max(
                            this.naturalHeight,
                            child.requestedHeight
                        );
                    }
                }
                updateAllocatedHeight(ctx) {
                    let additionalSpace =
                        this.allocatedWidth - this.naturalWidth;
                    if (this.nGrowers > 0 || Math.abs(additionalSpace) < 1e-6) {
                        this.undef1.style.flexGrow = '0';
                        this.undef2.style.flexGrow = '0';
                        this.undef1.classList.remove('rio-undefined-space');
                        this.undef2.classList.remove('rio-undefined-space');
                    } else {
                        let element2 = this.element;
                        if (element2.children.length === 0) {
                            this.undef1.style.flexGrow = '1';
                            this.undef2.style.flexGrow = '0';
                        } else {
                            this.undef1.style.flexGrow = '1';
                            this.undef2.style.flexGrow = '1';
                        }
                        console.log(
                            `Warning: Component #${this.id} has ${additionalSpace * pixelsPerRem}px of unused horizontal space`
                        );
                        this.undef1.classList.add('rio-undefined-space');
                        this.undef2.classList.add('rio-undefined-space');
                    }
                    for (let child of this.children) {
                        child.allocatedHeight = this.allocatedHeight;
                    }
                }
            }
            class ColumnComponent extends LinearContainer {
                createElement() {
                    let element2 = super.createElement();
                    element2.classList.add('rio-column');
                    return element2;
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 0;
                    for (let child of this.children) {
                        this.naturalWidth = Math.max(
                            this.naturalWidth,
                            child.requestedWidth
                        );
                    }
                }
                updateAllocatedWidth(ctx) {
                    for (let child of this.children) {
                        child.allocatedWidth = this.allocatedWidth;
                    }
                }
                updateNaturalHeight(ctx) {
                    if (this.state.proportions === null) {
                        this.naturalHeight = 0;
                        this.nGrowers = 0;
                        for (let child of this.children) {
                            this.naturalHeight += child.requestedHeight;
                            this.nGrowers += child.state['_grow_'][1];
                        }
                    } else {
                        let proportions =
                            this.state.proportions === 'homogeneous'
                                ? Array(this.children.size).fill(1)
                                : this.state.proportions;
                        let maxProportionSize = 0;
                        for (let i = 0; i < proportions.length; i++) {
                            let child = componentsById[this.state.children[i]];
                            let proportion = proportions[i];
                            if (proportion !== 0) {
                                let proportionSize =
                                    child.requestedHeight / proportion;
                                maxProportionSize = Math.max(
                                    maxProportionSize,
                                    proportionSize
                                );
                            }
                        }
                        this.naturalHeight =
                            maxProportionSize * this.totalProportions;
                    }
                    this.naturalHeight +=
                        Math.max(this.children.size - 1, 0) *
                        this.state.spacing;
                }
                updateAllocatedHeight(ctx) {
                    if (this.state.proportions === null) {
                        let additionalSpace =
                            this.allocatedHeight - this.naturalHeight;
                        if (
                            this.nGrowers > 0 ||
                            Math.abs(additionalSpace) < 1e-6
                        ) {
                            this.undef1.style.flexGrow = '0';
                            this.undef2.style.flexGrow = '0';
                            this.undef1.classList.remove('rio-undefined-space');
                            this.undef2.classList.remove('rio-undefined-space');
                        } else {
                            let element2 = this.element;
                            if (element2.children.length === 0) {
                                this.undef1.style.flexGrow = '1';
                                this.undef2.style.flexGrow = '0';
                            } else {
                                this.undef1.style.flexGrow = '1';
                                this.undef2.style.flexGrow = '1';
                            }
                            console.log(
                                `Warning: Component #${this.id} has ${additionalSpace * pixelsPerRem}px of unused vertical space`
                            );
                            this.undef1.classList.add('rio-undefined-space');
                            this.undef2.classList.add('rio-undefined-space');
                        }
                        let children = this.children;
                        let additionalSpacePerGrower =
                            this.nGrowers === 0
                                ? 0
                                : additionalSpace / this.nGrowers;
                        for (let child of children) {
                            child.allocatedHeight = child.requestedHeight;
                            if (child.state['_grow_'][1]) {
                                child.allocatedHeight +=
                                    additionalSpacePerGrower;
                            }
                        }
                    } else {
                        let proportions =
                            this.state.proportions === 'homogeneous'
                                ? Array(this.children.size).fill(1)
                                : this.state.proportions;
                        let spacing =
                            Math.max(this.children.size - 1, 0) *
                            this.state.spacing;
                        let proportionSize =
                            (this.allocatedWidth - spacing) /
                            this.totalProportions;
                        for (let i = 0; i < proportions.length; i++) {
                            let child = componentsById[this.state.children[i]];
                            child.allocatedHeight =
                                proportionSize * proportions[i];
                        }
                    }
                }
            }
            class ComponentTreeComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.selectedComponentId = null;
                }
                createElement() {
                    let dbg = globalThis.RIO_DEBUGGER;
                    console.assert(dbg !== null);
                    dbg.componentTree = this;
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-debugger-tree-component-tree');
                    requestAnimationFrame(() => {
                        this.buildTree();
                    });
                    this.highlighterElement = document.createElement('div');
                    this.highlighterElement.classList.add(
                        'rio-debugger-component-highlighter'
                    );
                    document.body.appendChild(this.highlighterElement);
                    this.moveHighlighterTo(null);
                    return element2;
                }
                onDestruction() {
                    let dbg = globalThis.RIO_DEBUGGER;
                    console.assert(dbg !== null);
                    dbg.componentTree = null;
                    this.highlighterElement.remove();
                }
                updateElement(deltaState, latentComponents) {}
                /// Returns the currently selected component. This will impute a sensible
                /// default if the selected component no longer exists.
                getSelectedComponent() {
                    let selectedComponent =
                        this.selectedComponentId === null
                            ? void 0
                            : componentsById[this.selectedComponentId];
                    if (selectedComponent !== void 0) {
                        return selectedComponent;
                    }
                    let result = this.getDisplayedRootComponent();
                    this.setSelectedComponent(result);
                    return result;
                }
                /// Stores the currently selected component, without updating any UI. Also
                /// notifies the backend.
                setSelectedComponent(component) {
                    this.selectedComponentId = component.id;
                    this.sendMessageToBackend({
                        selectedComponentId: this.selectedComponentId,
                    });
                }
                /// Many of the spawned components are internal to Rio and shouldn't be
                /// displayed to the user. This function makes that determination.
                shouldDisplayComponent(comp) {
                    return !comp.state._rio_internal_;
                }
                _drillDown(comp) {
                    if (this.shouldDisplayComponent(comp)) {
                        return [comp];
                    }
                    let result = [];
                    for (let child of comp.children) {
                        result.push(...this._drillDown(child));
                    }
                    return result;
                }
                /// Given a component, return all of its children which should be displayed
                /// in the tree.
                getDisplayableChildren(comp) {
                    let result = [];
                    for (let child of comp.children) {
                        result.push(...this._drillDown(child));
                    }
                    return result;
                }
                /// Return the root component, but take care to discard any rio internal
                /// components.
                getDisplayedRootComponent() {
                    let rootScroller = getRootScroller();
                    let userRoot = componentsById[rootScroller.state.content];
                    return userRoot;
                }
                buildTree() {
                    let rootComponent = this.getDisplayedRootComponent();
                    let element2 = this.element;
                    element2.innerHTML = '';
                    this.buildNode(element2, rootComponent, 0);
                    setTimeout(() => {
                        if (!this.getNodeExpanded(rootComponent)) {
                            this.setNodeExpanded(rootComponent, true);
                        }
                        this.highlightSelectedComponent();
                    }, 0);
                }
                buildNode(parentElement, component, level) {
                    let element2 = document.createElement('div');
                    element2.id = `rio-debugger-component-tree-item-${component.id}`;
                    element2.classList.add('rio-debugger-component-tree-item');
                    parentElement.appendChild(element2);
                    let header = document.createElement('div');
                    header.classList.add(
                        'rio-debugger-component-tree-item-header'
                    );
                    header.textContent = component.state._python_type_;
                    let iconElement = document.createElement('div');
                    header.insertBefore(iconElement, header.firstChild);
                    applyIcon(
                        iconElement,
                        'material/keyboard-arrow-right',
                        'currentColor'
                    );
                    element2.appendChild(header);
                    let children = this.getDisplayableChildren(component);
                    let childElement = document.createElement('div');
                    childElement.classList.add(
                        'rio-debugger-component-tree-item-children'
                    );
                    element2.appendChild(childElement);
                    for (let childInfo of children) {
                        this.buildNode(childElement, childInfo, level + 1);
                    }
                    let expanded = this.getNodeExpanded(component);
                    element2.dataset.expanded = `${expanded}`;
                    element2.dataset.hasChildren = `${children.length > 0}`;
                    let icons = [];
                    if (children.length <= 1);
                    else if (children.length > 9) {
                        icons.push('material/filter-9-plus');
                    } else {
                        icons.push(`material/filter-${children.length}`);
                    }
                    if (component.state._key_ !== null) {
                        icons.push('material/key');
                    }
                    let spacer = document.createElement('div');
                    spacer.style.flexGrow = '1';
                    header.appendChild(spacer);
                    for (let icon of icons) {
                        let iconElement2 = document.createElement('div');
                        header.appendChild(iconElement2);
                        applyIcon(iconElement2, icon, 'currentColor');
                    }
                    header.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.setSelectedComponent(component);
                        this.highlightSelectedComponent();
                        let expanded2 = this.getNodeExpanded(component);
                        this.setNodeExpanded(component, !expanded2);
                        let componentElement = component.element;
                        componentElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest',
                            inline: 'nearest',
                        });
                    });
                    header.addEventListener('mouseover', (event) => {
                        this.moveHighlighterTo(component);
                        event.stopPropagation();
                    });
                    element2.addEventListener('mouseout', (event) => {
                        this.moveHighlighterTo(null);
                        event.stopPropagation();
                    });
                }
                /// Transition the highlighter to the given component. If the component is
                /// `null`, transition it out.
                moveHighlighterTo(component) {
                    let left, top, width, height;
                    if (component === null) {
                        left = -10;
                        top = -10;
                        width = window.innerWidth + 20;
                        height = window.innerHeight + 20;
                    } else {
                        let componentElement = component.element;
                        let rect = componentElement.getBoundingClientRect();
                        left = rect.left;
                        top = rect.top;
                        width = rect.width;
                        height = rect.height;
                    }
                    this.highlighterElement.style.top = `${top}px`;
                    this.highlighterElement.style.left = `${left}px`;
                    this.highlighterElement.style.width = `${width}px`;
                    this.highlighterElement.style.height = `${height}px`;
                }
                getNodeExpanded(instance) {
                    return instance._rio_debugger_expanded_ === true;
                }
                setNodeExpanded(component, expanded, allowRecursion = true) {
                    component._rio_debugger_expanded_ = expanded;
                    let element2 = document.getElementById(
                        `rio-debugger-component-tree-item-${component.id}`
                    );
                    let children = this.getDisplayableChildren(component);
                    if (element2 !== null) {
                        element2.dataset.expanded = `${expanded}`;
                    }
                    if (allowRecursion && expanded) {
                        if (children.length === 1) {
                            this.setNodeExpanded(children[0], true);
                        }
                    }
                }
                highlightSelectedComponent() {
                    for (let element2 of Array.from(
                        document.querySelectorAll(
                            '.rio-debugger-component-tree-item-header-weakly-selected, .rio-debugger-component-tree-item-header-strongly-selected'
                        )
                    )) {
                        element2.classList.remove(
                            'rio-debugger-component-tree-item-header-weakly-selected',
                            'rio-debugger-component-tree-item-header-strongly-selected'
                        );
                    }
                    let selectedComponent = this.getSelectedComponent();
                    let treeItems = [];
                    let cur = document.getElementById(
                        `rio-debugger-component-tree-item-${selectedComponent.id}`
                    );
                    while (
                        cur !== null &&
                        cur.classList.contains(
                            'rio-debugger-component-tree-item'
                        )
                    ) {
                        treeItems.push(cur.firstElementChild);
                        cur = cur.parentElement.parentElement;
                    }
                    treeItems[0].classList.add(
                        'rio-debugger-component-tree-item-header-strongly-selected'
                    );
                    for (let i = 1; i < treeItems.length; i++) {
                        treeItems[i].classList.add(
                            'rio-debugger-component-tree-item-header-weakly-selected'
                        );
                    }
                }
                afterComponentStateChange(deltaStates) {
                    this.buildTree();
                    setTimeout(() => {
                        for (let componentId in deltaStates) {
                            let element2 = document.getElementById(
                                `rio-debugger-component-tree-item-rio-id-${componentId}`
                            );
                            if (element2 === null) {
                                continue;
                            }
                            let elementHeader = element2.firstElementChild;
                            elementHeader.classList.add(
                                'rio-debugger-component-tree-flash'
                            );
                            setTimeout(() => {
                                elementHeader.classList.remove(
                                    'rio-debugger-component-tree-flash'
                                );
                            }, 5e3);
                        }
                    }, 0);
                }
            }
            const PADDING_X = 1.5;
            const PADDING_Y = 0.7;
            class CustomListItemComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.mdcRipple = null;
                }
                createElement() {
                    return document.createElement('div');
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                    if (deltaState.pressable === true) {
                        if (this.mdcRipple === null) {
                            this.mdcRipple = new MDCRipple(this.element);
                            this.element.classList.add(
                                'mdc-ripple-surface',
                                'rio-rectangle-ripple'
                            );
                            this.element.style.cursor = 'pointer';
                            this.element.onclick = this._on_press.bind(this);
                        }
                    } else if (deltaState.pressable === false) {
                        if (this.mdcRipple !== null) {
                            this.mdcRipple.destroy();
                            this.mdcRipple = null;
                            this.element.classList.remove(
                                'mdc-ripple-surface',
                                'rio-rectangle-ripple'
                            );
                            this.element.style.removeProperty('cursor');
                            this.element.onclick = null;
                        }
                    }
                }
                _on_press() {
                    this.sendMessageToBackend({
                        type: 'press',
                    });
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth =
                        componentsById[this.state.content].requestedWidth +
                        PADDING_X * 2;
                }
                updateAllocatedWidth(ctx) {
                    componentsById[this.state.content].allocatedWidth =
                        this.allocatedWidth - PADDING_X * 2;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight =
                        componentsById[this.state.content].requestedHeight +
                        PADDING_Y * 2;
                }
                updateAllocatedHeight(ctx) {
                    let child = componentsById[this.state.content];
                    child.allocatedHeight =
                        this.allocatedHeight - PADDING_Y * 2;
                    let element2 = child.element;
                    element2.style.left = `${PADDING_X}rem`;
                    element2.style.top = `${PADDING_Y}rem`;
                    if (this.mdcRipple !== null) {
                        this.mdcRipple.layout();
                    }
                }
            }
            class DebuggerConnectorComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.componentTree = null;
                }
                createElement() {
                    globalThis.RIO_DEBUGGER = this;
                    let element2 = document.createElement('a');
                    element2.href = 'https://rio.dev';
                    element2.target = '_blank';
                    element2.classList.add('rio-debugger-navigation-rio-logo');
                    element2.innerHTML = `
            <img src="/rio/asset/rio-logos/rio-logo-square.png">
            <div>Rio</div>
        `;
                    return element2;
                }
                updateElement(deltaState, latentComponents) {}
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 3;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 7;
                }
                /// Called when the state of any component changes. This allows the debugger
                /// to update its display.
                afterComponentStateChange(deltaStates) {
                    if (this.componentTree !== null) {
                        this.componentTree.afterComponentStateChange(
                            deltaStates
                        );
                    }
                }
            }
            class DrawerComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.dragStartedAt = 0;
                    this.openFractionAtDragStart = 0;
                    this.openFraction = 1;
                    this.isFirstUpdate = true;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-drawer');
                    element2.innerHTML = `
            <div class="rio-drawer-anchor"></div>
            <div class="rio-drawer-shade"></div>
            <div class="rio-drawer-content-outer">
                <div class="rio-drawer-content-inner"></div>
                <div class="rio-drawer-knob"></div>
            </div>
        `;
                    this.anchorContainer =
                        element2.querySelector('.rio-drawer-anchor');
                    this.shadeElement =
                        element2.querySelector('.rio-drawer-shade');
                    this.contentOuterContainer = element2.querySelector(
                        '.rio-drawer-content-outer'
                    );
                    this.contentInnerContainer = element2.querySelector(
                        '.rio-drawer-content-inner'
                    );
                    this.addDragHandler({
                        element: element2,
                        onStart: this.beginDrag.bind(this),
                        onMove: this.dragMove.bind(this),
                        onEnd: this.endDrag.bind(this),
                        // Let things like Buttons and TextInputs consume mouse events
                        capturing: false,
                    });
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.anchor,
                        this.anchorContainer
                    );
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content,
                        this.contentInnerContainer
                    );
                    if (deltaState.side !== void 0) {
                        this.element.classList.remove(
                            'rio-drawer-left',
                            'rio-drawer-right',
                            'rio-drawer-top',
                            'rio-drawer-bottom'
                        );
                        this.element.classList.add(
                            `rio-drawer-${deltaState.side}`
                        );
                        this.makeLayoutDirty();
                    }
                    if (deltaState.is_open === true) {
                        this.openFraction = 1;
                    } else if (deltaState.is_open === false) {
                        this.openFraction = 0;
                    }
                    if (this.isFirstUpdate) {
                        this._disableTransition();
                    } else {
                        this._enableTransition();
                    }
                    this._updateCss();
                    this.isFirstUpdate = false;
                }
                _updateCss() {
                    let axis =
                        this.state.side === 'left' ||
                        this.state.side === 'right'
                            ? 'X'
                            : 'Y';
                    let negate =
                        this.state.side === 'right' ||
                        this.state.side === 'bottom'
                            ? '+'
                            : '-';
                    let closedFraction = 1 - this.openFraction;
                    this.contentOuterContainer.style.transform = `translate${axis}(calc(0rem ${negate} ${closedFraction * 100}% ${negate} ${closedFraction * 1}rem))`;
                    if (this.state.is_modal) {
                        let shadeFraction = this.openFraction * 0.5;
                        this.shadeElement.style.backgroundColor = `rgba(0, 0, 0, ${shadeFraction})`;
                        this.shadeElement.style.pointerEvents = this.state
                            .is_open
                            ? 'auto'
                            : 'none';
                    } else {
                        this.shadeElement.style.backgroundColor =
                            'rgba(0, 0, 0, 0)';
                        this.shadeElement.style.pointerEvents = 'none';
                    }
                    let element2 = this.element;
                    if (this.openFraction > 0.5) {
                        element2.classList.add('rio-drawer-open');
                    } else {
                        element2.classList.remove('rio-drawer-open');
                    }
                }
                _enableTransition() {
                    let element2 = this.element;
                    element2.classList.remove('rio-drawer-no-transition');
                    commitCss(element2);
                }
                _disableTransition() {
                    let element2 = this.element;
                    element2.classList.add('rio-drawer-no-transition');
                    commitCss(element2);
                }
                openDrawer() {
                    this.openFraction = 1;
                    this._enableTransition();
                    this._updateCss();
                    if (!this.state.is_open) {
                        this.setStateAndNotifyBackend({
                            is_open: true,
                        });
                    }
                }
                closeDrawer() {
                    this.openFraction = 0;
                    this._enableTransition();
                    this._updateCss();
                    if (this.state.is_open) {
                        this.setStateAndNotifyBackend({
                            is_open: false,
                        });
                    }
                }
                beginDrag(event) {
                    let element2 = this.element;
                    let drawerRect = element2.getBoundingClientRect();
                    const handleSizeIfClosed = 2 * pixelsPerRem;
                    let relevantClickCoordinate, thresholdMin, thresholdMax;
                    if (this.state.side === 'left') {
                        relevantClickCoordinate = event.clientX;
                        thresholdMin = drawerRect.left;
                        thresholdMax = Math.max(
                            drawerRect.left + handleSizeIfClosed,
                            drawerRect.left +
                                this.contentOuterContainer.scrollWidth *
                                    this.openFraction
                        );
                    } else if (this.state.side === 'right') {
                        relevantClickCoordinate = event.clientX;
                        thresholdMin = Math.min(
                            drawerRect.right - handleSizeIfClosed,
                            drawerRect.right -
                                this.contentOuterContainer.scrollWidth *
                                    this.openFraction
                        );
                        thresholdMax = drawerRect.right;
                    } else if (this.state.side === 'top') {
                        relevantClickCoordinate = event.clientY;
                        thresholdMin = drawerRect.top;
                        thresholdMax = Math.max(
                            drawerRect.top + handleSizeIfClosed,
                            drawerRect.top +
                                this.contentOuterContainer.scrollHeight *
                                    this.openFraction
                        );
                    } else if (this.state.side === 'bottom') {
                        relevantClickCoordinate = event.clientY;
                        thresholdMin = Math.min(
                            drawerRect.bottom - handleSizeIfClosed,
                            drawerRect.bottom -
                                this.contentOuterContainer.scrollHeight *
                                    this.openFraction
                        );
                        thresholdMax = drawerRect.bottom;
                    }
                    if (
                        thresholdMin < relevantClickCoordinate &&
                        relevantClickCoordinate < thresholdMax
                    ) {
                        this.openFractionAtDragStart = this.openFraction;
                        this.dragStartedAt = relevantClickCoordinate;
                        event.stopPropagation();
                        return true;
                    } else if (this.state.is_modal) {
                        this.closeDrawer();
                        event.stopPropagation();
                        return false;
                    }
                    return false;
                }
                dragMove(event) {
                    let relevantCoordinate, drawerSize;
                    if (
                        this.state.side === 'left' ||
                        this.state.side === 'right'
                    ) {
                        relevantCoordinate = event.clientX;
                        drawerSize = this.contentOuterContainer.scrollWidth;
                    } else {
                        relevantCoordinate = event.clientY;
                        drawerSize = this.contentOuterContainer.scrollHeight;
                    }
                    let negate =
                        this.state.side === 'right' ||
                        this.state.side === 'bottom'
                            ? -1
                            : 1;
                    this.openFraction =
                        this.openFractionAtDragStart +
                        ((relevantCoordinate - this.dragStartedAt) /
                            drawerSize) *
                            negate;
                    this.openFraction = Math.max(
                        0,
                        Math.min(1, this.openFraction)
                    );
                    this._disableTransition();
                    this._updateCss();
                }
                endDrag() {
                    let threshold =
                        this.openFractionAtDragStart > 0.5 ? 0.7 : 0.3;
                    if (this.openFraction > threshold) {
                        this.openDrawer();
                    } else {
                        this.closeDrawer();
                    }
                }
                updateNaturalWidth(ctx) {
                    let anchorInst = componentsById[this.state.anchor];
                    let contentInst = componentsById[this.state.content];
                    this.naturalWidth = Math.max(
                        anchorInst.requestedWidth,
                        contentInst.requestedWidth
                    );
                }
                updateAllocatedWidth(ctx) {
                    let anchorInst = componentsById[this.state.anchor];
                    let contentInst = componentsById[this.state.content];
                    anchorInst.allocatedWidth = this.allocatedWidth;
                    if (
                        this.state.side === 'left' ||
                        this.state.side === 'right'
                    ) {
                        contentInst.allocatedWidth = contentInst.requestedWidth;
                    } else {
                        contentInst.allocatedWidth = this.allocatedWidth;
                    }
                }
                updateNaturalHeight(ctx) {
                    let anchorInst = componentsById[this.state.anchor];
                    let contentInst = componentsById[this.state.content];
                    this.naturalHeight = Math.max(
                        anchorInst.requestedHeight,
                        contentInst.requestedHeight
                    );
                }
                updateAllocatedHeight(ctx) {
                    let anchorInst = componentsById[this.state.anchor];
                    let contentInst = componentsById[this.state.content];
                    anchorInst.allocatedHeight = this.allocatedHeight;
                    if (
                        this.state.side === 'top' ||
                        this.state.side === 'bottom'
                    ) {
                        contentInst.allocatedHeight =
                            contentInst.requestedHeight;
                    } else {
                        contentInst.allocatedHeight = this.allocatedHeight;
                    }
                }
            }
            const HORIZONTAL_PADDING = 0.8;
            function updateInputBoxNaturalWidth(component, additionalSpace) {
                let newWidth = Math.max(
                    8,
                    additionalSpace + HORIZONTAL_PADDING * 2
                );
                if (newWidth !== component.naturalWidth) {
                    component.naturalWidth = newWidth;
                    component.makeLayoutDirty();
                }
            }
            function updateInputBoxNaturalHeight(
                component,
                label,
                additionalSpace
            ) {
                let newHeight = label.length === 0 ? 2.375 : 3.3;
                newHeight += additionalSpace;
                if (newHeight !== component.naturalHeight) {
                    component.naturalHeight = newHeight;
                    component.makeLayoutDirty();
                }
            }
            const RESERVED_WIDTH_FOR_ARROW = 1.3;
            const DROPDOWN_LIST_HORIZONTAL_PADDING = 1;
            class DropdownComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.isOpen = false;
                    this.highlightedOptionElement = null;
                    this.longestOptionWidth = 0;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add(
                        'rio-dropdown',
                        'mdc-ripple-surface',
                        'rio-input-box'
                    );
                    element2.innerHTML = `
            <input type="text" placeholder="">
            <div class="rio-input-box-label"></div>
            <div class="rio-dropdown-arrow"></div>
            <div class="rio-input-box-plain-bar"></div>
            <div class="rio-input-box-color-bar"></div>
        `;
                    this.inputElement = element2.querySelector('input');
                    this.popupElement = document.createElement('div');
                    this.popupElement.tabIndex = -999;
                    this.popupElement.classList.add('rio-dropdown-popup');
                    this.optionsElement = document.createElement('div');
                    this.optionsElement.classList.add('rio-dropdown-options');
                    this.popupElement.appendChild(this.optionsElement);
                    let arrowElement = element2.querySelector(
                        '.rio-dropdown-arrow'
                    );
                    applyIcon(
                        arrowElement,
                        'material/expand-more',
                        'var(--rio-local-text-color)'
                    );
                    element2.addEventListener(
                        'mousedown',
                        this._onMouseDown.bind(this),
                        true
                    );
                    this.inputElement.addEventListener(
                        'keydown',
                        this._onKeyDown.bind(this)
                    );
                    this.inputElement.addEventListener(
                        'input',
                        this._onInputValueChange.bind(this)
                    );
                    this.inputElement.addEventListener(
                        'focusin',
                        this._onFocusIn.bind(this)
                    );
                    this.inputElement.addEventListener(
                        'focusout',
                        this._onFocusOut.bind(this)
                    );
                    return element2;
                }
                _onFocusIn() {
                    this.inputElement.value = '';
                    this.showPopup();
                }
                _onFocusOut(event) {
                    if (
                        event.relatedTarget instanceof HTMLElement &&
                        event.relatedTarget.classList.contains(
                            'rio-dropdown-popup'
                        )
                    ) {
                        return;
                    }
                    this.trySubmitInput();
                }
                trySubmitInput() {
                    this.inputElement.blur();
                    this.hidePopup();
                    let inputText = this.inputElement.value;
                    if (inputText === this.state.selectedName) {
                        return;
                    }
                    if (this.state.optionNames.includes(inputText)) {
                        this.state.selectedName = inputText;
                        this.sendMessageToBackend({
                            name: inputText,
                        });
                    } else {
                        this.inputElement.value = this.state.selectedName;
                    }
                }
                cancelInput() {
                    this.inputElement.value = this.state.selectedName;
                    this.trySubmitInput();
                }
                submitInput(optionName) {
                    this.inputElement.value = optionName;
                    this.trySubmitInput();
                }
                _onMouseDown(event) {
                    if (event.button !== 0) {
                        return;
                    }
                    event.stopPropagation();
                    event.preventDefault();
                    if (this.isOpen) {
                        this.cancelInput();
                        return;
                    }
                    this.inputElement.focus();
                }
                _onKeyDown(event) {
                    if (event.key === 'Escape') {
                        this.cancelInput();
                    } else if (event.key === 'Enter') {
                        if (this.highlightedOptionElement !== null) {
                            this.highlightedOptionElement.click();
                        }
                    } else if (event.key === 'ArrowDown') {
                        let nextOption;
                        if (this.highlightedOptionElement === null) {
                            nextOption = this.optionsElement.firstElementChild;
                        } else {
                            nextOption =
                                this.highlightedOptionElement
                                    .nextElementSibling;
                            if (nextOption === null) {
                                nextOption =
                                    this.optionsElement.firstElementChild;
                            }
                        }
                        this._highlightOption(nextOption);
                    } else if (event.key === 'ArrowUp') {
                        let nextOption;
                        if (this.highlightedOptionElement === null) {
                            nextOption = this.optionsElement.lastElementChild;
                        } else {
                            nextOption =
                                this.highlightedOptionElement
                                    .previousElementSibling;
                            if (nextOption === null) {
                                nextOption =
                                    this.optionsElement.lastElementChild;
                            }
                        }
                        this._highlightOption(nextOption);
                    } else {
                        return;
                    }
                    event.stopPropagation();
                    event.preventDefault();
                }
                _onInputValueChange() {
                    this._updateOptionEntries();
                }
                _highlightOption(optionElement) {
                    if (this.highlightedOptionElement !== null) {
                        this.highlightedOptionElement.classList.remove(
                            'rio-dropdown-option-highlighted'
                        );
                    }
                    this.highlightedOptionElement = optionElement;
                    if (optionElement !== null) {
                        optionElement.classList.add(
                            'rio-dropdown-option-highlighted'
                        );
                    }
                }
                showPopup() {
                    if (this.isOpen) {
                        return;
                    }
                    this.isOpen = true;
                    document.body.appendChild(this.popupElement);
                    this._updateOptionEntries();
                    let dropdownRect = this.element.getBoundingClientRect();
                    let popupHeight = this.popupElement.scrollHeight;
                    let windowHeight = window.innerHeight - 1;
                    this.popupElement.style.removeProperty('top');
                    this.popupElement.style.removeProperty('bottom');
                    const MARGIN_IF_ENTIRELY_ABOVE = 0.5 * pixelsPerRem;
                    if (popupHeight >= windowHeight) {
                        this.popupElement.style.overflowY = 'scroll';
                        this.popupElement.style.top = '0';
                        this.popupElement.classList.add(
                            'rio-dropdown-popup-above'
                        );
                    } else if (
                        dropdownRect.bottom + popupHeight <=
                        windowHeight
                    ) {
                        this.popupElement.style.overflowY = 'hidden';
                        this.popupElement.style.top = `${dropdownRect.bottom}px`;
                        this.popupElement.classList.remove(
                            'rio-dropdown-popup-above'
                        );
                    } else if (
                        dropdownRect.top - popupHeight >=
                        MARGIN_IF_ENTIRELY_ABOVE
                    ) {
                        this.popupElement.style.overflowY = 'hidden';
                        this.popupElement.style.bottom = `${windowHeight - dropdownRect.top + MARGIN_IF_ENTIRELY_ABOVE}px`;
                        this.popupElement.classList.add(
                            'rio-dropdown-popup-above'
                        );
                    } else {
                        this.popupElement.style.overflowY = 'hidden';
                        let top =
                            dropdownRect.top +
                            dropdownRect.height / 2 -
                            popupHeight / 2;
                        if (top < 0) {
                            top = 0;
                        } else if (top + popupHeight > windowHeight) {
                            top = windowHeight - popupHeight;
                        }
                        this.popupElement.style.top = `${top}px`;
                        this.popupElement.classList.add(
                            'rio-dropdown-popup-above'
                        );
                    }
                    this.popupElement.style.left = dropdownRect.left + 'px';
                }
                hidePopup() {
                    if (!this.isOpen) {
                        return;
                    }
                    this.isOpen = false;
                    this.popupElement.style.height = '0';
                    setTimeout(() => {
                        if (!this.isOpen) {
                            this.popupElement.remove();
                        }
                    }, 300);
                }
                onDestruction() {
                    super.onDestruction();
                    this.popupElement.remove();
                }
                /// Find needle in haystack, returning a HTMLElement with the matched
                /// sections highlighted. If no match is found, return null. Needle must be
                /// lowercase.
                _highlightMatches(haystack, needleLower) {
                    if (needleLower.length === 0) {
                        const container2 = document.createElement('div');
                        container2.textContent = haystack;
                        return container2;
                    }
                    const container = document.createElement('div');
                    let startIndex = 0;
                    let haystackLower = haystack.toLowerCase();
                    let index = haystackLower.indexOf(needleLower, startIndex);
                    while (index !== -1) {
                        container.appendChild(
                            document.createTextNode(
                                haystack.substring(startIndex, index)
                            )
                        );
                        const span = document.createElement('span');
                        span.className = 'rio-dropdown-option-highlight';
                        span.textContent = haystack.substring(
                            index,
                            index + needleLower.length
                        );
                        container.appendChild(span);
                        startIndex = index + needleLower.length;
                        index = haystackLower.indexOf(needleLower, startIndex);
                    }
                    container.appendChild(
                        document.createTextNode(haystack.substring(startIndex))
                    );
                    return container.children.length === 0 ? null : container;
                }
                /// Update the visible options based on everything matching the search
                /// filter
                _updateOptionEntries() {
                    this.optionsElement.innerHTML = '';
                    let needleLower = this.inputElement.value.toLowerCase();
                    for (let optionName of this.state.optionNames) {
                        let match = this._highlightMatches(
                            optionName,
                            needleLower
                        );
                        if (match === null) {
                            continue;
                        }
                        match.classList.add('rio-dropdown-option');
                        match.style.padding = `0.6rem ${DROPDOWN_LIST_HORIZONTAL_PADDING}rem`;
                        this.optionsElement.appendChild(match);
                        match.addEventListener('mouseenter', () => {
                            this._highlightOption(match);
                        });
                        match.addEventListener('click', (event) => {
                            this.submitInput(optionName);
                            event.stopPropagation();
                        });
                    }
                    if (this.optionsElement.children.length === 1) {
                        this._highlightOption(
                            this.optionsElement.firstElementChild
                        );
                    }
                    if (this.optionsElement.children.length === 0) {
                        applyIcon(
                            this.optionsElement,
                            'material/error',
                            'var(--rio-local-text-color)'
                        );
                        this.popupElement.style.height = '7rem';
                    } else {
                        this.popupElement.style.height = `${this.optionsElement.scrollHeight}px`;
                    }
                }
                updateElement(deltaState, latentComponents) {
                    let element2 = this.element;
                    if (deltaState.optionNames !== void 0) {
                        this.state.optionNames = deltaState.optionNames;
                        this.longestOptionWidth = Math.max(
                            0,
                            ...this.state.optionNames.map(
                                (option) => getTextDimensions(option, 'text')[0]
                            )
                        );
                        if (this.isOpen) {
                            this._updateOptionEntries();
                        }
                    }
                    if (deltaState.label !== void 0) {
                        let labelElement = element2.querySelector(
                            '.rio-input-box-label'
                        );
                        labelElement.textContent = deltaState.label;
                        updateInputBoxNaturalHeight(this, deltaState.label, 0);
                    }
                    if (deltaState.selectedName !== void 0) {
                        this.inputElement.value = deltaState.selectedName;
                    }
                    if (deltaState.is_sensitive === true) {
                        element2.classList.remove('rio-input-box-disabled');
                    } else if (deltaState.is_sensitive === false) {
                        element2.classList.add('rio-input-box-disabled');
                    }
                    if (deltaState.is_valid === false) {
                        this.element.style.setProperty(
                            '--rio-local-text-color',
                            'var(--rio-global-danger-bg)'
                        );
                    } else if (deltaState.is_valid === true) {
                        this.element.style.removeProperty(
                            '--rio-local-text-color'
                        );
                    }
                }
                updateNaturalWidth(ctx) {
                    updateInputBoxNaturalWidth(
                        this,
                        this.longestOptionWidth +
                            scrollBarSize +
                            RESERVED_WIDTH_FOR_ARROW +
                            2 * DROPDOWN_LIST_HORIZONTAL_PADDING
                    );
                }
                updateAllocatedWidth(ctx) {
                    this.popupElement.style.width = `${this.allocatedWidth}rem`;
                }
                updateNaturalHeight(ctx) {}
            }
            class FlowComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-flow-container');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceChildren(latentComponents, deltaState.children);
                    this.makeLayoutDirty();
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 0;
                    for (let child of this.children) {
                        this.naturalWidth = Math.max(
                            this.naturalWidth,
                            child.requestedWidth
                        );
                    }
                }
                processRow(row, rowWidth) {
                    let spaceToTheLeft, spaceToGrow, spaceForGap;
                    let additionalWidth = this.allocatedWidth - rowWidth;
                    if (this.state.justify === 'left') {
                        spaceToTheLeft = 0;
                        spaceToGrow = 0;
                        spaceForGap = 0;
                    } else if (this.state.justify === 'center') {
                        spaceToTheLeft = additionalWidth * 0.5;
                        spaceToGrow = 0;
                        spaceForGap = 0;
                    } else if (this.state.justify === 'right') {
                        spaceToTheLeft = additionalWidth;
                        spaceToGrow = 0;
                        spaceForGap = 0;
                    } else if (this.state.justify === 'justified') {
                        if (row.length === 1) {
                            spaceToTheLeft = additionalWidth * 0.5;
                            spaceToGrow = 0;
                            spaceForGap = 0;
                        } else {
                            spaceToTheLeft = 0;
                            spaceToGrow = 0;
                            spaceForGap = additionalWidth / (row.length - 1);
                        }
                    } else {
                        spaceToTheLeft = 0;
                        spaceToGrow = additionalWidth / row.length;
                        spaceForGap = spaceToGrow;
                    }
                    for (let ii = 0; ii < row.length; ii++) {
                        let child = row[ii];
                        let left =
                            child._flowContainer_posX +
                            spaceToTheLeft +
                            ii * spaceForGap;
                        child.element.style.left = `${left}rem`;
                        child.allocatedWidth =
                            child.requestedWidth + spaceToGrow;
                    }
                }
                updateAllocatedWidth(ctx) {
                    if (this.children.size === 0) {
                        return;
                    }
                    let posX = 0;
                    let rowIndex = 0;
                    let currentRow = [];
                    for (let child of this.children) {
                        if (posX + child.requestedWidth > this.allocatedWidth) {
                            this.processRow(
                                currentRow,
                                posX - this.state.column_spacing
                            );
                            posX = 0;
                            ++rowIndex;
                            currentRow = [];
                        }
                        child._flowContainer_rowIndex = rowIndex;
                        child._flowContainer_posX = posX;
                        currentRow.push(child);
                        posX +=
                            child.requestedWidth + this.state.column_spacing;
                    }
                    this.processRow(
                        currentRow,
                        posX - this.state.column_spacing
                    );
                }
                updateNaturalHeight(ctx) {
                    if (this.children.size === 0) {
                        this.naturalHeight = 0;
                        return;
                    }
                    let rowHeights = [];
                    for (let child of this.children) {
                        let rowIndex = child._flowContainer_rowIndex;
                        let childHeight = child.requestedHeight;
                        if (rowHeights[rowIndex] === void 0) {
                            rowHeights[rowIndex] = childHeight;
                        } else {
                            rowHeights[rowIndex] = Math.max(
                                rowHeights[rowIndex],
                                childHeight
                            );
                        }
                    }
                    let rowTops = [0];
                    for (let ii = 0; ii < rowHeights.length; ii++) {
                        rowTops.push(
                            rowTops[ii] +
                                rowHeights[ii] +
                                this.state.row_spacing
                        );
                    }
                    this.naturalHeight = rowTops[rowTops.length - 1];
                    for (let child of this.children) {
                        let rowIndex = child._flowContainer_rowIndex;
                        let rowTop = rowTops[rowIndex];
                        let childHeight = rowHeights[rowIndex];
                        child.element.style.top = `${rowTop}rem`;
                        child.allocatedHeight = childHeight;
                    }
                }
                updateAllocatedHeight(ctx) {}
            }
            class FundamentalRootComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.overlayWidth = 0;
                    this.overlayHeight = 0;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-fundamental-root-component');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    let content2 = deltaState.content ?? this.state.content;
                    let connectionLostComponent =
                        deltaState.connection_lost_component ??
                        this.state.connection_lost_component;
                    let debugger_ = deltaState.debugger ?? this.state.debugger;
                    let children = [content2, connectionLostComponent];
                    if (debugger_ !== null) {
                        children.push(debugger_);
                    }
                    this.replaceChildren(latentComponents, children);
                    let oldConnectionLostPopup = document.querySelector(
                        '.rio-connection-lost-popup'
                    );
                    let connectionLostPopupVisible =
                        oldConnectionLostPopup === null
                            ? false
                            : oldConnectionLostPopup.classList.contains(
                                  'rio-connection-lost-popup-visible'
                              );
                    let connectionLostPopupElement = this.element.children[1];
                    connectionLostPopupElement.classList.add(
                        'rio-connection-lost-popup'
                    );
                    if (deltaState.debugger !== null) {
                        let debuggerElement = this.element.children[2];
                        debuggerElement.classList.add('rio-debugger');
                    }
                    setTimeout(
                        () =>
                            setConnectionLostPopupVisibleUnlessGoingAway(
                                connectionLostPopupVisible
                            ),
                        0
                    );
                    this.makeLayoutDirty();
                }
                updateNaturalWidth(ctx) {
                    let rect = document.documentElement.getBoundingClientRect();
                    this.naturalWidth = this.allocatedWidth =
                        rect.width / pixelsPerRem;
                    this.naturalHeight = this.allocatedHeight =
                        rect.height / pixelsPerRem;
                }
                updateAllocatedWidth(ctx) {
                    this.overlayWidth = this.allocatedWidth;
                    if (this.state.debugger !== null) {
                        let dbg = componentsById[this.state.debugger];
                        dbg.allocatedWidth = dbg.requestedWidth;
                        this.overlayWidth -= dbg.allocatedWidth;
                    }
                    let child = componentsById[this.state.content];
                    child.allocatedWidth = this.overlayWidth;
                    let connectionLostPopup =
                        componentsById[this.state.connection_lost_component];
                    connectionLostPopup.allocatedWidth = this.allocatedWidth;
                }
                updateNaturalHeight(ctx) {}
                updateAllocatedHeight(ctx) {
                    this.overlayHeight = this.allocatedHeight;
                    if (this.state.debugger !== null) {
                        let dbgInst = componentsById[this.state.debugger];
                        dbgInst.allocatedHeight = this.overlayHeight;
                        let dbgElement = dbgInst.element;
                        dbgElement.style.left = `${this.overlayWidth}rem`;
                        dbgElement.style.top = '0';
                    }
                    let connectionLostPopup =
                        componentsById[this.state.connection_lost_component];
                    connectionLostPopup.allocatedHeight = this.overlayHeight;
                    let child = componentsById[this.state.content];
                    child.allocatedHeight = this.overlayHeight;
                }
            }
            class GridComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-grid');
                    return element2;
                }
                precomputeChildData(deltaState) {
                    let children = deltaState._children;
                    for (let ii = 0; ii < children.length; ii++) {
                        let child = deltaState._child_positions[ii];
                        child.id = children[ii];
                        child.allRows = range(
                            child.row,
                            child.row + child.height
                        );
                        child.allColumns = range(
                            child.column,
                            child.column + child.width
                        );
                    }
                    this.childrenByNumberOfRows = Array.from(
                        deltaState._child_positions
                    );
                    this.childrenByNumberOfRows.sort(
                        (a, b) => a.height - b.height
                    );
                    this.nRows = 0;
                    this.growingRows = /* @__PURE__ */ new Set();
                    for (let gridChild of this.childrenByNumberOfRows) {
                        let childInstance = componentsById[gridChild.id];
                        this.nRows = Math.max(
                            this.nRows,
                            gridChild.row + gridChild.height
                        );
                        if (!childInstance.state._grow_[1]) {
                            continue;
                        }
                        let alreadyGrowing = gridChild.allRows.some((row) =>
                            this.growingRows.has(row)
                        );
                        if (!alreadyGrowing) {
                            for (let row of gridChild.allRows) {
                                this.growingRows.add(row);
                            }
                        }
                    }
                    this.childrenByNumberOfColumns = Array.from(
                        this.childrenByNumberOfRows
                    );
                    this.childrenByNumberOfColumns.sort(
                        (a, b) => a.width - b.width
                    );
                    this.nColumns = 0;
                    this.growingColumns = /* @__PURE__ */ new Set();
                    for (let gridChild of this.childrenByNumberOfColumns) {
                        let childInstance = componentsById[gridChild.id];
                        this.nColumns = Math.max(
                            this.nColumns,
                            gridChild.column + gridChild.width
                        );
                        if (!childInstance.state._grow_[0]) {
                            continue;
                        }
                        let alreadyGrowing = gridChild.allColumns.some(
                            (column) => this.growingColumns.has(column)
                        );
                        if (!alreadyGrowing) {
                            for (let column of gridChild.allColumns) {
                                this.growingColumns.add(column);
                            }
                        }
                    }
                }
                updateElement(deltaState, latentComponents) {
                    let element2 = this.element;
                    if (deltaState._children !== void 0) {
                        this.replaceChildren(
                            latentComponents,
                            deltaState._children
                        );
                        this.precomputeChildData(deltaState);
                    }
                    if (deltaState.row_spacing !== void 0) {
                        element2.style.rowGap = `${deltaState.row_spacing}rem`;
                    }
                    if (deltaState.column_spacing !== void 0) {
                        element2.style.columnGap = `${deltaState.column_spacing}rem`;
                    }
                    this.makeLayoutDirty();
                }
                updateNaturalWidth(ctx) {
                    this.columnNaturalWidths = new Array(this.nColumns).fill(0);
                    for (let gridChild of this.childrenByNumberOfColumns) {
                        let childInstance = componentsById[gridChild.id];
                        let availableWidthTotal =
                            (gridChild.width - 1) * this.state.column_spacing;
                        let growCols = [];
                        for (let ii of gridChild.allColumns) {
                            let columnWidth = this.columnNaturalWidths[ii];
                            availableWidthTotal += columnWidth;
                            if (this.growingColumns.has(ii)) {
                                growCols.push(ii);
                            }
                        }
                        let neededSpace =
                            childInstance.requestedWidth - availableWidthTotal;
                        if (neededSpace <= 0) {
                            continue;
                        }
                        let targetColumns =
                            growCols.length > 0
                                ? growCols
                                : gridChild.allColumns;
                        let spacePerColumn = neededSpace / targetColumns.length;
                        for (let column of targetColumns) {
                            this.columnNaturalWidths[column] += spacePerColumn;
                        }
                    }
                    this.naturalWidth =
                        this.state.column_spacing * (this.nColumns - 1);
                    for (let columnWidth of this.columnNaturalWidths) {
                        this.naturalWidth += columnWidth;
                    }
                }
                updateAllocatedWidth(ctx) {
                    let additionalSpace =
                        this.allocatedWidth - this.naturalWidth;
                    let targetColumns =
                        this.growingColumns.size > 0
                            ? this.growingColumns
                            : new Set(range(0, this.nColumns));
                    let spacePerColumn = additionalSpace / targetColumns.size;
                    this.columnAllocatedWidths = [...this.columnNaturalWidths];
                    for (let column of targetColumns) {
                        this.columnAllocatedWidths[column] += spacePerColumn;
                    }
                    for (let gridChild of this.childrenByNumberOfColumns) {
                        let childInstance = componentsById[gridChild.id];
                        childInstance.allocatedWidth =
                            this.state.column_spacing * (gridChild.width - 1);
                        for (let column of gridChild.allColumns) {
                            childInstance.allocatedWidth +=
                                this.columnAllocatedWidths[column];
                        }
                    }
                }
                updateNaturalHeight(ctx) {
                    this.rowNaturalHeights = new Array(this.nRows).fill(0);
                    for (let gridChild of this.childrenByNumberOfRows) {
                        let childInstance = componentsById[gridChild.id];
                        let availableHeightTotal =
                            (gridChild.height - 1) * this.state.row_spacing;
                        let growRows = [];
                        for (let ii of gridChild.allRows) {
                            let rowHeight = this.rowNaturalHeights[ii];
                            availableHeightTotal += rowHeight;
                            if (this.growingRows.has(ii)) {
                                growRows.push(ii);
                            }
                        }
                        let neededSpace =
                            childInstance.requestedHeight -
                            availableHeightTotal;
                        if (neededSpace <= 0) {
                            continue;
                        }
                        let targetRows =
                            growRows.length > 0 ? growRows : gridChild.allRows;
                        let spacePerRow = neededSpace / targetRows.length;
                        for (let row of targetRows) {
                            this.rowNaturalHeights[row] += spacePerRow;
                        }
                    }
                    this.naturalHeight =
                        this.state.row_spacing * (this.nRows - 1);
                    for (let rowHeight of this.rowNaturalHeights) {
                        this.naturalHeight += rowHeight;
                    }
                }
                updateAllocatedHeight(ctx) {
                    let additionalSpace =
                        this.allocatedHeight - this.naturalHeight;
                    let targetRows =
                        this.growingRows.size > 0
                            ? this.growingRows
                            : new Set(range(0, this.nRows));
                    let spacePerRow = additionalSpace / targetRows.size;
                    this.rowAllocatedHeights = [...this.rowNaturalHeights];
                    for (let row of targetRows) {
                        this.rowAllocatedHeights[row] += spacePerRow;
                    }
                    let columnWidthCumSum = [0];
                    for (let columnWidth of this.columnAllocatedWidths) {
                        columnWidthCumSum.push(
                            columnWidthCumSum[columnWidthCumSum.length - 1] +
                                columnWidth +
                                this.state.column_spacing
                        );
                    }
                    let rowHeightCumSum = [0];
                    for (let rowHeight of this.rowAllocatedHeights) {
                        rowHeightCumSum.push(
                            rowHeightCumSum[rowHeightCumSum.length - 1] +
                                rowHeight +
                                this.state.row_spacing
                        );
                    }
                    for (let gridChild of this.childrenByNumberOfRows) {
                        let childInstance = componentsById[gridChild.id];
                        childInstance.allocatedHeight =
                            this.state.row_spacing * (gridChild.height - 1);
                        for (let row of gridChild.allRows) {
                            childInstance.allocatedHeight +=
                                this.rowAllocatedHeights[row];
                        }
                        let childElement = componentsById[gridChild.id].element;
                        childElement.style.left = `${columnWidthCumSum[gridChild.column]}rem`;
                        childElement.style.top = `${rowHeightCumSum[gridChild.row]}rem`;
                    }
                }
            }
            const PADDING_LEFT = 1;
            const PADDING_TOP = 1.3;
            const PADDING_RIGHT = 1;
            const PADDING_BOTTOM = 0.3;
            class HeadingListItemComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-heading-list-item');
                    Object.assign(element2.style, textStyleToCss('heading3'));
                    element2.style.paddingLeft = `${PADDING_LEFT}rem`;
                    element2.style.paddingTop = `${PADDING_TOP}rem`;
                    element2.style.paddingRight = `${PADDING_RIGHT}rem`;
                    element2.style.paddingBottom = `${PADDING_BOTTOM}rem`;
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.text !== void 0) {
                        this.element.textContent = deltaState.text;
                        [this.textWidth, this.textHeight] = getTextDimensions(
                            deltaState.text,
                            'heading3'
                        );
                        this.makeLayoutDirty();
                    }
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth =
                        PADDING_LEFT + this.textWidth + PADDING_RIGHT;
                }
                updateAllocatedWidth(ctx) {}
                updateNaturalHeight(ctx) {
                    this.naturalHeight =
                        PADDING_TOP + this.textHeight + PADDING_BOTTOM;
                }
                updateAllocatedHeight(ctx) {}
            }
            class HtmlComponent extends ComponentBase {
                createElement() {
                    return document.createElement('div');
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.html !== void 0) {
                        this.element.innerHTML = deltaState.html;
                    }
                }
            }
            function createSVGPath(div, svgSource, fill) {
                div.innerHTML = svgSource;
                let svgRoot = div.firstChild;
                if (fill === 'keep') {
                    svgRoot.style.fill = 'var(--rio-local-text-color)';
                    return;
                }
                if (fill === 'dim') {
                    svgRoot.style.fill = `var(--rio-global-neutral-fg)`;
                    svgRoot.style.opacity = '0.4';
                    return;
                }
                svgRoot.style.removeProperty('opacity');
                if (typeof fill === 'string') {
                    svgRoot.style.fill = `var(--rio-global-${fill}-bg)`;
                    return;
                }
                if (Array.isArray(fill)) {
                    fill = {
                        type: 'solid',
                        // @ts-ignore
                        color: fill,
                    };
                }
                applyFillToSVG(svgRoot, fill);
            }
            class IconComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-icon');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    let element2 = this.element;
                    element2.innerHTML = '';
                    createSVGPath(
                        element2,
                        deltaState.svgSource,
                        deltaState.fill
                    );
                    requestAnimationFrame(() => {
                        let cssWidth = this.state._grow_[0]
                            ? '100%'
                            : `${this.state._size_[0] * pixelsPerRem}px`;
                        let cssHeight = this.state._grow_[1]
                            ? '100%'
                            : `${this.state._size_[1] * pixelsPerRem}px`;
                        let svgElement = this.element.querySelector('svg');
                        svgElement.setAttribute('width', cssWidth);
                        svgElement.setAttribute('height', cssHeight);
                    });
                }
            }
            const FILL_MODE_TO_OBJECT_FIT = {
                fit: 'contain',
                stretch: 'fill',
                zoom: 'cover',
            };
            class ImageComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-image');
                    this.imageElement = document.createElement('img');
                    element2.appendChild(this.imageElement);
                    this.imageElement.onload = () => {
                        this.imageElement.classList.remove(
                            'rio-content-loading'
                        );
                    };
                    this.imageElement.onerror = this._onError.bind(this);
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    let imgElement = this.imageElement;
                    if (
                        deltaState.imageUrl !== void 0 &&
                        imgElement.src !== deltaState.imageUrl
                    ) {
                        imgElement.src = deltaState.imageUrl;
                        if (this.element.firstElementChild !== imgElement) {
                            this.element.firstElementChild.remove();
                            this.element.appendChild(imgElement);
                        }
                    }
                    if (deltaState.fill_mode !== void 0) {
                        imgElement.style.objectFit =
                            FILL_MODE_TO_OBJECT_FIT[deltaState.fill_mode];
                    }
                    if (deltaState.corner_radius !== void 0) {
                        let [topLeft, topRight, bottomRight, bottomLeft] =
                            deltaState.corner_radius;
                        imgElement.style.borderRadius = `${topLeft}rem ${topRight}rem ${bottomRight}rem ${bottomLeft}rem`;
                    }
                }
                _onError(event) {
                    this.imageElement.classList.remove('rio-content-loading');
                    applyIcon(
                        this.element,
                        'material/broken-image',
                        'var(--rio-local-text-color)'
                    );
                    this.sendMessageToBackend({
                        type: 'onError',
                    });
                }
            }
            const HARDWARE_KEY_MAP = {
                Unidentified: 'unknown',
                '': 'unknown',
                // Function keys
                F1: 'f1',
                F2: 'f2',
                F3: 'f3',
                F4: 'f4',
                F5: 'f5',
                F6: 'f6',
                F7: 'f7',
                F8: 'f8',
                F9: 'f9',
                F10: 'f10',
                F11: 'f11',
                F12: 'f12',
                F13: 'f13',
                F14: 'f14',
                F15: 'f15',
                F16: 'f16',
                F17: 'f17',
                F18: 'f18',
                F19: 'f19',
                F20: 'f20',
                F21: 'f21',
                F22: 'f22',
                F23: 'f23',
                F24: 'f24',
                // Digits
                Digit0: '0',
                Digit1: '1',
                Digit2: '2',
                Digit3: '3',
                Digit4: '4',
                Digit5: '5',
                Digit6: '6',
                Digit7: '7',
                Digit8: '8',
                Digit9: '9',
                // Letters
                KeyA: 'a',
                KeyB: 'b',
                KeyC: 'c',
                KeyD: 'd',
                KeyE: 'e',
                KeyF: 'f',
                KeyG: 'g',
                KeyH: 'h',
                KeyI: 'i',
                KeyJ: 'j',
                KeyK: 'k',
                KeyL: 'l',
                KeyM: 'm',
                KeyN: 'n',
                KeyO: 'o',
                KeyP: 'p',
                KeyQ: 'q',
                KeyR: 'r',
                KeyS: 's',
                KeyT: 't',
                KeyU: 'u',
                KeyV: 'v',
                KeyW: 'w',
                KeyX: 'x',
                KeyY: 'y',
                KeyZ: 'z',
                // Punctuation
                Comma: 'comma',
                Period: 'period',
                Semicolon: 'semicolon',
                Quote: 'single-quote',
                Backquote: 'backquote',
                Space: 'space',
                // Brackets
                BracketLeft: 'bracket-left',
                BracketRight: 'bracket-right',
                // Math
                Plus: 'plus',
                Minus: 'minus',
                Multiply: 'asterisk',
                Slash: 'slash',
                Equal: 'equal',
                // Numpad
                Numpad0: 'numpad-0',
                Numpad1: 'numpad-1',
                Numpad2: 'numpad-2',
                Numpad3: 'numpad-3',
                Numpad4: 'numpad-4',
                Numpad5: 'numpad-5',
                Numpad6: 'numpad-6',
                Numpad7: 'numpad-7',
                Numpad8: 'numpad-8',
                Numpad9: 'numpad-9',
                NumpadDecimal: 'numpad-decimal',
                NumpadAdd: 'numpad-plus',
                NumpadSubtract: 'numpad-minus',
                NumpadMultiply: 'numpad-asterisk',
                NumpadDivide: 'numpad-slash',
                NumpadEnter: 'numpad-enter',
                NumpadEqual: 'numpad-equal',
                NumpadComma: 'numpad-comma',
                // Arrow keys
                ArrowUp: 'arrow-up',
                ArrowDown: 'arrow-down',
                ArrowLeft: 'arrow-left',
                ArrowRight: 'arrow-right',
                // Modifiers
                AltLeft: 'left-alt',
                AltRight: 'right-alt',
                ControlLeft: 'left-control',
                ControlRight: 'right-control',
                MetaLeft: 'left-meta',
                MetaRight: 'right-meta',
                OSLeft: 'left-meta',
                OSRight: 'right-meta',
                ShiftLeft: 'left-shift',
                ShiftRight: 'right-shift',
                // Toggles
                CapsLock: 'caps-lock',
                NumLock: 'num-lock',
                ScrollLock: 'scroll-lock',
                FnLock: 'fn-lock',
                // Browser
                BrowserBack: 'browser-back',
                BrowserFavorites: 'browser-favorites',
                BrowserForward: 'browser-forward',
                BrowserHome: 'browser-home',
                BrowserRefresh: 'browser-refresh',
                BrowserSearch: 'browser-search',
                BrowserStop: 'browser-stop',
                // Media
                MediaPlayPause: 'media-play-pause',
                MediaTrackNext: 'media-track-next',
                MediaTrackPrevious: 'media-track-previous',
                MediaStop: 'media-stop',
                MediaSelect: 'media-select',
                MediaEject: 'media-eject',
                Eject: 'media-eject',
                // Alias of MediaEject
                VolumeDown: 'volume-down',
                VolumeUp: 'volume-up',
                AudioVolumeDown: 'volume-down',
                // Alias of VolumeDown
                AudioVolumeUp: 'volume-up',
                // Alias of VolumeUp
                AudioVolumeMute: 'volume-mute',
                // Apps
                LaunchApp1: 'launch-app-1',
                LaunchApp2: 'launch-app-2',
                LaunchMail: 'launch-mail',
                // Power
                Power: 'power',
                Sleep: 'sleep',
                WakeUp: 'wake-up',
                // Clipboard
                Copy: 'copy',
                Cut: 'cut',
                Paste: 'paste',
                // Languages
                Lang1: 'lang-1',
                Lang2: 'lang-2',
                Lang3: 'lang-3',
                Lang4: 'lang-4',
                // Misc
                Escape: 'escape',
                Tab: 'tab',
                Enter: 'enter',
                Delete: 'delete',
                Insert: 'insert',
                Home: 'home',
                End: 'end',
                PageUp: 'page-up',
                PageDown: 'page-down',
                Pause: 'pause',
                PrintScreen: 'print-screen',
                ContextMenu: 'context-menu',
                Help: 'help',
                Backspace: 'backspace',
                Convert: 'convert',
                NonConvert: 'non-convert',
                Backslash: 'backslash',
                IntlBackslash: 'left-backslash',
                Undo: 'undo',
                KanaMode: 'kana-mode',
                IntlRo: 'intl-ro',
                IntlYen: 'intl-yen',
                Fn: 'fn',
                Again: 'again',
                Props: 'props',
                Select: 'select',
                Execute: 'execute',
                Find: 'find',
                Cancel: 'cancel',
                Redo: 'redo',
                ZoomIn: 'zoom-in',
                ZoomOut: 'zoom-out',
                Clear: 'clear',
                BrightnessUp: 'brightness-up',
                BrightnessDown: 'brightness-down',
            };
            const SOFTWARE_KEY_MAP = {
                Unidentified: 'unknown',
                '': 'unknown',
                // Modifiers
                Alt: 'alt',
                Control: 'control',
                Meta: 'meta',
                OS: 'meta',
                Shift: 'shift',
                AltGraph: 'alt-graph',
                CapsLock: 'caps-lock',
                NumLock: 'num-lock',
                ScrollLock: 'scroll-lock',
                Fn: 'fn',
                FnLock: 'fn-lock',
                Super: 'super',
                Hyper: 'hyper',
                Symbol: 'symbol',
                SymbolLock: 'symbol-lock',
                // Whitespace
                Enter: 'enter',
                Tab: 'tab',
                ' ': 'space',
                // Navigation
                ArrowDown: 'arrow-down',
                ArrowLeft: 'arrow-left',
                ArrowRight: 'arrow-right',
                ArrowUp: 'arrow-up',
                End: 'end',
                Home: 'home',
                PageDown: 'page-down',
                PageUp: 'page-up',
                // Editing
                Backspace: 'backspace',
                Clear: 'clear',
                Copy: 'copy',
                CrSel: 'cursor-select',
                Cut: 'cut',
                Delete: 'delete',
                EraseEof: 'erase-eof',
                ExSel: 'extend-selection',
                Insert: 'insert',
                Paste: 'paste',
                Redo: 'redo',
                Undo: 'undo',
                // UI
                Accept: 'accept',
                Again: 'again',
                Attn: 'attention',
                Cancel: 'cancel',
                ContextMenu: 'context-menu',
                Escape: 'escape',
                Execute: 'execute',
                Find: 'find',
                Finish: 'finish',
                Help: 'help',
                Pause: 'pause',
                Play: 'play',
                Props: 'props',
                Select: 'select',
                ZoomIn: 'zoom-in',
                ZoomOut: 'zoom-out',
                // Device
                BrightnessDown: 'brightness-down',
                BrightnessUp: 'brightness-up',
                Eject: 'eject',
                LogOff: 'log-off',
                Power: 'power',
                PowerOff: 'power-off',
                PrintScreen: 'print-screen',
                Hibernate: 'hibernate',
                Standby: 'standby',
                WakeUp: 'wake-up',
                // IME and composition
                AllCandidates: 'all-candidates',
                Alphanumeric: 'alphanumeric',
                CodeInput: 'code-input',
                Compose: 'compose',
                Convert: 'convert',
                Dead: 'dead',
                FinalMode: 'final-mode',
                GroupFirst: 'group-first',
                GroupLast: 'group-last',
                GroupNext: 'group-next',
                GroupPrevious: 'group-previous',
                ModeChange: 'mode-change',
                NextCandidate: 'next-candidate',
                NonConvert: 'non-convert',
                PreviousCandidate: 'previous-candidate',
                Process: 'process',
                SingleCandidate: 'single-candidate',
                // Korean
                HangulMode: 'hangul-mode',
                HanjaMode: 'hanja-mode',
                JunjaMode: 'junja-mode',
                // Japanese
                Eisu: 'eisu',
                Hankaku: 'hankaku',
                Hiragana: 'hiragana',
                HiraganaKatakana: 'hiragana-katakana',
                KanaMode: 'kana-mode',
                KanjiMode: 'kanji-mode',
                Katakana: 'katakana',
                Romaji: 'romaji',
                Zenkaku: 'zenkaku',
                ZenkakuHanaku: 'zenkaku-hanaku',
                // Function
                F1: 'f1',
                F2: 'f2',
                F3: 'f3',
                F4: 'f4',
                F5: 'f5',
                F6: 'f6',
                F7: 'f7',
                F8: 'f8',
                F9: 'f9',
                F10: 'f10',
                F11: 'f11',
                F12: 'f12',
                F13: 'f13',
                F14: 'f14',
                F15: 'f15',
                F16: 'f16',
                F17: 'f17',
                F18: 'f18',
                F19: 'f19',
                F20: 'f20',
                F21: 'f21',
                // TODO: According to MDN they only go up to F20
                F22: 'f22',
                F23: 'f23',
                F24: 'f24',
                Soft1: 'soft-1',
                Soft2: 'soft-2',
                Soft3: 'soft-3',
                Soft4: 'soft-4',
                // Phone
                AppSwitch: 'app-switch',
                Call: 'call',
                Camera: 'camera',
                CameraFocus: 'camera-focus',
                EndCall: 'end-call',
                GoBack: 'go-back',
                GoHome: 'go-home',
                HeadsetHook: 'headset-hook',
                LastNumberRedial: 'last-number-redial',
                Notification: 'notification',
                MannerMode: 'manner-mode',
                VoiceDial: 'voice-dial',
                // Multimedia
                ChannelDown: 'channel-down',
                ChannelUp: 'channel-up',
                MediaFastForward: 'media-fast-forward',
                MediaPause: 'media-pause',
                MediaPlay: 'media-play',
                MediaPlayPause: 'media-play-pause',
                MediaRecord: 'media-record',
                MediaRewind: 'media-rewind',
                MediaStop: 'media-stop',
                MediaTrackNext: 'media-track-next',
                MediaTrackPrevious: 'media-track-previous',
                // Audio control
                // TODO: I stopped checking MDN at this point, this is purely Copilot now
                AudioBalanceLeft: 'audio-balance-left',
                AudioBalanceRight: 'audio-balance-right',
                AudioBassDown: 'audio-bass-down',
                AudioBassBoostDown: 'audio-bass-boost-down',
                AudioBassBoostToggle: 'audio-bass-boost-toggle',
                AudioBassBoostUp: 'audio-bass-boost-up',
                AudioBassUp: 'audio-bass-up',
                AudioFaderFront: 'audio-fader-front',
                AudioFaderRear: 'audio-fader-rear',
                AudioSurroundModeNext: 'audio-surround-mode-next',
                AudioTrebleDown: 'audio-treble-down',
                AudioTrebleUp: 'audio-treble-up',
                AudioVolumeDown: 'audio-volume-down',
                AudioVolumeMute: 'audio-volume-mute',
                AudioVolumeUp: 'audio-volume-up',
                MicrophoneToggle: 'microphone-toggle',
                MicrophoneVolumeDown: 'microphone-volume-down',
                MicrophoneVolumeMute: 'microphone-volume-mute',
                MicrophoneVolumeUp: 'microphone-volume-up',
                // TV control
                TV: 'tv',
                TV3DMode: 'tv-3d-mode',
                TVAntennaCable: 'tv-antenna-cable',
                TVAudioDescription: 'tv-audio-description',
                TVAudioDescriptionMixDown: 'tv-audio-description-mix-down',
                TVAudioDescriptionMixUp: 'tv-audio-description-mix-up',
                TVContentsMenu: 'tv-contents-menu',
                TVDataService: 'tv-data-service',
                TVInput: 'tv-input',
                TVInputComponent1: 'tv-input-component-1',
                TVInputComponent2: 'tv-input-component-2',
                TVInputComposite1: 'tv-input-composite-1',
                TVInputComposite2: 'tv-input-composite-2',
                TVInputHDMI1: 'tv-input-hdmi-1',
                TVInputHDMI2: 'tv-input-hdmi-2',
                TVInputHDMI3: 'tv-input-hdmi-3',
                TVInputHDMI4: 'tv-input-hdmi-4',
                TVInputVGA1: 'tv-input-vga-1',
                TVMediaContext: 'tv-media-context',
                TVNetwork: 'tv-network',
                TVNumberEntry: 'tv-number-entry',
                TVPower: 'tv-power',
                TVRadioService: 'tv-radio-service',
                TVSatellite: 'tv-satellite',
                TVSatelliteBS: 'tv-satellite-bs',
                TVSatelliteCS: 'tv-satellite-cs',
                TVSatelliteToggle: 'tv-satellite-toggle',
                TVTerrestrialAnalog: 'tv-terrestrial-analog',
                TVTerrestrialDigital: 'tv-terrestrial-digital',
                TVTimer: 'tv-timer',
                // Media controller
                AVRInput: 'avr-input',
                AVRPower: 'avr-power',
                ColorF0Red: 'color-f0-red',
                ColorF1Green: 'color-f1-green',
                ColorF2Yellow: 'color-f2-yellow',
                ColorF3Blue: 'color-f3-blue',
                ColorF4Grey: 'color-f4-grey',
                ColorF5Brown: 'color-f5-brown',
                ClosedCaptionToggle: 'closed-caption-toggle',
                Dimmer: 'dimmer',
                DisplaySwap: 'display-swap',
                DVR: 'dvr',
                Exit: 'exit',
                FavoriteClear0: 'favorite-clear-0',
                FavoriteClear1: 'favorite-clear-1',
                FavoriteClear2: 'favorite-clear-2',
                FavoriteClear3: 'favorite-clear-3',
                FavoriteRecall0: 'favorite-recall-0',
                FavoriteRecall1: 'favorite-recall-1',
                FavoriteRecall2: 'favorite-recall-2',
                FavoriteRecall3: 'favorite-recall-3',
                FavoriteStore0: 'favorite-store-0',
                FavoriteStore1: 'favorite-store-1',
                FavoriteStore2: 'favorite-store-2',
                FavoriteStore3: 'favorite-store-3',
                Guide: 'guide',
                GuideNextDay: 'guide-next-day',
                GuidePreviousDay: 'guide-previous-day',
                Info: 'info',
                InstantReplay: 'instant-replay',
                Link: 'link',
                ListProgram: 'list-program',
                LiveContent: 'live-content',
                Lock: 'lock',
                MediaApps: 'media-apps',
                MediaAudioTrack: 'media-audio-track',
                MediaLast: 'media-last',
                MediaSkipBackward: 'media-skip-backward',
                MediaSkipForward: 'media-skip-forward',
                MediaStepBackward: 'media-step-backward',
                MediaStepForward: 'media-step-forward',
                MediaTopMenu: 'media-top-menu',
                NavigateIn: 'navigate-in',
                NavigateNext: 'navigate-next',
                NavigateOut: 'navigate-out',
                NavigatePrevious: 'navigate-previous',
                NextFavoriteChannel: 'next-favorite-channel',
                NextUserProfile: 'next-user-profile',
                OnDemand: 'on-demand',
                Pairing: 'pairing',
                PinPDown: 'pin-p-down',
                PinPMove: 'pin-p-move',
                PinPToggle: 'pin-p-toggle',
                PinPUp: 'pin-p-up',
                PlaySpeedDown: 'play-speed-down',
                PlaySpeedReset: 'play-speed-reset',
                PlaySpeedUp: 'play-speed-up',
                RandomToggle: 'random-toggle',
                RcLowBattery: 'rc-low-battery',
                RecordSpeedNext: 'record-speed-next',
                RfBypass: 'rf-bypass',
                ScanChannelsToggle: 'scan-channels-toggle',
                ScreenModeNext: 'screen-mode-next',
                Settings: 'settings',
                SplitScreenToggle: 'split-screen-toggle',
                STBInput: 'stb-input',
                STBPower: 'stb-power',
                Subtitle: 'subtitle',
                Teletext: 'teletext',
                VideoModeNext: 'video-mode-next',
                Wink: 'wink',
                ZoomToggle: 'zoom-toggle',
                // Speech recognition
                SpeechCorrectionList: 'speech-correction-list',
                SpeechInputToggle: 'speech-input-toggle',
                // Document
                Close: 'close',
                New: 'new',
                Open: 'open',
                Print: 'print',
                Save: 'save',
                SpellCheck: 'spell-check',
                MailForward: 'mail-forward',
                MailReply: 'mail-reply',
                MailSend: 'mail-send',
                // Application launcher
                LaunchCalculator: 'launch-calculator',
                LaunchCalendar: 'launch-calendar',
                LaunchContacts: 'launch-contacts',
                LaunchMail: 'launch-mail',
                LaunchMediaPlayer: 'launch-media-player',
                LaunchMusicPlayer: 'launch-music-player',
                LaunchMyComputer: 'launch-my-computer',
                LaunchPhone: 'launch-phone',
                LaunchScreenSaver: 'launch-screen-saver',
                LaunchSpreadsheet: 'launch-spreadsheet',
                LaunchWebBrowser: 'launch-web-browser',
                LaunchWebCam: 'launch-web-cam',
                LaunchWordProcessor: 'launch-word-processor',
                LaunchApplication1: 'launch-application-1',
                LaunchApplication2: 'launch-application-2',
                LaunchApplication3: 'launch-application-3',
                LaunchApplication4: 'launch-application-4',
                LaunchApplication5: 'launch-application-5',
                LaunchApplication6: 'launch-application-6',
                LaunchApplication7: 'launch-application-7',
                LaunchApplication8: 'launch-application-8',
                LaunchApplication9: 'launch-application-9',
                LaunchApplication10: 'launch-application-10',
                LaunchApplication11: 'launch-application-11',
                LaunchApplication12: 'launch-application-12',
                LaunchApplication13: 'launch-application-13',
                LaunchApplication14: 'launch-application-14',
                LaunchApplication15: 'launch-application-15',
                LaunchApplication16: 'launch-application-16',
                // Browser
                BrowserBack: 'browser-back',
                BrowserFavorites: 'browser-favorites',
                BrowserForward: 'browser-forward',
                BrowserHome: 'browser-home',
                BrowserRefresh: 'browser-refresh',
                BrowserSearch: 'browser-search',
                BrowserStop: 'browser-stop',
                // Numeric keypad
                Decimal: 'decimal',
                Key11: 'key-11',
                Key12: 'key-12',
                Multiply: 'asterisk',
                Add: 'plus',
                Divide: 'slash',
                Subtract: 'minus',
                Separator: 'separator',
            };
            const SPECIAL_INPUTS = {
                plus: '+',
                minus: '-',
                asterisk: '*',
                slash: '/',
                equal: '=',
                enter: '\n',
                tab: '	',
                space: ' ',
                backspace: '\b',
                comma: ',',
                period: '.',
                semicolon: ';',
                'single-quote': "'",
                backquote: '`',
                backslash: '\\',
                'left-backslash': '\\',
                'bracket-left': '[',
                'bracket-right': ']',
            };
            function encodeKey(event) {
                let hardwareKey;
                if (event.code in HARDWARE_KEY_MAP) {
                    hardwareKey = HARDWARE_KEY_MAP[event.code];
                } else {
                    console.warn(`Unknown hardware key code: ${event.code}`);
                    hardwareKey = 'unknown';
                }
                let softwareKey;
                if (event.key in SOFTWARE_KEY_MAP) {
                    softwareKey = SOFTWARE_KEY_MAP[event.key];
                } else if (event.key.length === 1) {
                    softwareKey = event.key;
                } else {
                    console.warn(`Unknown software key: ${event.key}`);
                    softwareKey = 'unknown';
                }
                let text2;
                if (event.key.length === 1) {
                    text2 = event.key;
                } else {
                    text2 = SPECIAL_INPUTS[softwareKey] ?? '';
                }
                return {
                    hardwareKey,
                    softwareKey,
                    text: text2,
                };
            }
            function encodeEvent(event) {
                let modifiers = [];
                if (event.altKey) {
                    modifiers.push('alt');
                }
                if (event.ctrlKey) {
                    modifiers.push('control');
                }
                if (event.shiftKey) {
                    modifiers.push('shift');
                }
                if (event.metaKey) {
                    modifiers.push('meta');
                }
                return {
                    ...encodeKey(event),
                    modifiers,
                };
            }
            class KeyEventListenerComponent extends SingleContainer {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.tabIndex = -1;
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    let element2 = this.element;
                    let reportKeyDown = firstDefined(
                        deltaState.reportKeyDown,
                        this.state.reportKeyDown
                    );
                    let reportKeyUp = firstDefined(
                        deltaState.reportKeyUp,
                        this.state.reportKeyUp
                    );
                    let reportKeyPress = firstDefined(
                        deltaState.reportKeyPress,
                        this.state.reportKeyPress
                    );
                    if (reportKeyDown || reportKeyPress) {
                        element2.onkeydown = (e) => {
                            let encodedEvent = encodeEvent(e);
                            if (reportKeyPress) {
                                this.sendMessageToBackend({
                                    type: 'KeyPress',
                                    ...encodedEvent,
                                });
                            }
                            if (reportKeyDown && !e.repeat) {
                                this.sendMessageToBackend({
                                    type: 'KeyDown',
                                    ...encodedEvent,
                                });
                            }
                        };
                    } else {
                        element2.onkeydown = null;
                    }
                    if (reportKeyUp) {
                        element2.onkeyup = (e) => {
                            this.sendMessageToBackend({
                                type: 'KeyUp',
                                ...encodeEvent(e),
                            });
                        };
                    } else {
                        element2.onkeyup = null;
                    }
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                }
                grabKeyboardFocus() {
                    this.element.focus();
                }
            }
            class LinkComponent extends ComponentBase {
                childAttributeName() {
                    return 'child_component';
                }
                createElement() {
                    let containerElement = document.createElement('a');
                    containerElement.classList.add('rio-link');
                    containerElement.addEventListener('click', (event) => {
                        if (this.state.isPage) {
                            this.sendMessageToBackend({
                                page: this.state.targetUrl,
                            });
                        } else if (globalThis.RUNNING_IN_WINDOW) {
                            this.sendMessageToBackend({
                                open: this.state.targetUrl,
                            });
                        } else {
                            return;
                        }
                        event.stopPropagation();
                        event.preventDefault();
                    });
                    return containerElement;
                }
                updateElement(deltaState, latentComponents) {
                    let element2 = this.element;
                    if (
                        deltaState.child_text !== void 0 &&
                        deltaState.child_text !== null
                    ) {
                        this.replaceFirstChild(latentComponents, null);
                        let textElement = document.createElement('div');
                        element2.appendChild(textElement);
                        textElement.textContent = deltaState.child_text;
                        element2.classList.add('rio-text-link');
                    }
                    if (
                        deltaState.child_component !== void 0 &&
                        deltaState.child_component !== null
                    ) {
                        this.replaceFirstChild(
                            latentComponents,
                            deltaState.child_component
                        );
                        element2.classList.remove('rio-text-link');
                    }
                    if (deltaState.targetUrl !== void 0) {
                        element2.href = deltaState.targetUrl;
                    }
                    if (deltaState.open_in_new_tab === true) {
                        element2.target = '_blank';
                    } else if (deltaState.open_in_new_tab === false) {
                        element2.target = '';
                    }
                }
                updateNaturalWidth(ctx) {
                    if (this.state.child_component === null) {
                        [this.naturalWidth, this.naturalHeight] =
                            getTextDimensions(this.state.child_text, 'text');
                    } else {
                        this.naturalWidth =
                            componentsById[
                                this.state.child_component
                            ].requestedWidth;
                    }
                }
                updateAllocatedWidth(ctx) {
                    if (this.state.child_component !== null) {
                        componentsById[
                            this.state.child_component
                        ].allocatedWidth = this.allocatedWidth;
                    }
                }
                updateNaturalHeight(ctx) {
                    if (this.state.child_component === null);
                    else {
                        this.naturalHeight =
                            componentsById[
                                this.state.child_component
                            ].requestedHeight;
                    }
                }
                updateAllocatedHeight(ctx) {
                    if (this.state.child_component !== null) {
                        componentsById[
                            this.state.child_component
                        ].allocatedHeight = this.allocatedHeight;
                        let element2 =
                            componentsById[this.state.child_component].element;
                        element2.style.left = '0';
                        element2.style.top = '0';
                    }
                }
            }
            class SeparatorListItemComponent extends ComponentBase {
                createElement() {
                    return document.createElement('div');
                }
                updateElement(deltaState, latentComponents) {}
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 0;
                }
                updateAllocatedWidth(ctx) {}
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 1;
                }
                updateAllocatedHeight(ctx) {}
            }
            class ListViewComponent extends ColumnComponent {
                constructor(id, state) {
                    state.spacing = 0;
                    state.proportions = null;
                    super(id, state);
                }
                createElement() {
                    let element2 = super.createElement();
                    element2.classList.add('rio-list-view');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceChildren(
                        latentComponents,
                        deltaState.children,
                        this.childContainer,
                        true
                    );
                    for (let child of this.childContainer.children) {
                        let element2 = child.firstElementChild;
                        element2.style.left = '0';
                        element2.style.top = '0';
                    }
                    this._updateChildStyles();
                    this.makeLayoutDirty();
                }
                _isGroupedListItemWorker(comp) {
                    if (
                        comp instanceof HeadingListItemComponent ||
                        comp instanceof SeparatorListItemComponent
                    ) {
                        return false;
                    }
                    if (comp instanceof CustomListItemComponent) {
                        return true;
                    }
                    if (comp.children.size === 1) {
                        return this._isGroupedListItemWorker(
                            comp.children.values().next().value
                        );
                    }
                    return true;
                }
                _isGroupedListItem(elem) {
                    let comp = componentsByElement.get(elem.firstElementChild);
                    if (comp === void 0) {
                        throw new Error(
                            `Cannot find component for list element ${elem}`
                        );
                    }
                    return this._isGroupedListItemWorker(comp);
                }
                _updateChildStyles() {
                    let groupedChildren = /* @__PURE__ */ new Set();
                    for (let child of this.childContainer.children) {
                        let castChild = child;
                        if (this._isGroupedListItem(castChild)) {
                            groupedChildren.add(castChild);
                            castChild.classList.add('rio-listview-grouped');
                        } else {
                            castChild.classList.remove('rio-listview-grouped');
                        }
                    }
                    for (let curChildUncast of Array.from(
                        this.childContainer.children
                    )) {
                        let curChild = curChildUncast;
                        let curIsGrouped = groupedChildren.has(curChild);
                        let prevIsGrouped = groupedChildren.has(
                            curChild.previousElementSibling
                        );
                        let nextIsGrouped = groupedChildren.has(
                            curChild.nextElementSibling
                        );
                        if (!curIsGrouped) {
                            continue;
                        }
                        let topRadius = prevIsGrouped
                            ? '0'
                            : 'var(--rio-global-corner-radius-medium)';
                        let bottomRadius = nextIsGrouped
                            ? '0'
                            : 'var(--rio-global-corner-radius-medium)';
                        curChild.style.borderTopLeftRadius = topRadius;
                        curChild.style.borderTopRightRadius = topRadius;
                        curChild.style.borderBottomLeftRadius = bottomRadius;
                        curChild.style.borderBottomRightRadius = bottomRadius;
                        curChild.style.overflow = 'hidden';
                    }
                }
            }
            class MarginComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth =
                        componentsById[this.state.content].requestedWidth +
                        this.state.margin_left +
                        this.state.margin_right;
                }
                updateAllocatedWidth(ctx) {
                    let childInstance = componentsById[this.state.content];
                    childInstance.allocatedWidth =
                        this.allocatedWidth -
                        this.state.margin_left -
                        this.state.margin_right;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight =
                        componentsById[this.state.content].requestedHeight +
                        this.state.margin_top +
                        this.state.margin_bottom;
                }
                updateAllocatedHeight(ctx) {
                    let childInstance = componentsById[this.state.content];
                    childInstance.allocatedHeight =
                        this.allocatedHeight -
                        this.state.margin_top -
                        this.state.margin_bottom;
                    let childElement = childInstance.element;
                    childElement.style.left = `${this.state.margin_left}rem`;
                    childElement.style.top = `${this.state.margin_top}rem`;
                }
            }
            const element = document.createElement('i');
            function decodeNamedCharacterReference(value) {
                const characterReference2 = '&' + value + ';';
                element.innerHTML = characterReference2;
                const char = element.textContent;
                if (
                    char.charCodeAt(char.length - 1) === 59 &&
                    value !== 'semi'
                ) {
                    return false;
                }
                return char === characterReference2 ? false : char;
            }
            function splice(list2, start, remove, items) {
                const end = list2.length;
                let chunkStart = 0;
                let parameters;
                if (start < 0) {
                    start = -start > end ? 0 : end + start;
                } else {
                    start = start > end ? end : start;
                }
                remove = remove > 0 ? remove : 0;
                if (items.length < 1e4) {
                    parameters = Array.from(items);
                    parameters.unshift(start, remove);
                    list2.splice(...parameters);
                } else {
                    if (remove) list2.splice(start, remove);
                    while (chunkStart < items.length) {
                        parameters = items.slice(chunkStart, chunkStart + 1e4);
                        parameters.unshift(start, 0);
                        list2.splice(...parameters);
                        chunkStart += 1e4;
                        start += 1e4;
                    }
                }
            }
            function push(list2, items) {
                if (list2.length > 0) {
                    splice(list2, list2.length, 0, items);
                    return list2;
                }
                return items;
            }
            const hasOwnProperty$1 = {}.hasOwnProperty;
            function combineExtensions(extensions) {
                const all = {};
                let index = -1;
                while (++index < extensions.length) {
                    syntaxExtension(all, extensions[index]);
                }
                return all;
            }
            function syntaxExtension(all, extension) {
                let hook;
                for (hook in extension) {
                    const maybe = hasOwnProperty$1.call(all, hook)
                        ? all[hook]
                        : void 0;
                    const left = maybe || (all[hook] = {});
                    const right = extension[hook];
                    let code;
                    if (right) {
                        for (code in right) {
                            if (!hasOwnProperty$1.call(left, code))
                                left[code] = [];
                            const value = right[code];
                            constructs(
                                // @ts-expect-error Looks like a list.
                                left[code],
                                Array.isArray(value)
                                    ? value
                                    : value
                                      ? [value]
                                      : []
                            );
                        }
                    }
                }
            }
            function constructs(existing, list2) {
                let index = -1;
                const before = [];
                while (++index < list2.length) {
                    (list2[index].add === 'after' ? existing : before).push(
                        list2[index]
                    );
                }
                splice(existing, 0, 0, before);
            }
            function combineHtmlExtensions(htmlExtensions) {
                const handlers = {};
                let index = -1;
                while (++index < htmlExtensions.length) {
                    htmlExtension(handlers, htmlExtensions[index]);
                }
                return handlers;
            }
            function htmlExtension(all, extension) {
                let hook;
                for (hook in extension) {
                    const maybe = hasOwnProperty$1.call(all, hook)
                        ? all[hook]
                        : void 0;
                    const left = maybe || (all[hook] = {});
                    const right = extension[hook];
                    let type;
                    if (right) {
                        for (type in right) {
                            left[type] = right[type];
                        }
                    }
                }
            }
            function decodeNumericCharacterReference(value, base) {
                const code = Number.parseInt(value, base);
                if (
                    // C0 except for HT, LF, FF, CR, space.
                    code < 9 ||
                    code === 11 ||
                    (code > 13 && code < 32) || // Control character (DEL) of C0, and C1 controls.
                    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.
                    (code > 55295 && code < 57344) || // Noncharacters.
                    (code > 64975 &&
                        code < 65008) /* eslint-disable no-bitwise */ ||
                    (code & 65535) === 65535 ||
                    (code & 65535) === 65534 /* eslint-enable no-bitwise */ ||
                    // Out of range
                    code > 1114111
                ) {
                    return '�';
                }
                return String.fromCodePoint(code);
            }
            const characterReferences = {
                '"': 'quot',
                '&': 'amp',
                '<': 'lt',
                '>': 'gt',
            };
            function encode(value) {
                return value.replace(/["&<>]/g, replace);
                function replace(value2) {
                    return '&' + characterReferences[value2] + ';';
                }
            }
            function normalizeIdentifier(value) {
                return value
                    .replace(/[\t\n\r ]+/g, ' ')
                    .replace(/^ | $/g, '')
                    .toLowerCase()
                    .toUpperCase();
            }
            const asciiAlpha = regexCheck(/[A-Za-z]/);
            const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
            const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
            function asciiControl(code) {
                return (
                    // Special whitespace codes (which have negative values), C0 and Control
                    // character DEL
                    code !== null && (code < 32 || code === 127)
                );
            }
            const asciiDigit = regexCheck(/\d/);
            const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
            const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
            function markdownLineEnding(code) {
                return code !== null && code < -2;
            }
            function markdownLineEndingOrSpace(code) {
                return code !== null && (code < 0 || code === 32);
            }
            function markdownSpace(code) {
                return code === -2 || code === -1 || code === 32;
            }
            const unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
            const unicodeWhitespace = regexCheck(/\s/);
            function regexCheck(regex) {
                return check;
                function check(code) {
                    return (
                        code !== null &&
                        code > -1 &&
                        regex.test(String.fromCharCode(code))
                    );
                }
            }
            function sanitizeUri(url, protocol) {
                const value = encode(normalizeUri(url || ''));
                if (!protocol) {
                    return value;
                }
                const colon = value.indexOf(':');
                const questionMark = value.indexOf('?');
                const numberSign = value.indexOf('#');
                const slash = value.indexOf('/');
                if (
                    // If there is no protocol, it’s relative.
                    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
                    (slash > -1 && colon > slash) ||
                    (questionMark > -1 && colon > questionMark) ||
                    (numberSign > -1 && colon > numberSign) || // It is a protocol, it should be allowed.
                    protocol.test(value.slice(0, colon))
                ) {
                    return value;
                }
                return '';
            }
            function normalizeUri(value) {
                const result = [];
                let index = -1;
                let start = 0;
                let skip = 0;
                while (++index < value.length) {
                    const code = value.charCodeAt(index);
                    let replace = '';
                    if (
                        code === 37 &&
                        asciiAlphanumeric(value.charCodeAt(index + 1)) &&
                        asciiAlphanumeric(value.charCodeAt(index + 2))
                    ) {
                        skip = 2;
                    } else if (code < 128) {
                        if (
                            !/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))
                        ) {
                            replace = String.fromCharCode(code);
                        }
                    } else if (code > 55295 && code < 57344) {
                        const next = value.charCodeAt(index + 1);
                        if (code < 56320 && next > 56319 && next < 57344) {
                            replace = String.fromCharCode(code, next);
                            skip = 1;
                        } else {
                            replace = '�';
                        }
                    } else {
                        replace = String.fromCharCode(code);
                    }
                    if (replace) {
                        result.push(
                            value.slice(start, index),
                            encodeURIComponent(replace)
                        );
                        start = index + skip + 1;
                        replace = '';
                    }
                    if (skip) {
                        index += skip;
                        skip = 0;
                    }
                }
                return result.join('') + value.slice(start);
            }
            const hasOwnProperty = {}.hasOwnProperty;
            const protocolHref = /^(https?|ircs?|mailto|xmpp)$/i;
            const protocolSrc = /^https?$/i;
            function compile(options) {
                const settings = options || {};
                let tags = true;
                const definitions = {};
                const buffers = [[]];
                const mediaStack = [];
                const tightStack = [];
                const defaultHandlers = {
                    enter: {
                        blockQuote: onenterblockquote,
                        codeFenced: onentercodefenced,
                        codeFencedFenceInfo: buffer,
                        codeFencedFenceMeta: buffer,
                        codeIndented: onentercodeindented,
                        codeText: onentercodetext,
                        content: onentercontent,
                        definition: onenterdefinition,
                        definitionDestinationString:
                            onenterdefinitiondestinationstring,
                        definitionLabelString: buffer,
                        definitionTitleString: buffer,
                        emphasis: onenteremphasis,
                        htmlFlow: onenterhtmlflow,
                        htmlText: onenterhtml,
                        image: onenterimage,
                        label: buffer,
                        link: onenterlink,
                        listItemMarker: onenterlistitemmarker,
                        listItemValue: onenterlistitemvalue,
                        listOrdered: onenterlistordered,
                        listUnordered: onenterlistunordered,
                        paragraph: onenterparagraph,
                        reference: buffer,
                        resource: onenterresource,
                        resourceDestinationString:
                            onenterresourcedestinationstring,
                        resourceTitleString: buffer,
                        setextHeading: onentersetextheading,
                        strong: onenterstrong,
                    },
                    exit: {
                        atxHeading: onexitatxheading,
                        atxHeadingSequence: onexitatxheadingsequence,
                        autolinkEmail: onexitautolinkemail,
                        autolinkProtocol: onexitautolinkprotocol,
                        blockQuote: onexitblockquote,
                        characterEscapeValue: onexitdata,
                        characterReferenceMarkerHexadecimal:
                            onexitcharacterreferencemarker,
                        characterReferenceMarkerNumeric:
                            onexitcharacterreferencemarker,
                        characterReferenceValue: onexitcharacterreferencevalue,
                        codeFenced: onexitflowcode,
                        codeFencedFence: onexitcodefencedfence,
                        codeFencedFenceInfo: onexitcodefencedfenceinfo,
                        codeFencedFenceMeta: onresumedrop,
                        codeFlowValue: onexitcodeflowvalue,
                        codeIndented: onexitflowcode,
                        codeText: onexitcodetext,
                        codeTextData: onexitdata,
                        data: onexitdata,
                        definition: onexitdefinition,
                        definitionDestinationString:
                            onexitdefinitiondestinationstring,
                        definitionLabelString: onexitdefinitionlabelstring,
                        definitionTitleString: onexitdefinitiontitlestring,
                        emphasis: onexitemphasis,
                        hardBreakEscape: onexithardbreak,
                        hardBreakTrailing: onexithardbreak,
                        htmlFlow: onexithtml,
                        htmlFlowData: onexitdata,
                        htmlText: onexithtml,
                        htmlTextData: onexitdata,
                        image: onexitmedia,
                        label: onexitlabel,
                        labelText: onexitlabeltext,
                        lineEnding: onexitlineending,
                        link: onexitmedia,
                        listOrdered: onexitlistordered,
                        listUnordered: onexitlistunordered,
                        paragraph: onexitparagraph,
                        reference: onresumedrop,
                        referenceString: onexitreferencestring,
                        resource: onresumedrop,
                        resourceDestinationString:
                            onexitresourcedestinationstring,
                        resourceTitleString: onexitresourcetitlestring,
                        setextHeading: onexitsetextheading,
                        setextHeadingLineSequence:
                            onexitsetextheadinglinesequence,
                        setextHeadingText: onexitsetextheadingtext,
                        strong: onexitstrong,
                        thematicBreak: onexitthematicbreak,
                    },
                };
                const handlers =
                    /** @type {NormalizedHtmlExtension} */
                    combineHtmlExtensions(
                        [defaultHandlers].concat(settings.htmlExtensions || [])
                    );
                const data = {
                    tightStack,
                    definitions,
                };
                const context = {
                    lineEndingIfNeeded,
                    options: settings,
                    encode: encode$1,
                    raw,
                    tag,
                    buffer,
                    resume,
                    setData,
                    getData,
                };
                let lineEndingStyle = settings.defaultLineEnding;
                return compile2;
                function compile2(events2) {
                    let index = -1;
                    let start = 0;
                    const listStack = [];
                    let head = [];
                    let body = [];
                    while (++index < events2.length) {
                        if (
                            !lineEndingStyle &&
                            (events2[index][1].type === 'lineEnding' ||
                                events2[index][1].type === 'lineEndingBlank')
                        ) {
                            lineEndingStyle = events2[index][2].sliceSerialize(
                                events2[index][1]
                            );
                        }
                        if (
                            events2[index][1].type === 'listOrdered' ||
                            events2[index][1].type === 'listUnordered'
                        ) {
                            if (events2[index][0] === 'enter') {
                                listStack.push(index);
                            } else {
                                prepareList(
                                    events2.slice(listStack.pop(), index)
                                );
                            }
                        }
                        if (events2[index][1].type === 'definition') {
                            if (events2[index][0] === 'enter') {
                                body = push(body, events2.slice(start, index));
                                start = index;
                            } else {
                                head = push(
                                    head,
                                    events2.slice(start, index + 1)
                                );
                                start = index + 1;
                            }
                        }
                    }
                    head = push(head, body);
                    head = push(head, events2.slice(start));
                    index = -1;
                    const result = head;
                    if (handlers.enter.null) {
                        handlers.enter.null.call(context);
                    }
                    while (++index < events2.length) {
                        const handles = handlers[result[index][0]];
                        const kind = result[index][1].type;
                        const handle = handles[kind];
                        if (hasOwnProperty.call(handles, kind) && handle) {
                            handle.call(
                                Object.assign(
                                    {
                                        sliceSerialize:
                                            result[index][2].sliceSerialize,
                                    },
                                    context
                                ),
                                result[index][1]
                            );
                        }
                    }
                    if (handlers.exit.null) {
                        handlers.exit.null.call(context);
                    }
                    return buffers[0].join('');
                }
                function prepareList(slice) {
                    const length = slice.length;
                    let index = 0;
                    let containerBalance = 0;
                    let loose = false;
                    let atMarker;
                    while (++index < length) {
                        const event = slice[index];
                        if (event[1]._container) {
                            atMarker = void 0;
                            if (event[0] === 'enter') {
                                containerBalance++;
                            } else {
                                containerBalance--;
                            }
                        } else
                            switch (event[1].type) {
                                case 'listItemPrefix': {
                                    if (event[0] === 'exit') {
                                        atMarker = true;
                                    }
                                    break;
                                }
                                case 'linePrefix': {
                                    break;
                                }
                                case 'lineEndingBlank': {
                                    if (
                                        event[0] === 'enter' &&
                                        !containerBalance
                                    ) {
                                        if (atMarker) {
                                            atMarker = void 0;
                                        } else {
                                            loose = true;
                                        }
                                    }
                                    break;
                                }
                                default: {
                                    atMarker = void 0;
                                }
                            }
                    }
                    slice[0][1]._loose = loose;
                }
                function setData(key, value) {
                    data[key] = value;
                }
                function getData(key) {
                    return data[key];
                }
                function buffer() {
                    buffers.push([]);
                }
                function resume() {
                    const buf = buffers.pop();
                    return buf.join('');
                }
                function tag(value) {
                    if (!tags) return;
                    setData('lastWasTag', true);
                    buffers[buffers.length - 1].push(value);
                }
                function raw(value) {
                    setData('lastWasTag');
                    buffers[buffers.length - 1].push(value);
                }
                function lineEnding2() {
                    raw(lineEndingStyle || '\n');
                }
                function lineEndingIfNeeded() {
                    const buffer2 = buffers[buffers.length - 1];
                    const slice = buffer2[buffer2.length - 1];
                    const previous2 = slice
                        ? slice.charCodeAt(slice.length - 1)
                        : null;
                    if (
                        previous2 === 10 ||
                        previous2 === 13 ||
                        previous2 === null
                    ) {
                        return;
                    }
                    lineEnding2();
                }
                function encode$1(value) {
                    return getData('ignoreEncode') ? value : encode(value);
                }
                function onresumedrop() {
                    resume();
                }
                function onenterlistordered(token) {
                    tightStack.push(!token._loose);
                    lineEndingIfNeeded();
                    tag('<ol');
                    setData('expectFirstItem', true);
                }
                function onenterlistunordered(token) {
                    tightStack.push(!token._loose);
                    lineEndingIfNeeded();
                    tag('<ul');
                    setData('expectFirstItem', true);
                }
                function onenterlistitemvalue(token) {
                    if (getData('expectFirstItem')) {
                        const value = Number.parseInt(
                            this.sliceSerialize(token),
                            10
                        );
                        if (value !== 1) {
                            tag(' start="' + encode$1(String(value)) + '"');
                        }
                    }
                }
                function onenterlistitemmarker() {
                    if (getData('expectFirstItem')) {
                        tag('>');
                    } else {
                        onexitlistitem();
                    }
                    lineEndingIfNeeded();
                    tag('<li>');
                    setData('expectFirstItem');
                    setData('lastWasTag');
                }
                function onexitlistordered() {
                    onexitlistitem();
                    tightStack.pop();
                    lineEnding2();
                    tag('</ol>');
                }
                function onexitlistunordered() {
                    onexitlistitem();
                    tightStack.pop();
                    lineEnding2();
                    tag('</ul>');
                }
                function onexitlistitem() {
                    if (
                        getData('lastWasTag') &&
                        !getData('slurpAllLineEndings')
                    ) {
                        lineEndingIfNeeded();
                    }
                    tag('</li>');
                    setData('slurpAllLineEndings');
                }
                function onenterblockquote() {
                    tightStack.push(false);
                    lineEndingIfNeeded();
                    tag('<blockquote>');
                }
                function onexitblockquote() {
                    tightStack.pop();
                    lineEndingIfNeeded();
                    tag('</blockquote>');
                    setData('slurpAllLineEndings');
                }
                function onenterparagraph() {
                    if (!tightStack[tightStack.length - 1]) {
                        lineEndingIfNeeded();
                        tag('<p>');
                    }
                    setData('slurpAllLineEndings');
                }
                function onexitparagraph() {
                    if (tightStack[tightStack.length - 1]) {
                        setData('slurpAllLineEndings', true);
                    } else {
                        tag('</p>');
                    }
                }
                function onentercodefenced() {
                    lineEndingIfNeeded();
                    tag('<pre><code');
                    setData('fencesCount', 0);
                }
                function onexitcodefencedfenceinfo() {
                    const value = resume();
                    tag(' class="language-' + value + '"');
                }
                function onexitcodefencedfence() {
                    const count = getData('fencesCount') || 0;
                    if (!count) {
                        tag('>');
                        setData('slurpOneLineEnding', true);
                    }
                    setData('fencesCount', count + 1);
                }
                function onentercodeindented() {
                    lineEndingIfNeeded();
                    tag('<pre><code>');
                }
                function onexitflowcode() {
                    const count = getData('fencesCount');
                    if (
                        count !== void 0 &&
                        count < 2 &&
                        data.tightStack.length > 0 &&
                        !getData('lastWasTag')
                    ) {
                        lineEnding2();
                    }
                    if (getData('flowCodeSeenData')) {
                        lineEndingIfNeeded();
                    }
                    tag('</code></pre>');
                    if (count !== void 0 && count < 2) lineEndingIfNeeded();
                    setData('flowCodeSeenData');
                    setData('fencesCount');
                    setData('slurpOneLineEnding');
                }
                function onenterimage() {
                    mediaStack.push({
                        image: true,
                    });
                    tags = void 0;
                }
                function onenterlink() {
                    mediaStack.push({});
                }
                function onexitlabeltext(token) {
                    mediaStack[mediaStack.length - 1].labelId =
                        this.sliceSerialize(token);
                }
                function onexitlabel() {
                    mediaStack[mediaStack.length - 1].label = resume();
                }
                function onexitreferencestring(token) {
                    mediaStack[mediaStack.length - 1].referenceId =
                        this.sliceSerialize(token);
                }
                function onenterresource() {
                    buffer();
                    mediaStack[mediaStack.length - 1].destination = '';
                }
                function onenterresourcedestinationstring() {
                    buffer();
                    setData('ignoreEncode', true);
                }
                function onexitresourcedestinationstring() {
                    mediaStack[mediaStack.length - 1].destination = resume();
                    setData('ignoreEncode');
                }
                function onexitresourcetitlestring() {
                    mediaStack[mediaStack.length - 1].title = resume();
                }
                function onexitmedia() {
                    let index = mediaStack.length - 1;
                    const media = mediaStack[index];
                    const id = media.referenceId || media.labelId;
                    const context2 =
                        media.destination === void 0
                            ? definitions[normalizeIdentifier(id)]
                            : media;
                    tags = true;
                    while (index--) {
                        if (mediaStack[index].image) {
                            tags = void 0;
                            break;
                        }
                    }
                    if (media.image) {
                        tag(
                            '<img src="' +
                                sanitizeUri(
                                    context2.destination,
                                    settings.allowDangerousProtocol
                                        ? void 0
                                        : protocolSrc
                                ) +
                                '" alt="'
                        );
                        raw(media.label);
                        tag('"');
                    } else {
                        tag(
                            '<a href="' +
                                sanitizeUri(
                                    context2.destination,
                                    settings.allowDangerousProtocol
                                        ? void 0
                                        : protocolHref
                                ) +
                                '"'
                        );
                    }
                    tag(
                        context2.title ? ' title="' + context2.title + '"' : ''
                    );
                    if (media.image) {
                        tag(' />');
                    } else {
                        tag('>');
                        raw(media.label);
                        tag('</a>');
                    }
                    mediaStack.pop();
                }
                function onenterdefinition() {
                    buffer();
                    mediaStack.push({});
                }
                function onexitdefinitionlabelstring(token) {
                    resume();
                    mediaStack[mediaStack.length - 1].labelId =
                        this.sliceSerialize(token);
                }
                function onenterdefinitiondestinationstring() {
                    buffer();
                    setData('ignoreEncode', true);
                }
                function onexitdefinitiondestinationstring() {
                    mediaStack[mediaStack.length - 1].destination = resume();
                    setData('ignoreEncode');
                }
                function onexitdefinitiontitlestring() {
                    mediaStack[mediaStack.length - 1].title = resume();
                }
                function onexitdefinition() {
                    const media = mediaStack[mediaStack.length - 1];
                    const id = normalizeIdentifier(media.labelId);
                    resume();
                    if (!hasOwnProperty.call(definitions, id)) {
                        definitions[id] = mediaStack[mediaStack.length - 1];
                    }
                    mediaStack.pop();
                }
                function onentercontent() {
                    setData('slurpAllLineEndings', true);
                }
                function onexitatxheadingsequence(token) {
                    if (getData('headingRank')) return;
                    setData('headingRank', this.sliceSerialize(token).length);
                    lineEndingIfNeeded();
                    tag('<h' + getData('headingRank') + '>');
                }
                function onentersetextheading() {
                    buffer();
                    setData('slurpAllLineEndings');
                }
                function onexitsetextheadingtext() {
                    setData('slurpAllLineEndings', true);
                }
                function onexitatxheading() {
                    tag('</h' + getData('headingRank') + '>');
                    setData('headingRank');
                }
                function onexitsetextheadinglinesequence(token) {
                    setData(
                        'headingRank',
                        this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2
                    );
                }
                function onexitsetextheading() {
                    const value = resume();
                    lineEndingIfNeeded();
                    tag('<h' + getData('headingRank') + '>');
                    raw(value);
                    tag('</h' + getData('headingRank') + '>');
                    setData('slurpAllLineEndings');
                    setData('headingRank');
                }
                function onexitdata(token) {
                    raw(encode$1(this.sliceSerialize(token)));
                }
                function onexitlineending(token) {
                    if (getData('slurpAllLineEndings')) {
                        return;
                    }
                    if (getData('slurpOneLineEnding')) {
                        setData('slurpOneLineEnding');
                        return;
                    }
                    if (getData('inCodeText')) {
                        raw(' ');
                        return;
                    }
                    raw(encode$1(this.sliceSerialize(token)));
                }
                function onexitcodeflowvalue(token) {
                    raw(encode$1(this.sliceSerialize(token)));
                    setData('flowCodeSeenData', true);
                }
                function onexithardbreak() {
                    tag('<br />');
                }
                function onenterhtmlflow() {
                    lineEndingIfNeeded();
                    onenterhtml();
                }
                function onexithtml() {
                    setData('ignoreEncode');
                }
                function onenterhtml() {
                    if (settings.allowDangerousHtml) {
                        setData('ignoreEncode', true);
                    }
                }
                function onenteremphasis() {
                    tag('<em>');
                }
                function onenterstrong() {
                    tag('<strong>');
                }
                function onentercodetext() {
                    setData('inCodeText', true);
                    tag('<code>');
                }
                function onexitcodetext() {
                    setData('inCodeText');
                    tag('</code>');
                }
                function onexitemphasis() {
                    tag('</em>');
                }
                function onexitstrong() {
                    tag('</strong>');
                }
                function onexitthematicbreak() {
                    lineEndingIfNeeded();
                    tag('<hr />');
                }
                function onexitcharacterreferencemarker(token) {
                    setData('characterReferenceType', token.type);
                }
                function onexitcharacterreferencevalue(token) {
                    let value = this.sliceSerialize(token);
                    value = getData('characterReferenceType')
                        ? decodeNumericCharacterReference(
                              value,
                              getData('characterReferenceType') ===
                                  'characterReferenceMarkerNumeric'
                                  ? 10
                                  : 16
                          )
                        : decodeNamedCharacterReference(value);
                    raw(encode$1(value));
                    setData('characterReferenceType');
                }
                function onexitautolinkprotocol(token) {
                    const uri = this.sliceSerialize(token);
                    tag(
                        '<a href="' +
                            sanitizeUri(
                                uri,
                                settings.allowDangerousProtocol
                                    ? void 0
                                    : protocolHref
                            ) +
                            '">'
                    );
                    raw(encode$1(uri));
                    tag('</a>');
                }
                function onexitautolinkemail(token) {
                    const uri = this.sliceSerialize(token);
                    tag('<a href="' + sanitizeUri('mailto:' + uri) + '">');
                    raw(encode$1(uri));
                    tag('</a>');
                }
            }
            function factorySpace(effects, ok, type, max) {
                const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
                let size = 0;
                return start;
                function start(code) {
                    if (markdownSpace(code)) {
                        effects.enter(type);
                        return prefix(code);
                    }
                    return ok(code);
                }
                function prefix(code) {
                    if (markdownSpace(code) && size++ < limit) {
                        effects.consume(code);
                        return prefix;
                    }
                    effects.exit(type);
                    return ok(code);
                }
            }
            const content$1 = {
                tokenize: initializeContent,
            };
            function initializeContent(effects) {
                const contentStart = effects.attempt(
                    this.parser.constructs.contentInitial,
                    afterContentStartConstruct,
                    paragraphInitial
                );
                let previous2;
                return contentStart;
                function afterContentStartConstruct(code) {
                    if (code === null) {
                        effects.consume(code);
                        return;
                    }
                    effects.enter('lineEnding');
                    effects.consume(code);
                    effects.exit('lineEnding');
                    return factorySpace(effects, contentStart, 'linePrefix');
                }
                function paragraphInitial(code) {
                    effects.enter('paragraph');
                    return lineStart(code);
                }
                function lineStart(code) {
                    const token = effects.enter('chunkText', {
                        contentType: 'text',
                        previous: previous2,
                    });
                    if (previous2) {
                        previous2.next = token;
                    }
                    previous2 = token;
                    return data(code);
                }
                function data(code) {
                    if (code === null) {
                        effects.exit('chunkText');
                        effects.exit('paragraph');
                        effects.consume(code);
                        return;
                    }
                    if (markdownLineEnding(code)) {
                        effects.consume(code);
                        effects.exit('chunkText');
                        return lineStart;
                    }
                    effects.consume(code);
                    return data;
                }
            }
            const document$2 = {
                tokenize: initializeDocument,
            };
            const containerConstruct = {
                tokenize: tokenizeContainer,
            };
            function initializeDocument(effects) {
                const self = this;
                const stack = [];
                let continued = 0;
                let childFlow;
                let childToken;
                let lineStartOffset;
                return start;
                function start(code) {
                    if (continued < stack.length) {
                        const item = stack[continued];
                        self.containerState = item[1];
                        return effects.attempt(
                            item[0].continuation,
                            documentContinue,
                            checkNewContainers
                        )(code);
                    }
                    return checkNewContainers(code);
                }
                function documentContinue(code) {
                    continued++;
                    if (self.containerState._closeFlow) {
                        self.containerState._closeFlow = void 0;
                        if (childFlow) {
                            closeFlow();
                        }
                        const indexBeforeExits = self.events.length;
                        let indexBeforeFlow = indexBeforeExits;
                        let point;
                        while (indexBeforeFlow--) {
                            if (
                                self.events[indexBeforeFlow][0] === 'exit' &&
                                self.events[indexBeforeFlow][1].type ===
                                    'chunkFlow'
                            ) {
                                point = self.events[indexBeforeFlow][1].end;
                                break;
                            }
                        }
                        exitContainers(continued);
                        let index = indexBeforeExits;
                        while (index < self.events.length) {
                            self.events[index][1].end = Object.assign(
                                {},
                                point
                            );
                            index++;
                        }
                        splice(
                            self.events,
                            indexBeforeFlow + 1,
                            0,
                            self.events.slice(indexBeforeExits)
                        );
                        self.events.length = index;
                        return checkNewContainers(code);
                    }
                    return start(code);
                }
                function checkNewContainers(code) {
                    if (continued === stack.length) {
                        if (!childFlow) {
                            return documentContinued(code);
                        }
                        if (
                            childFlow.currentConstruct &&
                            childFlow.currentConstruct.concrete
                        ) {
                            return flowStart(code);
                        }
                        self.interrupt = Boolean(
                            childFlow.currentConstruct &&
                                !childFlow._gfmTableDynamicInterruptHack
                        );
                    }
                    self.containerState = {};
                    return effects.check(
                        containerConstruct,
                        thereIsANewContainer,
                        thereIsNoNewContainer
                    )(code);
                }
                function thereIsANewContainer(code) {
                    if (childFlow) closeFlow();
                    exitContainers(continued);
                    return documentContinued(code);
                }
                function thereIsNoNewContainer(code) {
                    self.parser.lazy[self.now().line] =
                        continued !== stack.length;
                    lineStartOffset = self.now().offset;
                    return flowStart(code);
                }
                function documentContinued(code) {
                    self.containerState = {};
                    return effects.attempt(
                        containerConstruct,
                        containerContinue,
                        flowStart
                    )(code);
                }
                function containerContinue(code) {
                    continued++;
                    stack.push([self.currentConstruct, self.containerState]);
                    return documentContinued(code);
                }
                function flowStart(code) {
                    if (code === null) {
                        if (childFlow) closeFlow();
                        exitContainers(0);
                        effects.consume(code);
                        return;
                    }
                    childFlow = childFlow || self.parser.flow(self.now());
                    effects.enter('chunkFlow', {
                        contentType: 'flow',
                        previous: childToken,
                        _tokenizer: childFlow,
                    });
                    return flowContinue(code);
                }
                function flowContinue(code) {
                    if (code === null) {
                        writeToChild(effects.exit('chunkFlow'), true);
                        exitContainers(0);
                        effects.consume(code);
                        return;
                    }
                    if (markdownLineEnding(code)) {
                        effects.consume(code);
                        writeToChild(effects.exit('chunkFlow'));
                        continued = 0;
                        self.interrupt = void 0;
                        return start;
                    }
                    effects.consume(code);
                    return flowContinue;
                }
                function writeToChild(token, eof) {
                    const stream = self.sliceStream(token);
                    if (eof) stream.push(null);
                    token.previous = childToken;
                    if (childToken) childToken.next = token;
                    childToken = token;
                    childFlow.defineSkip(token.start);
                    childFlow.write(stream);
                    if (self.parser.lazy[token.start.line]) {
                        let index = childFlow.events.length;
                        while (index--) {
                            if (
                                // The token starts before the line ending…
                                childFlow.events[index][1].start.offset <
                                    lineStartOffset && // …and either is not ended yet…
                                (!childFlow.events[index][1].end || // …or ends after it.
                                    childFlow.events[index][1].end.offset >
                                        lineStartOffset)
                            ) {
                                return;
                            }
                        }
                        const indexBeforeExits = self.events.length;
                        let indexBeforeFlow = indexBeforeExits;
                        let seen;
                        let point;
                        while (indexBeforeFlow--) {
                            if (
                                self.events[indexBeforeFlow][0] === 'exit' &&
                                self.events[indexBeforeFlow][1].type ===
                                    'chunkFlow'
                            ) {
                                if (seen) {
                                    point = self.events[indexBeforeFlow][1].end;
                                    break;
                                }
                                seen = true;
                            }
                        }
                        exitContainers(continued);
                        index = indexBeforeExits;
                        while (index < self.events.length) {
                            self.events[index][1].end = Object.assign(
                                {},
                                point
                            );
                            index++;
                        }
                        splice(
                            self.events,
                            indexBeforeFlow + 1,
                            0,
                            self.events.slice(indexBeforeExits)
                        );
                        self.events.length = index;
                    }
                }
                function exitContainers(size) {
                    let index = stack.length;
                    while (index-- > size) {
                        const entry = stack[index];
                        self.containerState = entry[1];
                        entry[0].exit.call(self, effects);
                    }
                    stack.length = size;
                }
                function closeFlow() {
                    childFlow.write([null]);
                    childToken = void 0;
                    childFlow = void 0;
                    self.containerState._closeFlow = void 0;
                }
            }
            function tokenizeContainer(effects, ok, nok) {
                return factorySpace(
                    effects,
                    effects.attempt(this.parser.constructs.document, ok, nok),
                    'linePrefix',
                    this.parser.constructs.disable.null.includes('codeIndented')
                        ? void 0
                        : 4
                );
            }
            function classifyCharacter(code) {
                if (
                    code === null ||
                    markdownLineEndingOrSpace(code) ||
                    unicodeWhitespace(code)
                ) {
                    return 1;
                }
                if (unicodePunctuation(code)) {
                    return 2;
                }
            }
            function resolveAll(constructs2, events2, context) {
                const called = [];
                let index = -1;
                while (++index < constructs2.length) {
                    const resolve = constructs2[index].resolveAll;
                    if (resolve && !called.includes(resolve)) {
                        events2 = resolve(events2, context);
                        called.push(resolve);
                    }
                }
                return events2;
            }
            const attention = {
                name: 'attention',
                tokenize: tokenizeAttention,
                resolveAll: resolveAllAttention,
            };
            function resolveAllAttention(events2, context) {
                let index = -1;
                let open;
                let group;
                let text2;
                let openingSequence;
                let closingSequence;
                let use;
                let nextEvents;
                let offset;
                while (++index < events2.length) {
                    if (
                        events2[index][0] === 'enter' &&
                        events2[index][1].type === 'attentionSequence' &&
                        events2[index][1]._close
                    ) {
                        open = index;
                        while (open--) {
                            if (
                                events2[open][0] === 'exit' &&
                                events2[open][1].type === 'attentionSequence' &&
                                events2[open][1]._open && // If the markers are the same:
                                context
                                    .sliceSerialize(events2[open][1])
                                    .charCodeAt(0) ===
                                    context
                                        .sliceSerialize(events2[index][1])
                                        .charCodeAt(0)
                            ) {
                                if (
                                    (events2[open][1]._close ||
                                        events2[index][1]._open) &&
                                    (events2[index][1].end.offset -
                                        events2[index][1].start.offset) %
                                        3 &&
                                    !(
                                        (events2[open][1].end.offset -
                                            events2[open][1].start.offset +
                                            events2[index][1].end.offset -
                                            events2[index][1].start.offset) %
                                        3
                                    )
                                ) {
                                    continue;
                                }
                                use =
                                    events2[open][1].end.offset -
                                        events2[open][1].start.offset >
                                        1 &&
                                    events2[index][1].end.offset -
                                        events2[index][1].start.offset >
                                        1
                                        ? 2
                                        : 1;
                                const start = Object.assign(
                                    {},
                                    events2[open][1].end
                                );
                                const end = Object.assign(
                                    {},
                                    events2[index][1].start
                                );
                                movePoint(start, -use);
                                movePoint(end, use);
                                openingSequence = {
                                    type:
                                        use > 1
                                            ? 'strongSequence'
                                            : 'emphasisSequence',
                                    start,
                                    end: Object.assign(
                                        {},
                                        events2[open][1].end
                                    ),
                                };
                                closingSequence = {
                                    type:
                                        use > 1
                                            ? 'strongSequence'
                                            : 'emphasisSequence',
                                    start: Object.assign(
                                        {},
                                        events2[index][1].start
                                    ),
                                    end,
                                };
                                text2 = {
                                    type:
                                        use > 1 ? 'strongText' : 'emphasisText',
                                    start: Object.assign(
                                        {},
                                        events2[open][1].end
                                    ),
                                    end: Object.assign(
                                        {},
                                        events2[index][1].start
                                    ),
                                };
                                group = {
                                    type: use > 1 ? 'strong' : 'emphasis',
                                    start: Object.assign(
                                        {},
                                        openingSequence.start
                                    ),
                                    end: Object.assign({}, closingSequence.end),
                                };
                                events2[open][1].end = Object.assign(
                                    {},
                                    openingSequence.start
                                );
                                events2[index][1].start = Object.assign(
                                    {},
                                    closingSequence.end
                                );
                                nextEvents = [];
                                if (
                                    events2[open][1].end.offset -
                                    events2[open][1].start.offset
                                ) {
                                    nextEvents = push(nextEvents, [
                                        ['enter', events2[open][1], context],
                                        ['exit', events2[open][1], context],
                                    ]);
                                }
                                nextEvents = push(nextEvents, [
                                    ['enter', group, context],
                                    ['enter', openingSequence, context],
                                    ['exit', openingSequence, context],
                                    ['enter', text2, context],
                                ]);
                                nextEvents = push(
                                    nextEvents,
                                    resolveAll(
                                        context.parser.constructs.insideSpan
                                            .null,
                                        events2.slice(open + 1, index),
                                        context
                                    )
                                );
                                nextEvents = push(nextEvents, [
                                    ['exit', text2, context],
                                    ['enter', closingSequence, context],
                                    ['exit', closingSequence, context],
                                    ['exit', group, context],
                                ]);
                                if (
                                    events2[index][1].end.offset -
                                    events2[index][1].start.offset
                                ) {
                                    offset = 2;
                                    nextEvents = push(nextEvents, [
                                        ['enter', events2[index][1], context],
                                        ['exit', events2[index][1], context],
                                    ]);
                                } else {
                                    offset = 0;
                                }
                                splice(
                                    events2,
                                    open - 1,
                                    index - open + 3,
                                    nextEvents
                                );
                                index = open + nextEvents.length - offset - 2;
                                break;
                            }
                        }
                    }
                }
                index = -1;
                while (++index < events2.length) {
                    if (events2[index][1].type === 'attentionSequence') {
                        events2[index][1].type = 'data';
                    }
                }
                return events2;
            }
            function tokenizeAttention(effects, ok) {
                const attentionMarkers2 =
                    this.parser.constructs.attentionMarkers.null;
                const previous2 = this.previous;
                const before = classifyCharacter(previous2);
                let marker;
                return start;
                function start(code) {
                    marker = code;
                    effects.enter('attentionSequence');
                    return inside(code);
                }
                function inside(code) {
                    if (code === marker) {
                        effects.consume(code);
                        return inside;
                    }
                    const token = effects.exit('attentionSequence');
                    const after = classifyCharacter(code);
                    const open =
                        !after ||
                        (after === 2 && before) ||
                        attentionMarkers2.includes(code);
                    const close =
                        !before ||
                        (before === 2 && after) ||
                        attentionMarkers2.includes(previous2);
                    token._open = Boolean(
                        marker === 42 ? open : open && (before || !close)
                    );
                    token._close = Boolean(
                        marker === 42 ? close : close && (after || !open)
                    );
                    return ok(code);
                }
            }
            function movePoint(point, offset) {
                point.column += offset;
                point.offset += offset;
                point._bufferIndex += offset;
            }
            const autolink = {
                name: 'autolink',
                tokenize: tokenizeAutolink,
            };
            function tokenizeAutolink(effects, ok, nok) {
                let size = 0;
                return start;
                function start(code) {
                    effects.enter('autolink');
                    effects.enter('autolinkMarker');
                    effects.consume(code);
                    effects.exit('autolinkMarker');
                    effects.enter('autolinkProtocol');
                    return open;
                }
                function open(code) {
                    if (asciiAlpha(code)) {
                        effects.consume(code);
                        return schemeOrEmailAtext;
                    }
                    return emailAtext(code);
                }
                function schemeOrEmailAtext(code) {
                    if (
                        code === 43 ||
                        code === 45 ||
                        code === 46 ||
                        asciiAlphanumeric(code)
                    ) {
                        size = 1;
                        return schemeInsideOrEmailAtext(code);
                    }
                    return emailAtext(code);
                }
                function schemeInsideOrEmailAtext(code) {
                    if (code === 58) {
                        effects.consume(code);
                        size = 0;
                        return urlInside;
                    }
                    if (
                        (code === 43 ||
                            code === 45 ||
                            code === 46 ||
                            asciiAlphanumeric(code)) &&
                        size++ < 32
                    ) {
                        effects.consume(code);
                        return schemeInsideOrEmailAtext;
                    }
                    size = 0;
                    return emailAtext(code);
                }
                function urlInside(code) {
                    if (code === 62) {
                        effects.exit('autolinkProtocol');
                        effects.enter('autolinkMarker');
                        effects.consume(code);
                        effects.exit('autolinkMarker');
                        effects.exit('autolink');
                        return ok;
                    }
                    if (
                        code === null ||
                        code === 32 ||
                        code === 60 ||
                        asciiControl(code)
                    ) {
                        return nok(code);
                    }
                    effects.consume(code);
                    return urlInside;
                }
                function emailAtext(code) {
                    if (code === 64) {
                        effects.consume(code);
                        return emailAtSignOrDot;
                    }
                    if (asciiAtext(code)) {
                        effects.consume(code);
                        return emailAtext;
                    }
                    return nok(code);
                }
                function emailAtSignOrDot(code) {
                    return asciiAlphanumeric(code)
                        ? emailLabel(code)
                        : nok(code);
                }
                function emailLabel(code) {
                    if (code === 46) {
                        effects.consume(code);
                        size = 0;
                        return emailAtSignOrDot;
                    }
                    if (code === 62) {
                        effects.exit('autolinkProtocol').type = 'autolinkEmail';
                        effects.enter('autolinkMarker');
                        effects.consume(code);
                        effects.exit('autolinkMarker');
                        effects.exit('autolink');
                        return ok;
                    }
                    return emailValue(code);
                }
                function emailValue(code) {
                    if (
                        (code === 45 || asciiAlphanumeric(code)) &&
                        size++ < 63
                    ) {
                        const next = code === 45 ? emailValue : emailLabel;
                        effects.consume(code);
                        return next;
                    }
                    return nok(code);
                }
            }
            const blankLine = {
                tokenize: tokenizeBlankLine,
                partial: true,
            };
            function tokenizeBlankLine(effects, ok, nok) {
                return start;
                function start(code) {
                    return markdownSpace(code)
                        ? factorySpace(effects, after, 'linePrefix')(code)
                        : after(code);
                }
                function after(code) {
                    return code === null || markdownLineEnding(code)
                        ? ok(code)
                        : nok(code);
                }
            }
            const blockQuote = {
                name: 'blockQuote',
                tokenize: tokenizeBlockQuoteStart,
                continuation: {
                    tokenize: tokenizeBlockQuoteContinuation,
                },
                exit,
            };
            function tokenizeBlockQuoteStart(effects, ok, nok) {
                const self = this;
                return start;
                function start(code) {
                    if (code === 62) {
                        const state = self.containerState;
                        if (!state.open) {
                            effects.enter('blockQuote', {
                                _container: true,
                            });
                            state.open = true;
                        }
                        effects.enter('blockQuotePrefix');
                        effects.enter('blockQuoteMarker');
                        effects.consume(code);
                        effects.exit('blockQuoteMarker');
                        return after;
                    }
                    return nok(code);
                }
                function after(code) {
                    if (markdownSpace(code)) {
                        effects.enter('blockQuotePrefixWhitespace');
                        effects.consume(code);
                        effects.exit('blockQuotePrefixWhitespace');
                        effects.exit('blockQuotePrefix');
                        return ok;
                    }
                    effects.exit('blockQuotePrefix');
                    return ok(code);
                }
            }
            function tokenizeBlockQuoteContinuation(effects, ok, nok) {
                const self = this;
                return contStart;
                function contStart(code) {
                    if (markdownSpace(code)) {
                        return factorySpace(
                            effects,
                            contBefore,
                            'linePrefix',
                            self.parser.constructs.disable.null.includes(
                                'codeIndented'
                            )
                                ? void 0
                                : 4
                        )(code);
                    }
                    return contBefore(code);
                }
                function contBefore(code) {
                    return effects.attempt(blockQuote, ok, nok)(code);
                }
            }
            function exit(effects) {
                effects.exit('blockQuote');
            }
            const characterEscape = {
                name: 'characterEscape',
                tokenize: tokenizeCharacterEscape,
            };
            function tokenizeCharacterEscape(effects, ok, nok) {
                return start;
                function start(code) {
                    effects.enter('characterEscape');
                    effects.enter('escapeMarker');
                    effects.consume(code);
                    effects.exit('escapeMarker');
                    return inside;
                }
                function inside(code) {
                    if (asciiPunctuation(code)) {
                        effects.enter('characterEscapeValue');
                        effects.consume(code);
                        effects.exit('characterEscapeValue');
                        effects.exit('characterEscape');
                        return ok;
                    }
                    return nok(code);
                }
            }
            const characterReference = {
                name: 'characterReference',
                tokenize: tokenizeCharacterReference,
            };
            function tokenizeCharacterReference(effects, ok, nok) {
                const self = this;
                let size = 0;
                let max;
                let test;
                return start;
                function start(code) {
                    effects.enter('characterReference');
                    effects.enter('characterReferenceMarker');
                    effects.consume(code);
                    effects.exit('characterReferenceMarker');
                    return open;
                }
                function open(code) {
                    if (code === 35) {
                        effects.enter('characterReferenceMarkerNumeric');
                        effects.consume(code);
                        effects.exit('characterReferenceMarkerNumeric');
                        return numeric;
                    }
                    effects.enter('characterReferenceValue');
                    max = 31;
                    test = asciiAlphanumeric;
                    return value(code);
                }
                function numeric(code) {
                    if (code === 88 || code === 120) {
                        effects.enter('characterReferenceMarkerHexadecimal');
                        effects.consume(code);
                        effects.exit('characterReferenceMarkerHexadecimal');
                        effects.enter('characterReferenceValue');
                        max = 6;
                        test = asciiHexDigit;
                        return value;
                    }
                    effects.enter('characterReferenceValue');
                    max = 7;
                    test = asciiDigit;
                    return value(code);
                }
                function value(code) {
                    if (code === 59 && size) {
                        const token = effects.exit('characterReferenceValue');
                        if (
                            test === asciiAlphanumeric &&
                            !decodeNamedCharacterReference(
                                self.sliceSerialize(token)
                            )
                        ) {
                            return nok(code);
                        }
                        effects.enter('characterReferenceMarker');
                        effects.consume(code);
                        effects.exit('characterReferenceMarker');
                        effects.exit('characterReference');
                        return ok;
                    }
                    if (test(code) && size++ < max) {
                        effects.consume(code);
                        return value;
                    }
                    return nok(code);
                }
            }
            const nonLazyContinuation = {
                tokenize: tokenizeNonLazyContinuation,
                partial: true,
            };
            const codeFenced = {
                name: 'codeFenced',
                tokenize: tokenizeCodeFenced,
                concrete: true,
            };
            function tokenizeCodeFenced(effects, ok, nok) {
                const self = this;
                const closeStart = {
                    tokenize: tokenizeCloseStart,
                    partial: true,
                };
                let initialPrefix = 0;
                let sizeOpen = 0;
                let marker;
                return start;
                function start(code) {
                    return beforeSequenceOpen(code);
                }
                function beforeSequenceOpen(code) {
                    const tail = self.events[self.events.length - 1];
                    initialPrefix =
                        tail && tail[1].type === 'linePrefix'
                            ? tail[2].sliceSerialize(tail[1], true).length
                            : 0;
                    marker = code;
                    effects.enter('codeFenced');
                    effects.enter('codeFencedFence');
                    effects.enter('codeFencedFenceSequence');
                    return sequenceOpen(code);
                }
                function sequenceOpen(code) {
                    if (code === marker) {
                        sizeOpen++;
                        effects.consume(code);
                        return sequenceOpen;
                    }
                    if (sizeOpen < 3) {
                        return nok(code);
                    }
                    effects.exit('codeFencedFenceSequence');
                    return markdownSpace(code)
                        ? factorySpace(effects, infoBefore, 'whitespace')(code)
                        : infoBefore(code);
                }
                function infoBefore(code) {
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('codeFencedFence');
                        return self.interrupt
                            ? ok(code)
                            : effects.check(
                                  nonLazyContinuation,
                                  atNonLazyBreak,
                                  after
                              )(code);
                    }
                    effects.enter('codeFencedFenceInfo');
                    effects.enter('chunkString', {
                        contentType: 'string',
                    });
                    return info(code);
                }
                function info(code) {
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('chunkString');
                        effects.exit('codeFencedFenceInfo');
                        return infoBefore(code);
                    }
                    if (markdownSpace(code)) {
                        effects.exit('chunkString');
                        effects.exit('codeFencedFenceInfo');
                        return factorySpace(
                            effects,
                            metaBefore,
                            'whitespace'
                        )(code);
                    }
                    if (code === 96 && code === marker) {
                        return nok(code);
                    }
                    effects.consume(code);
                    return info;
                }
                function metaBefore(code) {
                    if (code === null || markdownLineEnding(code)) {
                        return infoBefore(code);
                    }
                    effects.enter('codeFencedFenceMeta');
                    effects.enter('chunkString', {
                        contentType: 'string',
                    });
                    return meta(code);
                }
                function meta(code) {
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('chunkString');
                        effects.exit('codeFencedFenceMeta');
                        return infoBefore(code);
                    }
                    if (code === 96 && code === marker) {
                        return nok(code);
                    }
                    effects.consume(code);
                    return meta;
                }
                function atNonLazyBreak(code) {
                    return effects.attempt(
                        closeStart,
                        after,
                        contentBefore
                    )(code);
                }
                function contentBefore(code) {
                    effects.enter('lineEnding');
                    effects.consume(code);
                    effects.exit('lineEnding');
                    return contentStart;
                }
                function contentStart(code) {
                    return initialPrefix > 0 && markdownSpace(code)
                        ? factorySpace(
                              effects,
                              beforeContentChunk,
                              'linePrefix',
                              initialPrefix + 1
                          )(code)
                        : beforeContentChunk(code);
                }
                function beforeContentChunk(code) {
                    if (code === null || markdownLineEnding(code)) {
                        return effects.check(
                            nonLazyContinuation,
                            atNonLazyBreak,
                            after
                        )(code);
                    }
                    effects.enter('codeFlowValue');
                    return contentChunk(code);
                }
                function contentChunk(code) {
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('codeFlowValue');
                        return beforeContentChunk(code);
                    }
                    effects.consume(code);
                    return contentChunk;
                }
                function after(code) {
                    effects.exit('codeFenced');
                    return ok(code);
                }
                function tokenizeCloseStart(effects2, ok2, nok2) {
                    let size = 0;
                    return startBefore;
                    function startBefore(code) {
                        effects2.enter('lineEnding');
                        effects2.consume(code);
                        effects2.exit('lineEnding');
                        return start2;
                    }
                    function start2(code) {
                        effects2.enter('codeFencedFence');
                        return markdownSpace(code)
                            ? factorySpace(
                                  effects2,
                                  beforeSequenceClose,
                                  'linePrefix',
                                  self.parser.constructs.disable.null.includes(
                                      'codeIndented'
                                  )
                                      ? void 0
                                      : 4
                              )(code)
                            : beforeSequenceClose(code);
                    }
                    function beforeSequenceClose(code) {
                        if (code === marker) {
                            effects2.enter('codeFencedFenceSequence');
                            return sequenceClose(code);
                        }
                        return nok2(code);
                    }
                    function sequenceClose(code) {
                        if (code === marker) {
                            size++;
                            effects2.consume(code);
                            return sequenceClose;
                        }
                        if (size >= sizeOpen) {
                            effects2.exit('codeFencedFenceSequence');
                            return markdownSpace(code)
                                ? factorySpace(
                                      effects2,
                                      sequenceCloseAfter,
                                      'whitespace'
                                  )(code)
                                : sequenceCloseAfter(code);
                        }
                        return nok2(code);
                    }
                    function sequenceCloseAfter(code) {
                        if (code === null || markdownLineEnding(code)) {
                            effects2.exit('codeFencedFence');
                            return ok2(code);
                        }
                        return nok2(code);
                    }
                }
            }
            function tokenizeNonLazyContinuation(effects, ok, nok) {
                const self = this;
                return start;
                function start(code) {
                    if (code === null) {
                        return nok(code);
                    }
                    effects.enter('lineEnding');
                    effects.consume(code);
                    effects.exit('lineEnding');
                    return lineStart;
                }
                function lineStart(code) {
                    return self.parser.lazy[self.now().line]
                        ? nok(code)
                        : ok(code);
                }
            }
            const codeIndented = {
                name: 'codeIndented',
                tokenize: tokenizeCodeIndented,
            };
            const furtherStart = {
                tokenize: tokenizeFurtherStart,
                partial: true,
            };
            function tokenizeCodeIndented(effects, ok, nok) {
                const self = this;
                return start;
                function start(code) {
                    effects.enter('codeIndented');
                    return factorySpace(
                        effects,
                        afterPrefix,
                        'linePrefix',
                        4 + 1
                    )(code);
                }
                function afterPrefix(code) {
                    const tail = self.events[self.events.length - 1];
                    return tail &&
                        tail[1].type === 'linePrefix' &&
                        tail[2].sliceSerialize(tail[1], true).length >= 4
                        ? atBreak(code)
                        : nok(code);
                }
                function atBreak(code) {
                    if (code === null) {
                        return after(code);
                    }
                    if (markdownLineEnding(code)) {
                        return effects.attempt(
                            furtherStart,
                            atBreak,
                            after
                        )(code);
                    }
                    effects.enter('codeFlowValue');
                    return inside(code);
                }
                function inside(code) {
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('codeFlowValue');
                        return atBreak(code);
                    }
                    effects.consume(code);
                    return inside;
                }
                function after(code) {
                    effects.exit('codeIndented');
                    return ok(code);
                }
            }
            function tokenizeFurtherStart(effects, ok, nok) {
                const self = this;
                return furtherStart2;
                function furtherStart2(code) {
                    if (self.parser.lazy[self.now().line]) {
                        return nok(code);
                    }
                    if (markdownLineEnding(code)) {
                        effects.enter('lineEnding');
                        effects.consume(code);
                        effects.exit('lineEnding');
                        return furtherStart2;
                    }
                    return factorySpace(
                        effects,
                        afterPrefix,
                        'linePrefix',
                        4 + 1
                    )(code);
                }
                function afterPrefix(code) {
                    const tail = self.events[self.events.length - 1];
                    return tail &&
                        tail[1].type === 'linePrefix' &&
                        tail[2].sliceSerialize(tail[1], true).length >= 4
                        ? ok(code)
                        : markdownLineEnding(code)
                          ? furtherStart2(code)
                          : nok(code);
                }
            }
            const codeText = {
                name: 'codeText',
                tokenize: tokenizeCodeText,
                resolve: resolveCodeText,
                previous,
            };
            function resolveCodeText(events2) {
                let tailExitIndex = events2.length - 4;
                let headEnterIndex = 3;
                let index;
                let enter;
                if (
                    (events2[headEnterIndex][1].type === 'lineEnding' ||
                        events2[headEnterIndex][1].type === 'space') &&
                    (events2[tailExitIndex][1].type === 'lineEnding' ||
                        events2[tailExitIndex][1].type === 'space')
                ) {
                    index = headEnterIndex;
                    while (++index < tailExitIndex) {
                        if (events2[index][1].type === 'codeTextData') {
                            events2[headEnterIndex][1].type = 'codeTextPadding';
                            events2[tailExitIndex][1].type = 'codeTextPadding';
                            headEnterIndex += 2;
                            tailExitIndex -= 2;
                            break;
                        }
                    }
                }
                index = headEnterIndex - 1;
                tailExitIndex++;
                while (++index <= tailExitIndex) {
                    if (enter === void 0) {
                        if (
                            index !== tailExitIndex &&
                            events2[index][1].type !== 'lineEnding'
                        ) {
                            enter = index;
                        }
                    } else if (
                        index === tailExitIndex ||
                        events2[index][1].type === 'lineEnding'
                    ) {
                        events2[enter][1].type = 'codeTextData';
                        if (index !== enter + 2) {
                            events2[enter][1].end = events2[index - 1][1].end;
                            events2.splice(enter + 2, index - enter - 2);
                            tailExitIndex -= index - enter - 2;
                            index = enter + 2;
                        }
                        enter = void 0;
                    }
                }
                return events2;
            }
            function previous(code) {
                return (
                    code !== 96 ||
                    this.events[this.events.length - 1][1].type ===
                        'characterEscape'
                );
            }
            function tokenizeCodeText(effects, ok, nok) {
                let sizeOpen = 0;
                let size;
                let token;
                return start;
                function start(code) {
                    effects.enter('codeText');
                    effects.enter('codeTextSequence');
                    return sequenceOpen(code);
                }
                function sequenceOpen(code) {
                    if (code === 96) {
                        effects.consume(code);
                        sizeOpen++;
                        return sequenceOpen;
                    }
                    effects.exit('codeTextSequence');
                    return between(code);
                }
                function between(code) {
                    if (code === null) {
                        return nok(code);
                    }
                    if (code === 32) {
                        effects.enter('space');
                        effects.consume(code);
                        effects.exit('space');
                        return between;
                    }
                    if (code === 96) {
                        token = effects.enter('codeTextSequence');
                        size = 0;
                        return sequenceClose(code);
                    }
                    if (markdownLineEnding(code)) {
                        effects.enter('lineEnding');
                        effects.consume(code);
                        effects.exit('lineEnding');
                        return between;
                    }
                    effects.enter('codeTextData');
                    return data(code);
                }
                function data(code) {
                    if (
                        code === null ||
                        code === 32 ||
                        code === 96 ||
                        markdownLineEnding(code)
                    ) {
                        effects.exit('codeTextData');
                        return between(code);
                    }
                    effects.consume(code);
                    return data;
                }
                function sequenceClose(code) {
                    if (code === 96) {
                        effects.consume(code);
                        size++;
                        return sequenceClose;
                    }
                    if (size === sizeOpen) {
                        effects.exit('codeTextSequence');
                        effects.exit('codeText');
                        return ok(code);
                    }
                    token.type = 'codeTextData';
                    return data(code);
                }
            }
            function subtokenize(events2) {
                const jumps = {};
                let index = -1;
                let event;
                let lineIndex;
                let otherIndex;
                let otherEvent;
                let parameters;
                let subevents;
                let more;
                while (++index < events2.length) {
                    while (index in jumps) {
                        index = jumps[index];
                    }
                    event = events2[index];
                    if (
                        index &&
                        event[1].type === 'chunkFlow' &&
                        events2[index - 1][1].type === 'listItemPrefix'
                    ) {
                        subevents = event[1]._tokenizer.events;
                        otherIndex = 0;
                        if (
                            otherIndex < subevents.length &&
                            subevents[otherIndex][1].type === 'lineEndingBlank'
                        ) {
                            otherIndex += 2;
                        }
                        if (
                            otherIndex < subevents.length &&
                            subevents[otherIndex][1].type === 'content'
                        ) {
                            while (++otherIndex < subevents.length) {
                                if (
                                    subevents[otherIndex][1].type === 'content'
                                ) {
                                    break;
                                }
                                if (
                                    subevents[otherIndex][1].type ===
                                    'chunkText'
                                ) {
                                    subevents[
                                        otherIndex
                                    ][1]._isInFirstContentOfListItem = true;
                                    otherIndex++;
                                }
                            }
                        }
                    }
                    if (event[0] === 'enter') {
                        if (event[1].contentType) {
                            Object.assign(jumps, subcontent(events2, index));
                            index = jumps[index];
                            more = true;
                        }
                    } else if (event[1]._container) {
                        otherIndex = index;
                        lineIndex = void 0;
                        while (otherIndex--) {
                            otherEvent = events2[otherIndex];
                            if (
                                otherEvent[1].type === 'lineEnding' ||
                                otherEvent[1].type === 'lineEndingBlank'
                            ) {
                                if (otherEvent[0] === 'enter') {
                                    if (lineIndex) {
                                        events2[lineIndex][1].type =
                                            'lineEndingBlank';
                                    }
                                    otherEvent[1].type = 'lineEnding';
                                    lineIndex = otherIndex;
                                }
                            } else {
                                break;
                            }
                        }
                        if (lineIndex) {
                            event[1].end = Object.assign(
                                {},
                                events2[lineIndex][1].start
                            );
                            parameters = events2.slice(lineIndex, index);
                            parameters.unshift(event);
                            splice(
                                events2,
                                lineIndex,
                                index - lineIndex + 1,
                                parameters
                            );
                        }
                    }
                }
                return !more;
            }
            function subcontent(events2, eventIndex) {
                const token = events2[eventIndex][1];
                const context = events2[eventIndex][2];
                let startPosition = eventIndex - 1;
                const startPositions = [];
                const tokenizer =
                    token._tokenizer ||
                    context.parser[token.contentType](token.start);
                const childEvents = tokenizer.events;
                const jumps = [];
                const gaps = {};
                let stream;
                let previous2;
                let index = -1;
                let current = token;
                let adjust = 0;
                let start = 0;
                const breaks = [start];
                while (current) {
                    while (events2[++startPosition][1] !== current) {}
                    startPositions.push(startPosition);
                    if (!current._tokenizer) {
                        stream = context.sliceStream(current);
                        if (!current.next) {
                            stream.push(null);
                        }
                        if (previous2) {
                            tokenizer.defineSkip(current.start);
                        }
                        if (current._isInFirstContentOfListItem) {
                            tokenizer._gfmTasklistFirstContentOfListItem = true;
                        }
                        tokenizer.write(stream);
                        if (current._isInFirstContentOfListItem) {
                            tokenizer._gfmTasklistFirstContentOfListItem =
                                void 0;
                        }
                    }
                    previous2 = current;
                    current = current.next;
                }
                current = token;
                while (++index < childEvents.length) {
                    if (
                        // Find a void token that includes a break.
                        childEvents[index][0] === 'exit' &&
                        childEvents[index - 1][0] === 'enter' &&
                        childEvents[index][1].type ===
                            childEvents[index - 1][1].type &&
                        childEvents[index][1].start.line !==
                            childEvents[index][1].end.line
                    ) {
                        start = index + 1;
                        breaks.push(start);
                        current._tokenizer = void 0;
                        current.previous = void 0;
                        current = current.next;
                    }
                }
                tokenizer.events = [];
                if (current) {
                    current._tokenizer = void 0;
                    current.previous = void 0;
                } else {
                    breaks.pop();
                }
                index = breaks.length;
                while (index--) {
                    const slice = childEvents.slice(
                        breaks[index],
                        breaks[index + 1]
                    );
                    const start2 = startPositions.pop();
                    jumps.unshift([start2, start2 + slice.length - 1]);
                    splice(events2, start2, 2, slice);
                }
                index = -1;
                while (++index < jumps.length) {
                    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];
                    adjust += jumps[index][1] - jumps[index][0] - 1;
                }
                return gaps;
            }
            const content = {
                tokenize: tokenizeContent,
                resolve: resolveContent,
            };
            const continuationConstruct = {
                tokenize: tokenizeContinuation,
                partial: true,
            };
            function resolveContent(events2) {
                subtokenize(events2);
                return events2;
            }
            function tokenizeContent(effects, ok) {
                let previous2;
                return chunkStart;
                function chunkStart(code) {
                    effects.enter('content');
                    previous2 = effects.enter('chunkContent', {
                        contentType: 'content',
                    });
                    return chunkInside(code);
                }
                function chunkInside(code) {
                    if (code === null) {
                        return contentEnd(code);
                    }
                    if (markdownLineEnding(code)) {
                        return effects.check(
                            continuationConstruct,
                            contentContinue,
                            contentEnd
                        )(code);
                    }
                    effects.consume(code);
                    return chunkInside;
                }
                function contentEnd(code) {
                    effects.exit('chunkContent');
                    effects.exit('content');
                    return ok(code);
                }
                function contentContinue(code) {
                    effects.consume(code);
                    effects.exit('chunkContent');
                    previous2.next = effects.enter('chunkContent', {
                        contentType: 'content',
                        previous: previous2,
                    });
                    previous2 = previous2.next;
                    return chunkInside;
                }
            }
            function tokenizeContinuation(effects, ok, nok) {
                const self = this;
                return startLookahead;
                function startLookahead(code) {
                    effects.exit('chunkContent');
                    effects.enter('lineEnding');
                    effects.consume(code);
                    effects.exit('lineEnding');
                    return factorySpace(effects, prefixed, 'linePrefix');
                }
                function prefixed(code) {
                    if (code === null || markdownLineEnding(code)) {
                        return nok(code);
                    }
                    const tail = self.events[self.events.length - 1];
                    if (
                        !self.parser.constructs.disable.null.includes(
                            'codeIndented'
                        ) &&
                        tail &&
                        tail[1].type === 'linePrefix' &&
                        tail[2].sliceSerialize(tail[1], true).length >= 4
                    ) {
                        return ok(code);
                    }
                    return effects.interrupt(
                        self.parser.constructs.flow,
                        nok,
                        ok
                    )(code);
                }
            }
            function factoryDestination(
                effects,
                ok,
                nok,
                type,
                literalType,
                literalMarkerType,
                rawType,
                stringType,
                max
            ) {
                const limit = max || Number.POSITIVE_INFINITY;
                let balance = 0;
                return start;
                function start(code) {
                    if (code === 60) {
                        effects.enter(type);
                        effects.enter(literalType);
                        effects.enter(literalMarkerType);
                        effects.consume(code);
                        effects.exit(literalMarkerType);
                        return enclosedBefore;
                    }
                    if (
                        code === null ||
                        code === 32 ||
                        code === 41 ||
                        asciiControl(code)
                    ) {
                        return nok(code);
                    }
                    effects.enter(type);
                    effects.enter(rawType);
                    effects.enter(stringType);
                    effects.enter('chunkString', {
                        contentType: 'string',
                    });
                    return raw(code);
                }
                function enclosedBefore(code) {
                    if (code === 62) {
                        effects.enter(literalMarkerType);
                        effects.consume(code);
                        effects.exit(literalMarkerType);
                        effects.exit(literalType);
                        effects.exit(type);
                        return ok;
                    }
                    effects.enter(stringType);
                    effects.enter('chunkString', {
                        contentType: 'string',
                    });
                    return enclosed(code);
                }
                function enclosed(code) {
                    if (code === 62) {
                        effects.exit('chunkString');
                        effects.exit(stringType);
                        return enclosedBefore(code);
                    }
                    if (
                        code === null ||
                        code === 60 ||
                        markdownLineEnding(code)
                    ) {
                        return nok(code);
                    }
                    effects.consume(code);
                    return code === 92 ? enclosedEscape : enclosed;
                }
                function enclosedEscape(code) {
                    if (code === 60 || code === 62 || code === 92) {
                        effects.consume(code);
                        return enclosed;
                    }
                    return enclosed(code);
                }
                function raw(code) {
                    if (
                        !balance &&
                        (code === null ||
                            code === 41 ||
                            markdownLineEndingOrSpace(code))
                    ) {
                        effects.exit('chunkString');
                        effects.exit(stringType);
                        effects.exit(rawType);
                        effects.exit(type);
                        return ok(code);
                    }
                    if (balance < limit && code === 40) {
                        effects.consume(code);
                        balance++;
                        return raw;
                    }
                    if (code === 41) {
                        effects.consume(code);
                        balance--;
                        return raw;
                    }
                    if (
                        code === null ||
                        code === 32 ||
                        code === 40 ||
                        asciiControl(code)
                    ) {
                        return nok(code);
                    }
                    effects.consume(code);
                    return code === 92 ? rawEscape : raw;
                }
                function rawEscape(code) {
                    if (code === 40 || code === 41 || code === 92) {
                        effects.consume(code);
                        return raw;
                    }
                    return raw(code);
                }
            }
            function factoryLabel(
                effects,
                ok,
                nok,
                type,
                markerType,
                stringType
            ) {
                const self = this;
                let size = 0;
                let seen;
                return start;
                function start(code) {
                    effects.enter(type);
                    effects.enter(markerType);
                    effects.consume(code);
                    effects.exit(markerType);
                    effects.enter(stringType);
                    return atBreak;
                }
                function atBreak(code) {
                    if (
                        size > 999 ||
                        code === null ||
                        code === 91 ||
                        (code === 93 && !seen) || // To do: remove in the future once we’ve switched from
                        // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
                        // which doesn’t need this.
                        // Hidden footnotes hook.
                        /* c8 ignore next 3 */
                        (code === 94 &&
                            !size &&
                            '_hiddenFootnoteSupport' in self.parser.constructs)
                    ) {
                        return nok(code);
                    }
                    if (code === 93) {
                        effects.exit(stringType);
                        effects.enter(markerType);
                        effects.consume(code);
                        effects.exit(markerType);
                        effects.exit(type);
                        return ok;
                    }
                    if (markdownLineEnding(code)) {
                        effects.enter('lineEnding');
                        effects.consume(code);
                        effects.exit('lineEnding');
                        return atBreak;
                    }
                    effects.enter('chunkString', {
                        contentType: 'string',
                    });
                    return labelInside(code);
                }
                function labelInside(code) {
                    if (
                        code === null ||
                        code === 91 ||
                        code === 93 ||
                        markdownLineEnding(code) ||
                        size++ > 999
                    ) {
                        effects.exit('chunkString');
                        return atBreak(code);
                    }
                    effects.consume(code);
                    if (!seen) seen = !markdownSpace(code);
                    return code === 92 ? labelEscape : labelInside;
                }
                function labelEscape(code) {
                    if (code === 91 || code === 92 || code === 93) {
                        effects.consume(code);
                        size++;
                        return labelInside;
                    }
                    return labelInside(code);
                }
            }
            function factoryTitle(
                effects,
                ok,
                nok,
                type,
                markerType,
                stringType
            ) {
                let marker;
                return start;
                function start(code) {
                    if (code === 34 || code === 39 || code === 40) {
                        effects.enter(type);
                        effects.enter(markerType);
                        effects.consume(code);
                        effects.exit(markerType);
                        marker = code === 40 ? 41 : code;
                        return begin;
                    }
                    return nok(code);
                }
                function begin(code) {
                    if (code === marker) {
                        effects.enter(markerType);
                        effects.consume(code);
                        effects.exit(markerType);
                        effects.exit(type);
                        return ok;
                    }
                    effects.enter(stringType);
                    return atBreak(code);
                }
                function atBreak(code) {
                    if (code === marker) {
                        effects.exit(stringType);
                        return begin(marker);
                    }
                    if (code === null) {
                        return nok(code);
                    }
                    if (markdownLineEnding(code)) {
                        effects.enter('lineEnding');
                        effects.consume(code);
                        effects.exit('lineEnding');
                        return factorySpace(effects, atBreak, 'linePrefix');
                    }
                    effects.enter('chunkString', {
                        contentType: 'string',
                    });
                    return inside(code);
                }
                function inside(code) {
                    if (
                        code === marker ||
                        code === null ||
                        markdownLineEnding(code)
                    ) {
                        effects.exit('chunkString');
                        return atBreak(code);
                    }
                    effects.consume(code);
                    return code === 92 ? escape2 : inside;
                }
                function escape2(code) {
                    if (code === marker || code === 92) {
                        effects.consume(code);
                        return inside;
                    }
                    return inside(code);
                }
            }
            function factoryWhitespace(effects, ok) {
                let seen;
                return start;
                function start(code) {
                    if (markdownLineEnding(code)) {
                        effects.enter('lineEnding');
                        effects.consume(code);
                        effects.exit('lineEnding');
                        seen = true;
                        return start;
                    }
                    if (markdownSpace(code)) {
                        return factorySpace(
                            effects,
                            start,
                            seen ? 'linePrefix' : 'lineSuffix'
                        )(code);
                    }
                    return ok(code);
                }
            }
            const definition = {
                name: 'definition',
                tokenize: tokenizeDefinition,
            };
            const titleBefore = {
                tokenize: tokenizeTitleBefore,
                partial: true,
            };
            function tokenizeDefinition(effects, ok, nok) {
                const self = this;
                let identifier;
                return start;
                function start(code) {
                    effects.enter('definition');
                    return before(code);
                }
                function before(code) {
                    return factoryLabel.call(
                        self,
                        effects,
                        labelAfter,
                        // Note: we don’t need to reset the way `markdown-rs` does.
                        nok,
                        'definitionLabel',
                        'definitionLabelMarker',
                        'definitionLabelString'
                    )(code);
                }
                function labelAfter(code) {
                    identifier = normalizeIdentifier(
                        self
                            .sliceSerialize(
                                self.events[self.events.length - 1][1]
                            )
                            .slice(1, -1)
                    );
                    if (code === 58) {
                        effects.enter('definitionMarker');
                        effects.consume(code);
                        effects.exit('definitionMarker');
                        return markerAfter;
                    }
                    return nok(code);
                }
                function markerAfter(code) {
                    return markdownLineEndingOrSpace(code)
                        ? factoryWhitespace(effects, destinationBefore)(code)
                        : destinationBefore(code);
                }
                function destinationBefore(code) {
                    return factoryDestination(
                        effects,
                        destinationAfter,
                        // Note: we don’t need to reset the way `markdown-rs` does.
                        nok,
                        'definitionDestination',
                        'definitionDestinationLiteral',
                        'definitionDestinationLiteralMarker',
                        'definitionDestinationRaw',
                        'definitionDestinationString'
                    )(code);
                }
                function destinationAfter(code) {
                    return effects.attempt(titleBefore, after, after)(code);
                }
                function after(code) {
                    return markdownSpace(code)
                        ? factorySpace(
                              effects,
                              afterWhitespace,
                              'whitespace'
                          )(code)
                        : afterWhitespace(code);
                }
                function afterWhitespace(code) {
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('definition');
                        self.parser.defined.push(identifier);
                        return ok(code);
                    }
                    return nok(code);
                }
            }
            function tokenizeTitleBefore(effects, ok, nok) {
                return titleBefore2;
                function titleBefore2(code) {
                    return markdownLineEndingOrSpace(code)
                        ? factoryWhitespace(effects, beforeMarker)(code)
                        : nok(code);
                }
                function beforeMarker(code) {
                    return factoryTitle(
                        effects,
                        titleAfter,
                        nok,
                        'definitionTitle',
                        'definitionTitleMarker',
                        'definitionTitleString'
                    )(code);
                }
                function titleAfter(code) {
                    return markdownSpace(code)
                        ? factorySpace(
                              effects,
                              titleAfterOptionalWhitespace,
                              'whitespace'
                          )(code)
                        : titleAfterOptionalWhitespace(code);
                }
                function titleAfterOptionalWhitespace(code) {
                    return code === null || markdownLineEnding(code)
                        ? ok(code)
                        : nok(code);
                }
            }
            const hardBreakEscape = {
                name: 'hardBreakEscape',
                tokenize: tokenizeHardBreakEscape,
            };
            function tokenizeHardBreakEscape(effects, ok, nok) {
                return start;
                function start(code) {
                    effects.enter('hardBreakEscape');
                    effects.consume(code);
                    return after;
                }
                function after(code) {
                    if (markdownLineEnding(code)) {
                        effects.exit('hardBreakEscape');
                        return ok(code);
                    }
                    return nok(code);
                }
            }
            const headingAtx = {
                name: 'headingAtx',
                tokenize: tokenizeHeadingAtx,
                resolve: resolveHeadingAtx,
            };
            function resolveHeadingAtx(events2, context) {
                let contentEnd = events2.length - 2;
                let contentStart = 3;
                let content2;
                let text2;
                if (events2[contentStart][1].type === 'whitespace') {
                    contentStart += 2;
                }
                if (
                    contentEnd - 2 > contentStart &&
                    events2[contentEnd][1].type === 'whitespace'
                ) {
                    contentEnd -= 2;
                }
                if (
                    events2[contentEnd][1].type === 'atxHeadingSequence' &&
                    (contentStart === contentEnd - 1 ||
                        (contentEnd - 4 > contentStart &&
                            events2[contentEnd - 2][1].type === 'whitespace'))
                ) {
                    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
                }
                if (contentEnd > contentStart) {
                    content2 = {
                        type: 'atxHeadingText',
                        start: events2[contentStart][1].start,
                        end: events2[contentEnd][1].end,
                    };
                    text2 = {
                        type: 'chunkText',
                        start: events2[contentStart][1].start,
                        end: events2[contentEnd][1].end,
                        contentType: 'text',
                    };
                    splice(
                        events2,
                        contentStart,
                        contentEnd - contentStart + 1,
                        [
                            ['enter', content2, context],
                            ['enter', text2, context],
                            ['exit', text2, context],
                            ['exit', content2, context],
                        ]
                    );
                }
                return events2;
            }
            function tokenizeHeadingAtx(effects, ok, nok) {
                let size = 0;
                return start;
                function start(code) {
                    effects.enter('atxHeading');
                    return before(code);
                }
                function before(code) {
                    effects.enter('atxHeadingSequence');
                    return sequenceOpen(code);
                }
                function sequenceOpen(code) {
                    if (code === 35 && size++ < 6) {
                        effects.consume(code);
                        return sequenceOpen;
                    }
                    if (code === null || markdownLineEndingOrSpace(code)) {
                        effects.exit('atxHeadingSequence');
                        return atBreak(code);
                    }
                    return nok(code);
                }
                function atBreak(code) {
                    if (code === 35) {
                        effects.enter('atxHeadingSequence');
                        return sequenceFurther(code);
                    }
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('atxHeading');
                        return ok(code);
                    }
                    if (markdownSpace(code)) {
                        return factorySpace(
                            effects,
                            atBreak,
                            'whitespace'
                        )(code);
                    }
                    effects.enter('atxHeadingText');
                    return data(code);
                }
                function sequenceFurther(code) {
                    if (code === 35) {
                        effects.consume(code);
                        return sequenceFurther;
                    }
                    effects.exit('atxHeadingSequence');
                    return atBreak(code);
                }
                function data(code) {
                    if (
                        code === null ||
                        code === 35 ||
                        markdownLineEndingOrSpace(code)
                    ) {
                        effects.exit('atxHeadingText');
                        return atBreak(code);
                    }
                    effects.consume(code);
                    return data;
                }
            }
            const htmlBlockNames = [
                'address',
                'article',
                'aside',
                'base',
                'basefont',
                'blockquote',
                'body',
                'caption',
                'center',
                'col',
                'colgroup',
                'dd',
                'details',
                'dialog',
                'dir',
                'div',
                'dl',
                'dt',
                'fieldset',
                'figcaption',
                'figure',
                'footer',
                'form',
                'frame',
                'frameset',
                'h1',
                'h2',
                'h3',
                'h4',
                'h5',
                'h6',
                'head',
                'header',
                'hr',
                'html',
                'iframe',
                'legend',
                'li',
                'link',
                'main',
                'menu',
                'menuitem',
                'nav',
                'noframes',
                'ol',
                'optgroup',
                'option',
                'p',
                'param',
                'search',
                'section',
                'summary',
                'table',
                'tbody',
                'td',
                'tfoot',
                'th',
                'thead',
                'title',
                'tr',
                'track',
                'ul',
            ];
            const htmlRawNames = ['pre', 'script', 'style', 'textarea'];
            const htmlFlow = {
                name: 'htmlFlow',
                tokenize: tokenizeHtmlFlow,
                resolveTo: resolveToHtmlFlow,
                concrete: true,
            };
            const blankLineBefore = {
                tokenize: tokenizeBlankLineBefore,
                partial: true,
            };
            const nonLazyContinuationStart = {
                tokenize: tokenizeNonLazyContinuationStart,
                partial: true,
            };
            function resolveToHtmlFlow(events2) {
                let index = events2.length;
                while (index--) {
                    if (
                        events2[index][0] === 'enter' &&
                        events2[index][1].type === 'htmlFlow'
                    ) {
                        break;
                    }
                }
                if (index > 1 && events2[index - 2][1].type === 'linePrefix') {
                    events2[index][1].start = events2[index - 2][1].start;
                    events2[index + 1][1].start = events2[index - 2][1].start;
                    events2.splice(index - 2, 2);
                }
                return events2;
            }
            function tokenizeHtmlFlow(effects, ok, nok) {
                const self = this;
                let marker;
                let closingTag;
                let buffer;
                let index;
                let markerB;
                return start;
                function start(code) {
                    return before(code);
                }
                function before(code) {
                    effects.enter('htmlFlow');
                    effects.enter('htmlFlowData');
                    effects.consume(code);
                    return open;
                }
                function open(code) {
                    if (code === 33) {
                        effects.consume(code);
                        return declarationOpen;
                    }
                    if (code === 47) {
                        effects.consume(code);
                        closingTag = true;
                        return tagCloseStart;
                    }
                    if (code === 63) {
                        effects.consume(code);
                        marker = 3;
                        return self.interrupt
                            ? ok
                            : continuationDeclarationInside;
                    }
                    if (asciiAlpha(code)) {
                        effects.consume(code);
                        buffer = String.fromCharCode(code);
                        return tagName;
                    }
                    return nok(code);
                }
                function declarationOpen(code) {
                    if (code === 45) {
                        effects.consume(code);
                        marker = 2;
                        return commentOpenInside;
                    }
                    if (code === 91) {
                        effects.consume(code);
                        marker = 5;
                        index = 0;
                        return cdataOpenInside;
                    }
                    if (asciiAlpha(code)) {
                        effects.consume(code);
                        marker = 4;
                        return self.interrupt
                            ? ok
                            : continuationDeclarationInside;
                    }
                    return nok(code);
                }
                function commentOpenInside(code) {
                    if (code === 45) {
                        effects.consume(code);
                        return self.interrupt
                            ? ok
                            : continuationDeclarationInside;
                    }
                    return nok(code);
                }
                function cdataOpenInside(code) {
                    const value = 'CDATA[';
                    if (code === value.charCodeAt(index++)) {
                        effects.consume(code);
                        if (index === value.length) {
                            return self.interrupt ? ok : continuation;
                        }
                        return cdataOpenInside;
                    }
                    return nok(code);
                }
                function tagCloseStart(code) {
                    if (asciiAlpha(code)) {
                        effects.consume(code);
                        buffer = String.fromCharCode(code);
                        return tagName;
                    }
                    return nok(code);
                }
                function tagName(code) {
                    if (
                        code === null ||
                        code === 47 ||
                        code === 62 ||
                        markdownLineEndingOrSpace(code)
                    ) {
                        const slash = code === 47;
                        const name = buffer.toLowerCase();
                        if (
                            !slash &&
                            !closingTag &&
                            htmlRawNames.includes(name)
                        ) {
                            marker = 1;
                            return self.interrupt
                                ? ok(code)
                                : continuation(code);
                        }
                        if (htmlBlockNames.includes(buffer.toLowerCase())) {
                            marker = 6;
                            if (slash) {
                                effects.consume(code);
                                return basicSelfClosing;
                            }
                            return self.interrupt
                                ? ok(code)
                                : continuation(code);
                        }
                        marker = 7;
                        return self.interrupt &&
                            !self.parser.lazy[self.now().line]
                            ? nok(code)
                            : closingTag
                              ? completeClosingTagAfter(code)
                              : completeAttributeNameBefore(code);
                    }
                    if (code === 45 || asciiAlphanumeric(code)) {
                        effects.consume(code);
                        buffer += String.fromCharCode(code);
                        return tagName;
                    }
                    return nok(code);
                }
                function basicSelfClosing(code) {
                    if (code === 62) {
                        effects.consume(code);
                        return self.interrupt ? ok : continuation;
                    }
                    return nok(code);
                }
                function completeClosingTagAfter(code) {
                    if (markdownSpace(code)) {
                        effects.consume(code);
                        return completeClosingTagAfter;
                    }
                    return completeEnd(code);
                }
                function completeAttributeNameBefore(code) {
                    if (code === 47) {
                        effects.consume(code);
                        return completeEnd;
                    }
                    if (code === 58 || code === 95 || asciiAlpha(code)) {
                        effects.consume(code);
                        return completeAttributeName;
                    }
                    if (markdownSpace(code)) {
                        effects.consume(code);
                        return completeAttributeNameBefore;
                    }
                    return completeEnd(code);
                }
                function completeAttributeName(code) {
                    if (
                        code === 45 ||
                        code === 46 ||
                        code === 58 ||
                        code === 95 ||
                        asciiAlphanumeric(code)
                    ) {
                        effects.consume(code);
                        return completeAttributeName;
                    }
                    return completeAttributeNameAfter(code);
                }
                function completeAttributeNameAfter(code) {
                    if (code === 61) {
                        effects.consume(code);
                        return completeAttributeValueBefore;
                    }
                    if (markdownSpace(code)) {
                        effects.consume(code);
                        return completeAttributeNameAfter;
                    }
                    return completeAttributeNameBefore(code);
                }
                function completeAttributeValueBefore(code) {
                    if (
                        code === null ||
                        code === 60 ||
                        code === 61 ||
                        code === 62 ||
                        code === 96
                    ) {
                        return nok(code);
                    }
                    if (code === 34 || code === 39) {
                        effects.consume(code);
                        markerB = code;
                        return completeAttributeValueQuoted;
                    }
                    if (markdownSpace(code)) {
                        effects.consume(code);
                        return completeAttributeValueBefore;
                    }
                    return completeAttributeValueUnquoted(code);
                }
                function completeAttributeValueQuoted(code) {
                    if (code === markerB) {
                        effects.consume(code);
                        markerB = null;
                        return completeAttributeValueQuotedAfter;
                    }
                    if (code === null || markdownLineEnding(code)) {
                        return nok(code);
                    }
                    effects.consume(code);
                    return completeAttributeValueQuoted;
                }
                function completeAttributeValueUnquoted(code) {
                    if (
                        code === null ||
                        code === 34 ||
                        code === 39 ||
                        code === 47 ||
                        code === 60 ||
                        code === 61 ||
                        code === 62 ||
                        code === 96 ||
                        markdownLineEndingOrSpace(code)
                    ) {
                        return completeAttributeNameAfter(code);
                    }
                    effects.consume(code);
                    return completeAttributeValueUnquoted;
                }
                function completeAttributeValueQuotedAfter(code) {
                    if (code === 47 || code === 62 || markdownSpace(code)) {
                        return completeAttributeNameBefore(code);
                    }
                    return nok(code);
                }
                function completeEnd(code) {
                    if (code === 62) {
                        effects.consume(code);
                        return completeAfter;
                    }
                    return nok(code);
                }
                function completeAfter(code) {
                    if (code === null || markdownLineEnding(code)) {
                        return continuation(code);
                    }
                    if (markdownSpace(code)) {
                        effects.consume(code);
                        return completeAfter;
                    }
                    return nok(code);
                }
                function continuation(code) {
                    if (code === 45 && marker === 2) {
                        effects.consume(code);
                        return continuationCommentInside;
                    }
                    if (code === 60 && marker === 1) {
                        effects.consume(code);
                        return continuationRawTagOpen;
                    }
                    if (code === 62 && marker === 4) {
                        effects.consume(code);
                        return continuationClose;
                    }
                    if (code === 63 && marker === 3) {
                        effects.consume(code);
                        return continuationDeclarationInside;
                    }
                    if (code === 93 && marker === 5) {
                        effects.consume(code);
                        return continuationCdataInside;
                    }
                    if (
                        markdownLineEnding(code) &&
                        (marker === 6 || marker === 7)
                    ) {
                        effects.exit('htmlFlowData');
                        return effects.check(
                            blankLineBefore,
                            continuationAfter,
                            continuationStart
                        )(code);
                    }
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('htmlFlowData');
                        return continuationStart(code);
                    }
                    effects.consume(code);
                    return continuation;
                }
                function continuationStart(code) {
                    return effects.check(
                        nonLazyContinuationStart,
                        continuationStartNonLazy,
                        continuationAfter
                    )(code);
                }
                function continuationStartNonLazy(code) {
                    effects.enter('lineEnding');
                    effects.consume(code);
                    effects.exit('lineEnding');
                    return continuationBefore;
                }
                function continuationBefore(code) {
                    if (code === null || markdownLineEnding(code)) {
                        return continuationStart(code);
                    }
                    effects.enter('htmlFlowData');
                    return continuation(code);
                }
                function continuationCommentInside(code) {
                    if (code === 45) {
                        effects.consume(code);
                        return continuationDeclarationInside;
                    }
                    return continuation(code);
                }
                function continuationRawTagOpen(code) {
                    if (code === 47) {
                        effects.consume(code);
                        buffer = '';
                        return continuationRawEndTag;
                    }
                    return continuation(code);
                }
                function continuationRawEndTag(code) {
                    if (code === 62) {
                        const name = buffer.toLowerCase();
                        if (htmlRawNames.includes(name)) {
                            effects.consume(code);
                            return continuationClose;
                        }
                        return continuation(code);
                    }
                    if (asciiAlpha(code) && buffer.length < 8) {
                        effects.consume(code);
                        buffer += String.fromCharCode(code);
                        return continuationRawEndTag;
                    }
                    return continuation(code);
                }
                function continuationCdataInside(code) {
                    if (code === 93) {
                        effects.consume(code);
                        return continuationDeclarationInside;
                    }
                    return continuation(code);
                }
                function continuationDeclarationInside(code) {
                    if (code === 62) {
                        effects.consume(code);
                        return continuationClose;
                    }
                    if (code === 45 && marker === 2) {
                        effects.consume(code);
                        return continuationDeclarationInside;
                    }
                    return continuation(code);
                }
                function continuationClose(code) {
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('htmlFlowData');
                        return continuationAfter(code);
                    }
                    effects.consume(code);
                    return continuationClose;
                }
                function continuationAfter(code) {
                    effects.exit('htmlFlow');
                    return ok(code);
                }
            }
            function tokenizeNonLazyContinuationStart(effects, ok, nok) {
                const self = this;
                return start;
                function start(code) {
                    if (markdownLineEnding(code)) {
                        effects.enter('lineEnding');
                        effects.consume(code);
                        effects.exit('lineEnding');
                        return after;
                    }
                    return nok(code);
                }
                function after(code) {
                    return self.parser.lazy[self.now().line]
                        ? nok(code)
                        : ok(code);
                }
            }
            function tokenizeBlankLineBefore(effects, ok, nok) {
                return start;
                function start(code) {
                    effects.enter('lineEnding');
                    effects.consume(code);
                    effects.exit('lineEnding');
                    return effects.attempt(blankLine, ok, nok);
                }
            }
            const htmlText = {
                name: 'htmlText',
                tokenize: tokenizeHtmlText,
            };
            function tokenizeHtmlText(effects, ok, nok) {
                const self = this;
                let marker;
                let index;
                let returnState;
                return start;
                function start(code) {
                    effects.enter('htmlText');
                    effects.enter('htmlTextData');
                    effects.consume(code);
                    return open;
                }
                function open(code) {
                    if (code === 33) {
                        effects.consume(code);
                        return declarationOpen;
                    }
                    if (code === 47) {
                        effects.consume(code);
                        return tagCloseStart;
                    }
                    if (code === 63) {
                        effects.consume(code);
                        return instruction;
                    }
                    if (asciiAlpha(code)) {
                        effects.consume(code);
                        return tagOpen;
                    }
                    return nok(code);
                }
                function declarationOpen(code) {
                    if (code === 45) {
                        effects.consume(code);
                        return commentOpenInside;
                    }
                    if (code === 91) {
                        effects.consume(code);
                        index = 0;
                        return cdataOpenInside;
                    }
                    if (asciiAlpha(code)) {
                        effects.consume(code);
                        return declaration;
                    }
                    return nok(code);
                }
                function commentOpenInside(code) {
                    if (code === 45) {
                        effects.consume(code);
                        return commentEnd;
                    }
                    return nok(code);
                }
                function comment(code) {
                    if (code === null) {
                        return nok(code);
                    }
                    if (code === 45) {
                        effects.consume(code);
                        return commentClose;
                    }
                    if (markdownLineEnding(code)) {
                        returnState = comment;
                        return lineEndingBefore(code);
                    }
                    effects.consume(code);
                    return comment;
                }
                function commentClose(code) {
                    if (code === 45) {
                        effects.consume(code);
                        return commentEnd;
                    }
                    return comment(code);
                }
                function commentEnd(code) {
                    return code === 62
                        ? end(code)
                        : code === 45
                          ? commentClose(code)
                          : comment(code);
                }
                function cdataOpenInside(code) {
                    const value = 'CDATA[';
                    if (code === value.charCodeAt(index++)) {
                        effects.consume(code);
                        return index === value.length ? cdata : cdataOpenInside;
                    }
                    return nok(code);
                }
                function cdata(code) {
                    if (code === null) {
                        return nok(code);
                    }
                    if (code === 93) {
                        effects.consume(code);
                        return cdataClose;
                    }
                    if (markdownLineEnding(code)) {
                        returnState = cdata;
                        return lineEndingBefore(code);
                    }
                    effects.consume(code);
                    return cdata;
                }
                function cdataClose(code) {
                    if (code === 93) {
                        effects.consume(code);
                        return cdataEnd;
                    }
                    return cdata(code);
                }
                function cdataEnd(code) {
                    if (code === 62) {
                        return end(code);
                    }
                    if (code === 93) {
                        effects.consume(code);
                        return cdataEnd;
                    }
                    return cdata(code);
                }
                function declaration(code) {
                    if (code === null || code === 62) {
                        return end(code);
                    }
                    if (markdownLineEnding(code)) {
                        returnState = declaration;
                        return lineEndingBefore(code);
                    }
                    effects.consume(code);
                    return declaration;
                }
                function instruction(code) {
                    if (code === null) {
                        return nok(code);
                    }
                    if (code === 63) {
                        effects.consume(code);
                        return instructionClose;
                    }
                    if (markdownLineEnding(code)) {
                        returnState = instruction;
                        return lineEndingBefore(code);
                    }
                    effects.consume(code);
                    return instruction;
                }
                function instructionClose(code) {
                    return code === 62 ? end(code) : instruction(code);
                }
                function tagCloseStart(code) {
                    if (asciiAlpha(code)) {
                        effects.consume(code);
                        return tagClose;
                    }
                    return nok(code);
                }
                function tagClose(code) {
                    if (code === 45 || asciiAlphanumeric(code)) {
                        effects.consume(code);
                        return tagClose;
                    }
                    return tagCloseBetween(code);
                }
                function tagCloseBetween(code) {
                    if (markdownLineEnding(code)) {
                        returnState = tagCloseBetween;
                        return lineEndingBefore(code);
                    }
                    if (markdownSpace(code)) {
                        effects.consume(code);
                        return tagCloseBetween;
                    }
                    return end(code);
                }
                function tagOpen(code) {
                    if (code === 45 || asciiAlphanumeric(code)) {
                        effects.consume(code);
                        return tagOpen;
                    }
                    if (
                        code === 47 ||
                        code === 62 ||
                        markdownLineEndingOrSpace(code)
                    ) {
                        return tagOpenBetween(code);
                    }
                    return nok(code);
                }
                function tagOpenBetween(code) {
                    if (code === 47) {
                        effects.consume(code);
                        return end;
                    }
                    if (code === 58 || code === 95 || asciiAlpha(code)) {
                        effects.consume(code);
                        return tagOpenAttributeName;
                    }
                    if (markdownLineEnding(code)) {
                        returnState = tagOpenBetween;
                        return lineEndingBefore(code);
                    }
                    if (markdownSpace(code)) {
                        effects.consume(code);
                        return tagOpenBetween;
                    }
                    return end(code);
                }
                function tagOpenAttributeName(code) {
                    if (
                        code === 45 ||
                        code === 46 ||
                        code === 58 ||
                        code === 95 ||
                        asciiAlphanumeric(code)
                    ) {
                        effects.consume(code);
                        return tagOpenAttributeName;
                    }
                    return tagOpenAttributeNameAfter(code);
                }
                function tagOpenAttributeNameAfter(code) {
                    if (code === 61) {
                        effects.consume(code);
                        return tagOpenAttributeValueBefore;
                    }
                    if (markdownLineEnding(code)) {
                        returnState = tagOpenAttributeNameAfter;
                        return lineEndingBefore(code);
                    }
                    if (markdownSpace(code)) {
                        effects.consume(code);
                        return tagOpenAttributeNameAfter;
                    }
                    return tagOpenBetween(code);
                }
                function tagOpenAttributeValueBefore(code) {
                    if (
                        code === null ||
                        code === 60 ||
                        code === 61 ||
                        code === 62 ||
                        code === 96
                    ) {
                        return nok(code);
                    }
                    if (code === 34 || code === 39) {
                        effects.consume(code);
                        marker = code;
                        return tagOpenAttributeValueQuoted;
                    }
                    if (markdownLineEnding(code)) {
                        returnState = tagOpenAttributeValueBefore;
                        return lineEndingBefore(code);
                    }
                    if (markdownSpace(code)) {
                        effects.consume(code);
                        return tagOpenAttributeValueBefore;
                    }
                    effects.consume(code);
                    return tagOpenAttributeValueUnquoted;
                }
                function tagOpenAttributeValueQuoted(code) {
                    if (code === marker) {
                        effects.consume(code);
                        marker = void 0;
                        return tagOpenAttributeValueQuotedAfter;
                    }
                    if (code === null) {
                        return nok(code);
                    }
                    if (markdownLineEnding(code)) {
                        returnState = tagOpenAttributeValueQuoted;
                        return lineEndingBefore(code);
                    }
                    effects.consume(code);
                    return tagOpenAttributeValueQuoted;
                }
                function tagOpenAttributeValueUnquoted(code) {
                    if (
                        code === null ||
                        code === 34 ||
                        code === 39 ||
                        code === 60 ||
                        code === 61 ||
                        code === 96
                    ) {
                        return nok(code);
                    }
                    if (
                        code === 47 ||
                        code === 62 ||
                        markdownLineEndingOrSpace(code)
                    ) {
                        return tagOpenBetween(code);
                    }
                    effects.consume(code);
                    return tagOpenAttributeValueUnquoted;
                }
                function tagOpenAttributeValueQuotedAfter(code) {
                    if (
                        code === 47 ||
                        code === 62 ||
                        markdownLineEndingOrSpace(code)
                    ) {
                        return tagOpenBetween(code);
                    }
                    return nok(code);
                }
                function end(code) {
                    if (code === 62) {
                        effects.consume(code);
                        effects.exit('htmlTextData');
                        effects.exit('htmlText');
                        return ok;
                    }
                    return nok(code);
                }
                function lineEndingBefore(code) {
                    effects.exit('htmlTextData');
                    effects.enter('lineEnding');
                    effects.consume(code);
                    effects.exit('lineEnding');
                    return lineEndingAfter;
                }
                function lineEndingAfter(code) {
                    return markdownSpace(code)
                        ? factorySpace(
                              effects,
                              lineEndingAfterPrefix,
                              'linePrefix',
                              self.parser.constructs.disable.null.includes(
                                  'codeIndented'
                              )
                                  ? void 0
                                  : 4
                          )(code)
                        : lineEndingAfterPrefix(code);
                }
                function lineEndingAfterPrefix(code) {
                    effects.enter('htmlTextData');
                    return returnState(code);
                }
            }
            const labelEnd = {
                name: 'labelEnd',
                tokenize: tokenizeLabelEnd,
                resolveTo: resolveToLabelEnd,
                resolveAll: resolveAllLabelEnd,
            };
            const resourceConstruct = {
                tokenize: tokenizeResource,
            };
            const referenceFullConstruct = {
                tokenize: tokenizeReferenceFull,
            };
            const referenceCollapsedConstruct = {
                tokenize: tokenizeReferenceCollapsed,
            };
            function resolveAllLabelEnd(events2) {
                let index = -1;
                while (++index < events2.length) {
                    const token = events2[index][1];
                    if (
                        token.type === 'labelImage' ||
                        token.type === 'labelLink' ||
                        token.type === 'labelEnd'
                    ) {
                        events2.splice(
                            index + 1,
                            token.type === 'labelImage' ? 4 : 2
                        );
                        token.type = 'data';
                        index++;
                    }
                }
                return events2;
            }
            function resolveToLabelEnd(events2, context) {
                let index = events2.length;
                let offset = 0;
                let token;
                let open;
                let close;
                let media;
                while (index--) {
                    token = events2[index][1];
                    if (open) {
                        if (
                            token.type === 'link' ||
                            (token.type === 'labelLink' && token._inactive)
                        ) {
                            break;
                        }
                        if (
                            events2[index][0] === 'enter' &&
                            token.type === 'labelLink'
                        ) {
                            token._inactive = true;
                        }
                    } else if (close) {
                        if (
                            events2[index][0] === 'enter' &&
                            (token.type === 'labelImage' ||
                                token.type === 'labelLink') &&
                            !token._balanced
                        ) {
                            open = index;
                            if (token.type !== 'labelLink') {
                                offset = 2;
                                break;
                            }
                        }
                    } else if (token.type === 'labelEnd') {
                        close = index;
                    }
                }
                const group = {
                    type:
                        events2[open][1].type === 'labelLink'
                            ? 'link'
                            : 'image',
                    start: Object.assign({}, events2[open][1].start),
                    end: Object.assign({}, events2[events2.length - 1][1].end),
                };
                const label = {
                    type: 'label',
                    start: Object.assign({}, events2[open][1].start),
                    end: Object.assign({}, events2[close][1].end),
                };
                const text2 = {
                    type: 'labelText',
                    start: Object.assign({}, events2[open + offset + 2][1].end),
                    end: Object.assign({}, events2[close - 2][1].start),
                };
                media = [
                    ['enter', group, context],
                    ['enter', label, context],
                ];
                media = push(media, events2.slice(open + 1, open + offset + 3));
                media = push(media, [['enter', text2, context]]);
                media = push(
                    media,
                    resolveAll(
                        context.parser.constructs.insideSpan.null,
                        events2.slice(open + offset + 4, close - 3),
                        context
                    )
                );
                media = push(media, [
                    ['exit', text2, context],
                    events2[close - 2],
                    events2[close - 1],
                    ['exit', label, context],
                ]);
                media = push(media, events2.slice(close + 1));
                media = push(media, [['exit', group, context]]);
                splice(events2, open, events2.length, media);
                return events2;
            }
            function tokenizeLabelEnd(effects, ok, nok) {
                const self = this;
                let index = self.events.length;
                let labelStart;
                let defined;
                while (index--) {
                    if (
                        (self.events[index][1].type === 'labelImage' ||
                            self.events[index][1].type === 'labelLink') &&
                        !self.events[index][1]._balanced
                    ) {
                        labelStart = self.events[index][1];
                        break;
                    }
                }
                return start;
                function start(code) {
                    if (!labelStart) {
                        return nok(code);
                    }
                    if (labelStart._inactive) {
                        return labelEndNok(code);
                    }
                    defined = self.parser.defined.includes(
                        normalizeIdentifier(
                            self.sliceSerialize({
                                start: labelStart.end,
                                end: self.now(),
                            })
                        )
                    );
                    effects.enter('labelEnd');
                    effects.enter('labelMarker');
                    effects.consume(code);
                    effects.exit('labelMarker');
                    effects.exit('labelEnd');
                    return after;
                }
                function after(code) {
                    if (code === 40) {
                        return effects.attempt(
                            resourceConstruct,
                            labelEndOk,
                            defined ? labelEndOk : labelEndNok
                        )(code);
                    }
                    if (code === 91) {
                        return effects.attempt(
                            referenceFullConstruct,
                            labelEndOk,
                            defined ? referenceNotFull : labelEndNok
                        )(code);
                    }
                    return defined ? labelEndOk(code) : labelEndNok(code);
                }
                function referenceNotFull(code) {
                    return effects.attempt(
                        referenceCollapsedConstruct,
                        labelEndOk,
                        labelEndNok
                    )(code);
                }
                function labelEndOk(code) {
                    return ok(code);
                }
                function labelEndNok(code) {
                    labelStart._balanced = true;
                    return nok(code);
                }
            }
            function tokenizeResource(effects, ok, nok) {
                return resourceStart;
                function resourceStart(code) {
                    effects.enter('resource');
                    effects.enter('resourceMarker');
                    effects.consume(code);
                    effects.exit('resourceMarker');
                    return resourceBefore;
                }
                function resourceBefore(code) {
                    return markdownLineEndingOrSpace(code)
                        ? factoryWhitespace(effects, resourceOpen)(code)
                        : resourceOpen(code);
                }
                function resourceOpen(code) {
                    if (code === 41) {
                        return resourceEnd(code);
                    }
                    return factoryDestination(
                        effects,
                        resourceDestinationAfter,
                        resourceDestinationMissing,
                        'resourceDestination',
                        'resourceDestinationLiteral',
                        'resourceDestinationLiteralMarker',
                        'resourceDestinationRaw',
                        'resourceDestinationString',
                        32
                    )(code);
                }
                function resourceDestinationAfter(code) {
                    return markdownLineEndingOrSpace(code)
                        ? factoryWhitespace(effects, resourceBetween)(code)
                        : resourceEnd(code);
                }
                function resourceDestinationMissing(code) {
                    return nok(code);
                }
                function resourceBetween(code) {
                    if (code === 34 || code === 39 || code === 40) {
                        return factoryTitle(
                            effects,
                            resourceTitleAfter,
                            nok,
                            'resourceTitle',
                            'resourceTitleMarker',
                            'resourceTitleString'
                        )(code);
                    }
                    return resourceEnd(code);
                }
                function resourceTitleAfter(code) {
                    return markdownLineEndingOrSpace(code)
                        ? factoryWhitespace(effects, resourceEnd)(code)
                        : resourceEnd(code);
                }
                function resourceEnd(code) {
                    if (code === 41) {
                        effects.enter('resourceMarker');
                        effects.consume(code);
                        effects.exit('resourceMarker');
                        effects.exit('resource');
                        return ok;
                    }
                    return nok(code);
                }
            }
            function tokenizeReferenceFull(effects, ok, nok) {
                const self = this;
                return referenceFull;
                function referenceFull(code) {
                    return factoryLabel.call(
                        self,
                        effects,
                        referenceFullAfter,
                        referenceFullMissing,
                        'reference',
                        'referenceMarker',
                        'referenceString'
                    )(code);
                }
                function referenceFullAfter(code) {
                    return self.parser.defined.includes(
                        normalizeIdentifier(
                            self
                                .sliceSerialize(
                                    self.events[self.events.length - 1][1]
                                )
                                .slice(1, -1)
                        )
                    )
                        ? ok(code)
                        : nok(code);
                }
                function referenceFullMissing(code) {
                    return nok(code);
                }
            }
            function tokenizeReferenceCollapsed(effects, ok, nok) {
                return referenceCollapsedStart;
                function referenceCollapsedStart(code) {
                    effects.enter('reference');
                    effects.enter('referenceMarker');
                    effects.consume(code);
                    effects.exit('referenceMarker');
                    return referenceCollapsedOpen;
                }
                function referenceCollapsedOpen(code) {
                    if (code === 93) {
                        effects.enter('referenceMarker');
                        effects.consume(code);
                        effects.exit('referenceMarker');
                        effects.exit('reference');
                        return ok;
                    }
                    return nok(code);
                }
            }
            const labelStartImage = {
                name: 'labelStartImage',
                tokenize: tokenizeLabelStartImage,
                resolveAll: labelEnd.resolveAll,
            };
            function tokenizeLabelStartImage(effects, ok, nok) {
                const self = this;
                return start;
                function start(code) {
                    effects.enter('labelImage');
                    effects.enter('labelImageMarker');
                    effects.consume(code);
                    effects.exit('labelImageMarker');
                    return open;
                }
                function open(code) {
                    if (code === 91) {
                        effects.enter('labelMarker');
                        effects.consume(code);
                        effects.exit('labelMarker');
                        effects.exit('labelImage');
                        return after;
                    }
                    return nok(code);
                }
                function after(code) {
                    return code === 94 &&
                        '_hiddenFootnoteSupport' in self.parser.constructs
                        ? nok(code)
                        : ok(code);
                }
            }
            const labelStartLink = {
                name: 'labelStartLink',
                tokenize: tokenizeLabelStartLink,
                resolveAll: labelEnd.resolveAll,
            };
            function tokenizeLabelStartLink(effects, ok, nok) {
                const self = this;
                return start;
                function start(code) {
                    effects.enter('labelLink');
                    effects.enter('labelMarker');
                    effects.consume(code);
                    effects.exit('labelMarker');
                    effects.exit('labelLink');
                    return after;
                }
                function after(code) {
                    return code === 94 &&
                        '_hiddenFootnoteSupport' in self.parser.constructs
                        ? nok(code)
                        : ok(code);
                }
            }
            const lineEnding = {
                name: 'lineEnding',
                tokenize: tokenizeLineEnding,
            };
            function tokenizeLineEnding(effects, ok) {
                return start;
                function start(code) {
                    effects.enter('lineEnding');
                    effects.consume(code);
                    effects.exit('lineEnding');
                    return factorySpace(effects, ok, 'linePrefix');
                }
            }
            const thematicBreak = {
                name: 'thematicBreak',
                tokenize: tokenizeThematicBreak,
            };
            function tokenizeThematicBreak(effects, ok, nok) {
                let size = 0;
                let marker;
                return start;
                function start(code) {
                    effects.enter('thematicBreak');
                    return before(code);
                }
                function before(code) {
                    marker = code;
                    return atBreak(code);
                }
                function atBreak(code) {
                    if (code === marker) {
                        effects.enter('thematicBreakSequence');
                        return sequence(code);
                    }
                    if (
                        size >= 3 &&
                        (code === null || markdownLineEnding(code))
                    ) {
                        effects.exit('thematicBreak');
                        return ok(code);
                    }
                    return nok(code);
                }
                function sequence(code) {
                    if (code === marker) {
                        effects.consume(code);
                        size++;
                        return sequence;
                    }
                    effects.exit('thematicBreakSequence');
                    return markdownSpace(code)
                        ? factorySpace(effects, atBreak, 'whitespace')(code)
                        : atBreak(code);
                }
            }
            const list = {
                name: 'list',
                tokenize: tokenizeListStart,
                continuation: {
                    tokenize: tokenizeListContinuation,
                },
                exit: tokenizeListEnd,
            };
            const listItemPrefixWhitespaceConstruct = {
                tokenize: tokenizeListItemPrefixWhitespace,
                partial: true,
            };
            const indentConstruct = {
                tokenize: tokenizeIndent,
                partial: true,
            };
            function tokenizeListStart(effects, ok, nok) {
                const self = this;
                const tail = self.events[self.events.length - 1];
                let initialSize =
                    tail && tail[1].type === 'linePrefix'
                        ? tail[2].sliceSerialize(tail[1], true).length
                        : 0;
                let size = 0;
                return start;
                function start(code) {
                    const kind =
                        self.containerState.type ||
                        (code === 42 || code === 43 || code === 45
                            ? 'listUnordered'
                            : 'listOrdered');
                    if (
                        kind === 'listUnordered'
                            ? !self.containerState.marker ||
                              code === self.containerState.marker
                            : asciiDigit(code)
                    ) {
                        if (!self.containerState.type) {
                            self.containerState.type = kind;
                            effects.enter(kind, {
                                _container: true,
                            });
                        }
                        if (kind === 'listUnordered') {
                            effects.enter('listItemPrefix');
                            return code === 42 || code === 45
                                ? effects.check(
                                      thematicBreak,
                                      nok,
                                      atMarker
                                  )(code)
                                : atMarker(code);
                        }
                        if (!self.interrupt || code === 49) {
                            effects.enter('listItemPrefix');
                            effects.enter('listItemValue');
                            return inside(code);
                        }
                    }
                    return nok(code);
                }
                function inside(code) {
                    if (asciiDigit(code) && ++size < 10) {
                        effects.consume(code);
                        return inside;
                    }
                    if (
                        (!self.interrupt || size < 2) &&
                        (self.containerState.marker
                            ? code === self.containerState.marker
                            : code === 41 || code === 46)
                    ) {
                        effects.exit('listItemValue');
                        return atMarker(code);
                    }
                    return nok(code);
                }
                function atMarker(code) {
                    effects.enter('listItemMarker');
                    effects.consume(code);
                    effects.exit('listItemMarker');
                    self.containerState.marker =
                        self.containerState.marker || code;
                    return effects.check(
                        blankLine,
                        // Can’t be empty when interrupting.
                        self.interrupt ? nok : onBlank,
                        effects.attempt(
                            listItemPrefixWhitespaceConstruct,
                            endOfPrefix,
                            otherPrefix
                        )
                    );
                }
                function onBlank(code) {
                    self.containerState.initialBlankLine = true;
                    initialSize++;
                    return endOfPrefix(code);
                }
                function otherPrefix(code) {
                    if (markdownSpace(code)) {
                        effects.enter('listItemPrefixWhitespace');
                        effects.consume(code);
                        effects.exit('listItemPrefixWhitespace');
                        return endOfPrefix;
                    }
                    return nok(code);
                }
                function endOfPrefix(code) {
                    self.containerState.size =
                        initialSize +
                        self.sliceSerialize(
                            effects.exit('listItemPrefix'),
                            true
                        ).length;
                    return ok(code);
                }
            }
            function tokenizeListContinuation(effects, ok, nok) {
                const self = this;
                self.containerState._closeFlow = void 0;
                return effects.check(blankLine, onBlank, notBlank);
                function onBlank(code) {
                    self.containerState.furtherBlankLines =
                        self.containerState.furtherBlankLines ||
                        self.containerState.initialBlankLine;
                    return factorySpace(
                        effects,
                        ok,
                        'listItemIndent',
                        self.containerState.size + 1
                    )(code);
                }
                function notBlank(code) {
                    if (
                        self.containerState.furtherBlankLines ||
                        !markdownSpace(code)
                    ) {
                        self.containerState.furtherBlankLines = void 0;
                        self.containerState.initialBlankLine = void 0;
                        return notInCurrentItem(code);
                    }
                    self.containerState.furtherBlankLines = void 0;
                    self.containerState.initialBlankLine = void 0;
                    return effects.attempt(
                        indentConstruct,
                        ok,
                        notInCurrentItem
                    )(code);
                }
                function notInCurrentItem(code) {
                    self.containerState._closeFlow = true;
                    self.interrupt = void 0;
                    return factorySpace(
                        effects,
                        effects.attempt(list, ok, nok),
                        'linePrefix',
                        self.parser.constructs.disable.null.includes(
                            'codeIndented'
                        )
                            ? void 0
                            : 4
                    )(code);
                }
            }
            function tokenizeIndent(effects, ok, nok) {
                const self = this;
                return factorySpace(
                    effects,
                    afterPrefix,
                    'listItemIndent',
                    self.containerState.size + 1
                );
                function afterPrefix(code) {
                    const tail = self.events[self.events.length - 1];
                    return tail &&
                        tail[1].type === 'listItemIndent' &&
                        tail[2].sliceSerialize(tail[1], true).length ===
                            self.containerState.size
                        ? ok(code)
                        : nok(code);
                }
            }
            function tokenizeListEnd(effects) {
                effects.exit(this.containerState.type);
            }
            function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
                const self = this;
                return factorySpace(
                    effects,
                    afterPrefix,
                    'listItemPrefixWhitespace',
                    self.parser.constructs.disable.null.includes('codeIndented')
                        ? void 0
                        : 4 + 1
                );
                function afterPrefix(code) {
                    const tail = self.events[self.events.length - 1];
                    return !markdownSpace(code) &&
                        tail &&
                        tail[1].type === 'listItemPrefixWhitespace'
                        ? ok(code)
                        : nok(code);
                }
            }
            const setextUnderline = {
                name: 'setextUnderline',
                tokenize: tokenizeSetextUnderline,
                resolveTo: resolveToSetextUnderline,
            };
            function resolveToSetextUnderline(events2, context) {
                let index = events2.length;
                let content2;
                let text2;
                let definition2;
                while (index--) {
                    if (events2[index][0] === 'enter') {
                        if (events2[index][1].type === 'content') {
                            content2 = index;
                            break;
                        }
                        if (events2[index][1].type === 'paragraph') {
                            text2 = index;
                        }
                    } else {
                        if (events2[index][1].type === 'content') {
                            events2.splice(index, 1);
                        }
                        if (
                            !definition2 &&
                            events2[index][1].type === 'definition'
                        ) {
                            definition2 = index;
                        }
                    }
                }
                const heading = {
                    type: 'setextHeading',
                    start: Object.assign({}, events2[text2][1].start),
                    end: Object.assign({}, events2[events2.length - 1][1].end),
                };
                events2[text2][1].type = 'setextHeadingText';
                if (definition2) {
                    events2.splice(text2, 0, ['enter', heading, context]);
                    events2.splice(definition2 + 1, 0, [
                        'exit',
                        events2[content2][1],
                        context,
                    ]);
                    events2[content2][1].end = Object.assign(
                        {},
                        events2[definition2][1].end
                    );
                } else {
                    events2[content2][1] = heading;
                }
                events2.push(['exit', heading, context]);
                return events2;
            }
            function tokenizeSetextUnderline(effects, ok, nok) {
                const self = this;
                let marker;
                return start;
                function start(code) {
                    let index = self.events.length;
                    let paragraph;
                    while (index--) {
                        if (
                            self.events[index][1].type !== 'lineEnding' &&
                            self.events[index][1].type !== 'linePrefix' &&
                            self.events[index][1].type !== 'content'
                        ) {
                            paragraph =
                                self.events[index][1].type === 'paragraph';
                            break;
                        }
                    }
                    if (
                        !self.parser.lazy[self.now().line] &&
                        (self.interrupt || paragraph)
                    ) {
                        effects.enter('setextHeadingLine');
                        marker = code;
                        return before(code);
                    }
                    return nok(code);
                }
                function before(code) {
                    effects.enter('setextHeadingLineSequence');
                    return inside(code);
                }
                function inside(code) {
                    if (code === marker) {
                        effects.consume(code);
                        return inside;
                    }
                    effects.exit('setextHeadingLineSequence');
                    return markdownSpace(code)
                        ? factorySpace(effects, after, 'lineSuffix')(code)
                        : after(code);
                }
                function after(code) {
                    if (code === null || markdownLineEnding(code)) {
                        effects.exit('setextHeadingLine');
                        return ok(code);
                    }
                    return nok(code);
                }
            }
            const flow$1 = {
                tokenize: initializeFlow,
            };
            function initializeFlow(effects) {
                const self = this;
                const initial = effects.attempt(
                    // Try to parse a blank line.
                    blankLine,
                    atBlankEnding,
                    // Try to parse initial flow (essentially, only code).
                    effects.attempt(
                        this.parser.constructs.flowInitial,
                        afterConstruct,
                        factorySpace(
                            effects,
                            effects.attempt(
                                this.parser.constructs.flow,
                                afterConstruct,
                                effects.attempt(content, afterConstruct)
                            ),
                            'linePrefix'
                        )
                    )
                );
                return initial;
                function atBlankEnding(code) {
                    if (code === null) {
                        effects.consume(code);
                        return;
                    }
                    effects.enter('lineEndingBlank');
                    effects.consume(code);
                    effects.exit('lineEndingBlank');
                    self.currentConstruct = void 0;
                    return initial;
                }
                function afterConstruct(code) {
                    if (code === null) {
                        effects.consume(code);
                        return;
                    }
                    effects.enter('lineEnding');
                    effects.consume(code);
                    effects.exit('lineEnding');
                    self.currentConstruct = void 0;
                    return initial;
                }
            }
            const resolver = {
                resolveAll: createResolver(),
            };
            const string$1 = initializeFactory('string');
            const text$1 = initializeFactory('text');
            function initializeFactory(field) {
                return {
                    tokenize: initializeText,
                    resolveAll: createResolver(
                        field === 'text' ? resolveAllLineSuffixes : void 0
                    ),
                };
                function initializeText(effects) {
                    const self = this;
                    const constructs2 = this.parser.constructs[field];
                    const text2 = effects.attempt(constructs2, start, notText);
                    return start;
                    function start(code) {
                        return atBreak(code) ? text2(code) : notText(code);
                    }
                    function notText(code) {
                        if (code === null) {
                            effects.consume(code);
                            return;
                        }
                        effects.enter('data');
                        effects.consume(code);
                        return data;
                    }
                    function data(code) {
                        if (atBreak(code)) {
                            effects.exit('data');
                            return text2(code);
                        }
                        effects.consume(code);
                        return data;
                    }
                    function atBreak(code) {
                        if (code === null) {
                            return true;
                        }
                        const list2 = constructs2[code];
                        let index = -1;
                        if (list2) {
                            while (++index < list2.length) {
                                const item = list2[index];
                                if (
                                    !item.previous ||
                                    item.previous.call(self, self.previous)
                                ) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                }
            }
            function createResolver(extraResolver) {
                return resolveAllText;
                function resolveAllText(events2, context) {
                    let index = -1;
                    let enter;
                    while (++index <= events2.length) {
                        if (enter === void 0) {
                            if (
                                events2[index] &&
                                events2[index][1].type === 'data'
                            ) {
                                enter = index;
                                index++;
                            }
                        } else if (
                            !events2[index] ||
                            events2[index][1].type !== 'data'
                        ) {
                            if (index !== enter + 2) {
                                events2[enter][1].end =
                                    events2[index - 1][1].end;
                                events2.splice(enter + 2, index - enter - 2);
                                index = enter + 2;
                            }
                            enter = void 0;
                        }
                    }
                    return extraResolver
                        ? extraResolver(events2, context)
                        : events2;
                }
            }
            function resolveAllLineSuffixes(events2, context) {
                let eventIndex = 0;
                while (++eventIndex <= events2.length) {
                    if (
                        (eventIndex === events2.length ||
                            events2[eventIndex][1].type === 'lineEnding') &&
                        events2[eventIndex - 1][1].type === 'data'
                    ) {
                        const data = events2[eventIndex - 1][1];
                        const chunks = context.sliceStream(data);
                        let index = chunks.length;
                        let bufferIndex = -1;
                        let size = 0;
                        let tabs;
                        while (index--) {
                            const chunk = chunks[index];
                            if (typeof chunk === 'string') {
                                bufferIndex = chunk.length;
                                while (
                                    chunk.charCodeAt(bufferIndex - 1) === 32
                                ) {
                                    size++;
                                    bufferIndex--;
                                }
                                if (bufferIndex) break;
                                bufferIndex = -1;
                            } else if (chunk === -2) {
                                tabs = true;
                                size++;
                            } else if (chunk === -1);
                            else {
                                index++;
                                break;
                            }
                        }
                        if (size) {
                            const token = {
                                type:
                                    eventIndex === events2.length ||
                                    tabs ||
                                    size < 2
                                        ? 'lineSuffix'
                                        : 'hardBreakTrailing',
                                start: {
                                    line: data.end.line,
                                    column: data.end.column - size,
                                    offset: data.end.offset - size,
                                    _index: data.start._index + index,
                                    _bufferIndex: index
                                        ? bufferIndex
                                        : data.start._bufferIndex + bufferIndex,
                                },
                                end: Object.assign({}, data.end),
                            };
                            data.end = Object.assign({}, token.start);
                            if (data.start.offset === data.end.offset) {
                                Object.assign(data, token);
                            } else {
                                events2.splice(
                                    eventIndex,
                                    0,
                                    ['enter', token, context],
                                    ['exit', token, context]
                                );
                                eventIndex += 2;
                            }
                        }
                        eventIndex++;
                    }
                }
                return events2;
            }
            function createTokenizer(parser, initialize, from) {
                let point = Object.assign(
                    from
                        ? Object.assign({}, from)
                        : {
                              line: 1,
                              column: 1,
                              offset: 0,
                          },
                    {
                        _index: 0,
                        _bufferIndex: -1,
                    }
                );
                const columnStart = {};
                const resolveAllConstructs = [];
                let chunks = [];
                let stack = [];
                const effects = {
                    consume,
                    enter,
                    exit: exit2,
                    attempt: constructFactory(onsuccessfulconstruct),
                    check: constructFactory(onsuccessfulcheck),
                    interrupt: constructFactory(onsuccessfulcheck, {
                        interrupt: true,
                    }),
                };
                const context = {
                    previous: null,
                    code: null,
                    containerState: {},
                    events: [],
                    parser,
                    sliceStream,
                    sliceSerialize,
                    now,
                    defineSkip,
                    write,
                };
                let state = initialize.tokenize.call(context, effects);
                if (initialize.resolveAll) {
                    resolveAllConstructs.push(initialize);
                }
                return context;
                function write(slice) {
                    chunks = push(chunks, slice);
                    main2();
                    if (chunks[chunks.length - 1] !== null) {
                        return [];
                    }
                    addResult(initialize, 0);
                    context.events = resolveAll(
                        resolveAllConstructs,
                        context.events,
                        context
                    );
                    return context.events;
                }
                function sliceSerialize(token, expandTabs) {
                    return serializeChunks(sliceStream(token), expandTabs);
                }
                function sliceStream(token) {
                    return sliceChunks(chunks, token);
                }
                function now() {
                    const { line, column, offset, _index, _bufferIndex } =
                        point;
                    return {
                        line,
                        column,
                        offset,
                        _index,
                        _bufferIndex,
                    };
                }
                function defineSkip(value) {
                    columnStart[value.line] = value.column;
                    accountForPotentialSkip();
                }
                function main2() {
                    let chunkIndex;
                    while (point._index < chunks.length) {
                        const chunk = chunks[point._index];
                        if (typeof chunk === 'string') {
                            chunkIndex = point._index;
                            if (point._bufferIndex < 0) {
                                point._bufferIndex = 0;
                            }
                            while (
                                point._index === chunkIndex &&
                                point._bufferIndex < chunk.length
                            ) {
                                go(chunk.charCodeAt(point._bufferIndex));
                            }
                        } else {
                            go(chunk);
                        }
                    }
                }
                function go(code) {
                    state = state(code);
                }
                function consume(code) {
                    if (markdownLineEnding(code)) {
                        point.line++;
                        point.column = 1;
                        point.offset += code === -3 ? 2 : 1;
                        accountForPotentialSkip();
                    } else if (code !== -1) {
                        point.column++;
                        point.offset++;
                    }
                    if (point._bufferIndex < 0) {
                        point._index++;
                    } else {
                        point._bufferIndex++;
                        if (
                            point._bufferIndex === chunks[point._index].length
                        ) {
                            point._bufferIndex = -1;
                            point._index++;
                        }
                    }
                    context.previous = code;
                }
                function enter(type, fields) {
                    const token = fields || {};
                    token.type = type;
                    token.start = now();
                    context.events.push(['enter', token, context]);
                    stack.push(token);
                    return token;
                }
                function exit2(type) {
                    const token = stack.pop();
                    token.end = now();
                    context.events.push(['exit', token, context]);
                    return token;
                }
                function onsuccessfulconstruct(construct, info) {
                    addResult(construct, info.from);
                }
                function onsuccessfulcheck(_, info) {
                    info.restore();
                }
                function constructFactory(onreturn, fields) {
                    return hook;
                    function hook(constructs2, returnState, bogusState) {
                        let listOfConstructs;
                        let constructIndex;
                        let currentConstruct;
                        let info;
                        return Array.isArray(constructs2)
                            ? handleListOfConstructs(constructs2)
                            : 'tokenize' in constructs2
                              ? // @ts-expect-error Looks like a construct.
                                handleListOfConstructs([constructs2])
                              : handleMapOfConstructs(constructs2);
                        function handleMapOfConstructs(map) {
                            return start;
                            function start(code) {
                                const def = code !== null && map[code];
                                const all = code !== null && map.null;
                                const list2 = [
                                    // To do: add more extension tests.
                                    /* c8 ignore next 2 */
                                    ...(Array.isArray(def)
                                        ? def
                                        : def
                                          ? [def]
                                          : []),
                                    ...(Array.isArray(all)
                                        ? all
                                        : all
                                          ? [all]
                                          : []),
                                ];
                                return handleListOfConstructs(list2)(code);
                            }
                        }
                        function handleListOfConstructs(list2) {
                            listOfConstructs = list2;
                            constructIndex = 0;
                            if (list2.length === 0) {
                                return bogusState;
                            }
                            return handleConstruct(list2[constructIndex]);
                        }
                        function handleConstruct(construct) {
                            return start;
                            function start(code) {
                                info = store();
                                currentConstruct = construct;
                                if (!construct.partial) {
                                    context.currentConstruct = construct;
                                }
                                if (
                                    construct.name &&
                                    context.parser.constructs.disable.null.includes(
                                        construct.name
                                    )
                                ) {
                                    return nok();
                                }
                                return construct.tokenize.call(
                                    // If we do have fields, create an object w/ `context` as its
                                    // prototype.
                                    // This allows a “live binding”, which is needed for `interrupt`.
                                    fields
                                        ? Object.assign(
                                              Object.create(context),
                                              fields
                                          )
                                        : context,
                                    effects,
                                    ok,
                                    nok
                                )(code);
                            }
                        }
                        function ok(code) {
                            onreturn(currentConstruct, info);
                            return returnState;
                        }
                        function nok(code) {
                            info.restore();
                            if (++constructIndex < listOfConstructs.length) {
                                return handleConstruct(
                                    listOfConstructs[constructIndex]
                                );
                            }
                            return bogusState;
                        }
                    }
                }
                function addResult(construct, from2) {
                    if (
                        construct.resolveAll &&
                        !resolveAllConstructs.includes(construct)
                    ) {
                        resolveAllConstructs.push(construct);
                    }
                    if (construct.resolve) {
                        splice(
                            context.events,
                            from2,
                            context.events.length - from2,
                            construct.resolve(
                                context.events.slice(from2),
                                context
                            )
                        );
                    }
                    if (construct.resolveTo) {
                        context.events = construct.resolveTo(
                            context.events,
                            context
                        );
                    }
                }
                function store() {
                    const startPoint = now();
                    const startPrevious = context.previous;
                    const startCurrentConstruct = context.currentConstruct;
                    const startEventsIndex = context.events.length;
                    const startStack = Array.from(stack);
                    return {
                        restore,
                        from: startEventsIndex,
                    };
                    function restore() {
                        point = startPoint;
                        context.previous = startPrevious;
                        context.currentConstruct = startCurrentConstruct;
                        context.events.length = startEventsIndex;
                        stack = startStack;
                        accountForPotentialSkip();
                    }
                }
                function accountForPotentialSkip() {
                    if (point.line in columnStart && point.column < 2) {
                        point.column = columnStart[point.line];
                        point.offset += columnStart[point.line] - 1;
                    }
                }
            }
            function sliceChunks(chunks, token) {
                const startIndex = token.start._index;
                const startBufferIndex = token.start._bufferIndex;
                const endIndex = token.end._index;
                const endBufferIndex = token.end._bufferIndex;
                let view;
                if (startIndex === endIndex) {
                    view = [
                        chunks[startIndex].slice(
                            startBufferIndex,
                            endBufferIndex
                        ),
                    ];
                } else {
                    view = chunks.slice(startIndex, endIndex);
                    if (startBufferIndex > -1) {
                        const head = view[0];
                        if (typeof head === 'string') {
                            view[0] = head.slice(startBufferIndex);
                        } else {
                            view.shift();
                        }
                    }
                    if (endBufferIndex > 0) {
                        view.push(chunks[endIndex].slice(0, endBufferIndex));
                    }
                }
                return view;
            }
            function serializeChunks(chunks, expandTabs) {
                let index = -1;
                const result = [];
                let atTab;
                while (++index < chunks.length) {
                    const chunk = chunks[index];
                    let value;
                    if (typeof chunk === 'string') {
                        value = chunk;
                    } else
                        switch (chunk) {
                            case -5: {
                                value = '\r';
                                break;
                            }
                            case -4: {
                                value = '\n';
                                break;
                            }
                            case -3: {
                                value = '\r\n';
                                break;
                            }
                            case -2: {
                                value = expandTabs ? ' ' : '	';
                                break;
                            }
                            case -1: {
                                if (!expandTabs && atTab) continue;
                                value = ' ';
                                break;
                            }
                            default: {
                                value = String.fromCharCode(chunk);
                            }
                        }
                    atTab = chunk === -2;
                    result.push(value);
                }
                return result.join('');
            }
            const document$1 = {
                [42]: list,
                [43]: list,
                [45]: list,
                [48]: list,
                [49]: list,
                [50]: list,
                [51]: list,
                [52]: list,
                [53]: list,
                [54]: list,
                [55]: list,
                [56]: list,
                [57]: list,
                [62]: blockQuote,
            };
            const contentInitial = {
                [91]: definition,
            };
            const flowInitial = {
                [-2]: codeIndented,
                [-1]: codeIndented,
                [32]: codeIndented,
            };
            const flow = {
                [35]: headingAtx,
                [42]: thematicBreak,
                [45]: [setextUnderline, thematicBreak],
                [60]: htmlFlow,
                [61]: setextUnderline,
                [95]: thematicBreak,
                [96]: codeFenced,
                [126]: codeFenced,
            };
            const string = {
                [38]: characterReference,
                [92]: characterEscape,
            };
            const text = {
                [-5]: lineEnding,
                [-4]: lineEnding,
                [-3]: lineEnding,
                [33]: labelStartImage,
                [38]: characterReference,
                [42]: attention,
                [60]: [autolink, htmlText],
                [91]: labelStartLink,
                [92]: [hardBreakEscape, characterEscape],
                [93]: labelEnd,
                [95]: attention,
                [96]: codeText,
            };
            const insideSpan = {
                null: [attention, resolver],
            };
            const attentionMarkers = {
                null: [42, 95],
            };
            const disable = {
                null: [],
            };
            const defaultConstructs = /* @__PURE__ */ Object.freeze(
                /* @__PURE__ */ Object.defineProperty(
                    {
                        __proto__: null,
                        attentionMarkers,
                        contentInitial,
                        disable,
                        document: document$1,
                        flow,
                        flowInitial,
                        insideSpan,
                        string,
                        text,
                    },
                    Symbol.toStringTag,
                    { value: 'Module' }
                )
            );
            function parse(options) {
                const settings = options || {};
                const constructs2 =
                    /** @type {FullNormalizedExtension} */
                    combineExtensions([
                        defaultConstructs,
                        ...(settings.extensions || []),
                    ]);
                const parser = {
                    defined: [],
                    lazy: {},
                    constructs: constructs2,
                    content: create(content$1),
                    document: create(document$2),
                    flow: create(flow$1),
                    string: create(string$1),
                    text: create(text$1),
                };
                return parser;
                function create(initial) {
                    return creator;
                    function creator(from) {
                        return createTokenizer(parser, initial, from);
                    }
                }
            }
            function postprocess(events2) {
                while (!subtokenize(events2)) {}
                return events2;
            }
            const search = /[\0\t\n\r]/g;
            function preprocess() {
                let column = 1;
                let buffer = '';
                let start = true;
                let atCarriageReturn;
                return preprocessor;
                function preprocessor(value, encoding, end) {
                    const chunks = [];
                    let match;
                    let next;
                    let startPosition;
                    let endPosition;
                    let code;
                    value =
                        buffer +
                        (typeof value === 'string'
                            ? value.toString()
                            : new TextDecoder(encoding || void 0).decode(
                                  value
                              ));
                    startPosition = 0;
                    buffer = '';
                    if (start) {
                        if (value.charCodeAt(0) === 65279) {
                            startPosition++;
                        }
                        start = void 0;
                    }
                    while (startPosition < value.length) {
                        search.lastIndex = startPosition;
                        match = search.exec(value);
                        endPosition =
                            match && match.index !== void 0
                                ? match.index
                                : value.length;
                        code = value.charCodeAt(endPosition);
                        if (!match) {
                            buffer = value.slice(startPosition);
                            break;
                        }
                        if (
                            code === 10 &&
                            startPosition === endPosition &&
                            atCarriageReturn
                        ) {
                            chunks.push(-3);
                            atCarriageReturn = void 0;
                        } else {
                            if (atCarriageReturn) {
                                chunks.push(-5);
                                atCarriageReturn = void 0;
                            }
                            if (startPosition < endPosition) {
                                chunks.push(
                                    value.slice(startPosition, endPosition)
                                );
                                column += endPosition - startPosition;
                            }
                            switch (code) {
                                case 0: {
                                    chunks.push(65533);
                                    column++;
                                    break;
                                }
                                case 9: {
                                    next = Math.ceil(column / 4) * 4;
                                    chunks.push(-2);
                                    while (column++ < next) chunks.push(-1);
                                    break;
                                }
                                case 10: {
                                    chunks.push(-4);
                                    column = 1;
                                    break;
                                }
                                default: {
                                    atCarriageReturn = true;
                                    column = 1;
                                }
                            }
                        }
                        startPosition = endPosition + 1;
                    }
                    if (end) {
                        if (atCarriageReturn) chunks.push(-5);
                        if (buffer) chunks.push(buffer);
                        chunks.push(null);
                    }
                    return chunks;
                }
            }
            function micromark(value, encoding, options) {
                if (typeof encoding !== 'string') {
                    options = encoding;
                    encoding = void 0;
                }
                return compile(options)(
                    postprocess(
                        parse(options)
                            .document()
                            .write(preprocess()(value, encoding, true))
                    )
                );
            }
            function convertMarkdown(markdownSource, div, defaultLanguage) {
                if (
                    defaultLanguage !== null &&
                    HighlightJS.getLanguage(defaultLanguage) === void 0
                ) {
                    defaultLanguage = null;
                }
                div.innerHTML = micromark(markdownSource);
                const codeBlocks = div.querySelectorAll('pre code');
                codeBlocks.forEach((codeBlockInner) => {
                    codeBlockInner = codeBlockInner;
                    codeBlockInner.textContent = codeBlockInner.textContent
                        ? codeBlockInner.textContent.replace(/^\n+|\n+$/g, '')
                        : '';
                    let specifiedLanguage = defaultLanguage;
                    for (const cls of codeBlockInner.classList) {
                        if (cls.startsWith('language-')) {
                            specifiedLanguage = cls.replace('language-', '');
                            break;
                        }
                    }
                    if (
                        specifiedLanguage !== null &&
                        HighlightJS.getLanguage(specifiedLanguage) === void 0
                    ) {
                        specifiedLanguage = null;
                    }
                    let language = void 0;
                    if (specifiedLanguage === null) {
                        let hlResult = HighlightJS.highlightAuto(
                            codeBlockInner.textContent
                        );
                        codeBlockInner.innerHTML = hlResult.value;
                        if (hlResult.language !== void 0) {
                            language = HighlightJS.getLanguage(
                                hlResult.language
                            );
                        }
                    } else {
                        let hlResult = HighlightJS.highlight(
                            codeBlockInner.textContent,
                            {
                                language: specifiedLanguage,
                                ignoreIllegals: true,
                            }
                        );
                        codeBlockInner.innerHTML = hlResult.value;
                        language = HighlightJS.getLanguage(specifiedLanguage);
                    }
                    let languageNiceName =
                        (language == null ? void 0 : language.name) ?? '';
                    let codeBlockOuter = document.createElement('div');
                    codeBlockOuter.classList.add('rio-markdown-code-block');
                    codeBlockOuter.innerHTML = `<div class="rio-markdown-code-block-header"><div class="rio-markdown-code-block-language">${languageNiceName}</div><button class="rio-markdown-code-block-copy-button">Copy code</button></div>`;
                    codeBlockInner.parentNode.insertBefore(
                        codeBlockOuter,
                        codeBlockInner
                    );
                    codeBlockOuter.appendChild(codeBlockInner);
                    let copyButton = codeBlockOuter.querySelector(
                        '.rio-markdown-code-block-copy-button'
                    );
                    copyButton.title = 'Copy code';
                    applyIcon(
                        copyButton,
                        'material/content-copy',
                        'var(--rio-local-text-color)'
                    );
                    copyButton.addEventListener('click', (event) => {
                        const codeToCopy = codeBlockInner.textContent ?? '';
                        const textArea = document.createElement('textarea');
                        textArea.value = codeToCopy;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        copyButton.title = 'Copied!';
                        applyIcon(
                            copyButton,
                            'material/done',
                            'var(--rio-local-text-color)'
                        );
                        setTimeout(() => {
                            copyButton.title = 'Copy code';
                            applyIcon(
                                copyButton,
                                'material/content-copy',
                                'var(--rio-local-text-color)'
                            );
                        }, 5e3);
                        event.stopPropagation();
                    });
                });
                if (defaultLanguage !== null) {
                    const inlineCodeBlocks = div.querySelectorAll('code');
                    inlineCodeBlocks.forEach((codeElement) => {
                        let hlResult = HighlightJS.highlight(
                            codeElement.textContent || '',
                            {
                                language: defaultLanguage,
                                ignoreIllegals: true,
                            }
                        );
                        codeElement.innerHTML = hlResult.value;
                    });
                }
            }
            class MarkdownComponent extends ComponentBase {
                createElement() {
                    const element2 = document.createElement('div');
                    element2.classList.add('rio-markdown-view');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.text !== void 0) {
                        let defaultLanguage = firstDefined(
                            deltaState.default_language,
                            this.state.default_language
                        );
                        convertMarkdown(
                            deltaState.text,
                            this.element,
                            defaultLanguage
                        );
                        this.element.style.width = 'min-content';
                        this.naturalWidth = getElementWidth(this.element);
                        this.heightRequestAssumesWidth = -1;
                        this.makeLayoutDirty();
                    }
                }
                updateNaturalWidth(ctx) {}
                updateAllocatedWidth(ctx) {}
                updateNaturalHeight(ctx) {
                    if (
                        this.heightRequestAssumesWidth === this.allocatedWidth
                    ) {
                        return;
                    }
                    this.element.style.height = 'min-content';
                    this.naturalHeight = getElementHeight(this.element);
                    this.heightRequestAssumesWidth = this.allocatedWidth;
                }
                updateAllocatedHeight(ctx) {}
            }
            const OVERLAY_TIMEOUT = 2e3;
            async function hasAudio(element2) {
                let mozHasAudio = element2.mozHasAudio;
                if (mozHasAudio !== void 0) {
                    return mozHasAudio;
                }
                let audioTracks = element2.audioTracks;
                if (audioTracks !== void 0) {
                    return audioTracks.length > 0;
                }
                let byteCount = element2.webkitAudioDecodedByteCount;
                if (byteCount !== void 0) {
                    if (byteCount > 0) {
                        return true;
                    }
                    for (let i = 10; i > 0; i--) {
                        await sleep(50);
                        if (element2.webkitAudioDecodedByteCount > 0) {
                            return true;
                        }
                    }
                    return false;
                }
                return true;
            }
            class MediaPlayerComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this._lastInteractionAt = -1;
                    this._overlayVisible = true;
                    this._isFullScreen = false;
                    this._hasAudio = true;
                    this._notifyBackend = true;
                }
                /// Update the overlay's opacity to be what it currently should be.
                _updateOverlay() {
                    let visibilityBefore = this._overlayVisible;
                    if (this.mediaPlayer.paused) {
                        this._overlayVisible = true;
                    } else if (
                        Date.now() - this._lastInteractionAt <
                        OVERLAY_TIMEOUT
                    ) {
                        this._overlayVisible = true;
                    } else {
                        this._overlayVisible = false;
                    }
                    if (visibilityBefore == this._overlayVisible) {
                        return;
                    }
                    if (this._overlayVisible) {
                        this.controls.style.opacity = '1';
                        this.mediaPlayer.style.cursor = 'default';
                    } else {
                        this.controls.style.opacity = '0';
                        this.mediaPlayer.style.cursor = 'none';
                    }
                }
                interactWorker() {
                    let now = Date.now();
                    let waitTime =
                        this._lastInteractionAt + OVERLAY_TIMEOUT - now;
                    if (waitTime > 0) {
                        setTimeout(this.interactWorker.bind(this), waitTime);
                        return;
                    }
                    this._lastInteractionAt = -1;
                    this._updateOverlay();
                }
                /// Register an interaction with the video player, so it knows to show/hide
                /// the controls.
                interact() {
                    let timeoutIsRunning = this._lastInteractionAt !== -1;
                    this._lastInteractionAt = Date.now();
                    this._updateOverlay();
                    if (!timeoutIsRunning) {
                        setTimeout(
                            this.interactWorker.bind(this),
                            OVERLAY_TIMEOUT
                        );
                    }
                }
                /// Mute/Unmute the video
                setMute(mute) {
                    if (mute) {
                        this.mediaPlayer.muted = true;
                    } else {
                        if (!this._hasAudio) {
                            return;
                        }
                        this.mediaPlayer.muted = false;
                        if (this.mediaPlayer.volume == 0) {
                            this.setVolume(0.5);
                        }
                    }
                }
                /// Hooman eers aar stoopid
                humanVolumeToLinear(volume) {
                    return (Math.pow(3, volume) - 1) / 2;
                }
                linearVolumeToHuman(volume) {
                    return Math.log(volume * 2 + 1) / Math.log(3);
                }
                /// Set the volume of the video
                setVolume(volume) {
                    let linearVolume = this.humanVolumeToLinear(volume);
                    if (linearVolume < 1e-4) {
                        linearVolume = 0;
                    }
                    this.mediaPlayer.volume = linearVolume;
                    if (
                        linearVolume > 0 &&
                        this.mediaPlayer.muted &&
                        this._hasAudio
                    ) {
                        this.mediaPlayer.muted = false;
                    }
                }
                /// Enter/Exit fullscreen mode
                toggleFullscreen() {
                    if (this._isFullScreen) {
                        document.exitFullscreen();
                    } else {
                        this.element.requestFullscreen();
                    }
                }
                _onFullscreenChange() {
                    this._isFullScreen =
                        document.fullscreenElement === this.element;
                    if (this._isFullScreen) {
                        applyIcon(
                            this.fullscreenButton,
                            'material/fullscreen-exit',
                            'white'
                        );
                    } else {
                        applyIcon(
                            this.fullscreenButton,
                            'material/fullscreen',
                            'white'
                        );
                    }
                }
                /// Pretty-string a duration (in seconds. FU JS)
                _durationToString(duration) {
                    let hours = Math.floor(duration / 3600);
                    let minutes = Math.floor(duration / 60) % 60;
                    let seconds = Math.floor(duration % 60);
                    if (hours > 0) {
                        return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    } else if (minutes > 0) {
                        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        return `0:${seconds.toString().padStart(2, '0')}`;
                    }
                }
                /// Update the UI to reflect the current playback and loading progress
                _updateProgress() {
                    let duration = this.mediaPlayer.duration;
                    if (isNaN(duration)) {
                        this.timelinePlayed.style.width = '0';
                        this.timelineLoaded.style.width = '0';
                        this.playtimeLabel.textContent = '0:00';
                        return;
                    }
                    let currentTime = this.mediaPlayer.currentTime;
                    let progress = currentTime / duration;
                    let percentage = `${progress * 100}%`;
                    this.timelinePlayed.style.width = percentage;
                    let playedString = this._durationToString(currentTime);
                    let durationString = this._durationToString(duration);
                    this.playtimeLabel.textContent = `${playedString} / ${durationString}`;
                    let loadedFraction =
                        this.mediaPlayer.buffered.length > 0
                            ? this.mediaPlayer.buffered.end(0) / duration
                            : 0;
                    this.timelineLoaded.style.width = `${loadedFraction * 100}%`;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-media-player');
                    element2.setAttribute('tabindex', '0');
                    element2.innerHTML = `
            <video></video>
            <div class="rio-media-player-alt-display" style="display: none"></div>
            <div class="rio-media-player-controls">
                <!-- Timeline -->
                <div class="rio-media-player-timeline">
                    <div>
                        <div class="rio-media-player-timeline-background"></div>
                        <div class="rio-media-player-timeline-loaded"></div>
                        <div class="rio-media-player-timeline-hover"></div>
                        <div class="rio-media-player-timeline-played">
                            <div class="rio-media-player-timeline-knob"></div>
                        </div>
                    </div>
                </div>
                <!-- Controls -->
                <div class="rio-media-player-controls-row">
                    <div class="rio-media-player-button rio-media-player-button-play"></div>
                    <div class="rio-media-player-button rio-media-player-button-mute"></div>
                    <!-- Volume -->
                    <div class="rio-media-player-volume">
                        <div>
                            <div class="rio-media-player-volume-background"></div>
                            <div class="rio-media-player-volume-current">
                                <div class="rio-media-player-volume-knob"></div>
                            </div>
                        </div>
                    </div>

                    <div class="rio-media-player-playtime-label"></div>

                    <!-- Spacer -->
                    <div style="flex-grow: 1;"></div>

                    <div class="rio-media-player-button rio-media-player-button-fullscreen"></div>
                </div>
            </div>
        `;
                    this.mediaPlayer = element2.querySelector('video');
                    this.altDisplay = element2.querySelector(
                        '.rio-media-player-alt-display'
                    );
                    this.controls = element2.querySelector(
                        '.rio-media-player-controls'
                    );
                    this.playButton = element2.querySelector(
                        '.rio-media-player-button-play'
                    );
                    this.muteButton = element2.querySelector(
                        '.rio-media-player-button-mute'
                    );
                    this.fullscreenButton = element2.querySelector(
                        '.rio-media-player-button-fullscreen'
                    );
                    this.playtimeLabel = element2.querySelector(
                        '.rio-media-player-playtime-label'
                    );
                    this.timelineOuter = element2.querySelector(
                        '.rio-media-player-timeline'
                    );
                    this.timelineLoaded = element2.querySelector(
                        '.rio-media-player-timeline-loaded'
                    );
                    this.timelineHover = element2.querySelector(
                        '.rio-media-player-timeline-hover'
                    );
                    this.timelinePlayed = element2.querySelector(
                        '.rio-media-player-timeline-played'
                    );
                    this.volumeOuter = element2.querySelector(
                        '.rio-media-player-volume'
                    );
                    this.volumeCurrent = element2.querySelector(
                        '.rio-media-player-volume-current'
                    );
                    this.volumeKnob = element2.querySelector(
                        '.rio-media-player-volume-knob'
                    );
                    this.mediaPlayer.addEventListener(
                        'timeupdate',
                        this._updateProgress.bind(this)
                    );
                    element2.addEventListener(
                        'mousemove',
                        this.interact.bind(this),
                        true
                    );
                    element2.addEventListener('click', (event) => {
                        event.stopPropagation();
                        if (!this.state.controls) {
                            return;
                        }
                        this.interact();
                        if (this.mediaPlayer.paused) {
                            this.mediaPlayer.play();
                        } else {
                            this.mediaPlayer.pause();
                        }
                    });
                    this.playButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.interact();
                        if (this.mediaPlayer.paused) {
                            this.mediaPlayer.play();
                        } else {
                            this.mediaPlayer.pause();
                        }
                    });
                    this.muteButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.interact();
                        this.setMute(!this.mediaPlayer.muted);
                    });
                    this.fullscreenButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.interact();
                        this.toggleFullscreen();
                    });
                    document.addEventListener(
                        'fullscreenchange',
                        this._onFullscreenChange.bind(this)
                    );
                    this.timelineOuter.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.interact();
                        this._seekFromMousePosition(event);
                    });
                    this.timelineOuter.addEventListener(
                        'mousemove',
                        (event) => {
                            let rect =
                                this.timelineOuter.getBoundingClientRect();
                            let progress =
                                (event.clientX - rect.left) / rect.width;
                            this.timelineHover.style.width = `${progress * 100}%`;
                            this.timelineHover.style.opacity = '0.5';
                        }
                    );
                    this.timelineOuter.addEventListener('mouseleave', () => {
                        this.timelineHover.style.opacity = '0';
                    });
                    this.addDragHandler({
                        element: this.timelineOuter,
                        onStart: this._onTimelineDragStart.bind(this),
                        onMove: this._onTimelineDrag.bind(this),
                        onEnd: this._onTimelineDragEnd.bind(this),
                    });
                    this.volumeOuter.addEventListener('click', (event) => {
                        event.stopPropagation();
                        if (!this._hasAudio) {
                            return;
                        }
                        this.interact();
                        this._setVolumeFromMousePosition(event);
                    });
                    this.addDragHandler({
                        element: this.volumeOuter,
                        onStart: this._onVolumeDrag.bind(this),
                        onMove: this._onVolumeDrag.bind(this),
                        onEnd: this._onVolumeDragEnd.bind(this),
                    });
                    this.muteButton.addEventListener(
                        'wheel',
                        this._onVolumeWheelEvent.bind(this)
                    );
                    this.volumeOuter.addEventListener(
                        'wheel',
                        this._onVolumeWheelEvent.bind(this)
                    );
                    element2.addEventListener('dblclick', (event) => {
                        event.stopPropagation();
                        if (!this.state.controls) {
                            return;
                        }
                        this.toggleFullscreen();
                    });
                    element2.addEventListener(
                        'keydown',
                        this._onKeyPress.bind(this)
                    );
                    this.mediaPlayer.addEventListener('play', () => {
                        applyIcon(
                            this.playButton,
                            'material/pause:fill',
                            'white'
                        );
                    });
                    this.mediaPlayer.addEventListener('pause', () => {
                        applyIcon(
                            this.playButton,
                            'material/play-arrow:fill',
                            'white'
                        );
                    });
                    this.mediaPlayer.addEventListener('ended', () => {
                        applyIcon(
                            this.playButton,
                            'material/play-arrow:fill',
                            'white'
                        );
                    });
                    this.mediaPlayer.addEventListener(
                        'volumechange',
                        this._onVolumeChange.bind(this)
                    );
                    this.mediaPlayer.addEventListener(
                        'loadedmetadata',
                        async () => {
                            this._updateProgress();
                            let isVideo = this.mediaPlayer.videoWidth > 0;
                            if (isVideo) {
                                this.mediaPlayer.style.removeProperty(
                                    'display'
                                );
                                this.altDisplay.style.display = 'none';
                                this._hasAudio = await hasAudio(
                                    this.mediaPlayer
                                );
                            } else {
                                this.mediaPlayer.style.display = 'none';
                                this.altDisplay.style.removeProperty('display');
                                this._hasAudio = true;
                            }
                            if (this._hasAudio) {
                                this.mediaPlayer.muted = this.state.muted;
                            }
                            this._updateVolumeSliderAndIcon();
                        }
                    );
                    applyIcon(
                        this.altDisplay,
                        'material/music-note:fill',
                        'white'
                    );
                    applyIcon(
                        this.playButton,
                        'material/play-arrow:fill',
                        'white'
                    );
                    applyIcon(
                        this.fullscreenButton,
                        'material/fullscreen',
                        'white'
                    );
                    applyIcon(
                        this.muteButton,
                        'material/volume-up:fill',
                        'white'
                    );
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.mediaUrl !== void 0) {
                        let mediaUrl = new URL(
                            deltaState.mediaUrl,
                            document.location.href
                        ).href;
                        if (mediaUrl !== this.mediaPlayer.src) {
                            this.mediaPlayer.src = mediaUrl;
                            this._updateProgress();
                            this.interact();
                        }
                    }
                    if (deltaState.loop !== void 0) {
                        this.mediaPlayer.loop = deltaState.loop;
                    }
                    if (deltaState.autoplay !== void 0) {
                        this.mediaPlayer.autoplay = deltaState.autoplay;
                    }
                    if (deltaState.controls === true) {
                        this.controls.style.removeProperty('display');
                    } else if (deltaState.controls === false) {
                        this.controls.style.display = 'none';
                    }
                    if (deltaState.volume !== void 0) {
                        this.setVolume(
                            Math.min(1, Math.max(0, deltaState.volume))
                        );
                    }
                    if (deltaState.muted !== void 0) {
                        this.setMute(deltaState.muted);
                    }
                    this._updateVolumeSliderAndIcon();
                    if (deltaState.background !== void 0) {
                        Object.assign(
                            this.element.style,
                            fillToCss(deltaState.background)
                        );
                    }
                    if (deltaState.reportError !== void 0) {
                        if (deltaState.reportError) {
                            if (this.mediaPlayer.onerror === null) {
                                this.mediaPlayer.onerror =
                                    this._onError.bind(this);
                            }
                        } else {
                            this.mediaPlayer.onerror = null;
                        }
                    }
                    if (deltaState.reportPlaybackEnd !== void 0) {
                        if (deltaState.reportPlaybackEnd) {
                            if (this.mediaPlayer.onended === null) {
                                this.mediaPlayer.onended =
                                    this._onPlaybackEnd.bind(this);
                            }
                        } else {
                            this.mediaPlayer.onended = null;
                        }
                    }
                }
                _onVolumeChange() {
                    let newHumanVolume = this.linearVolumeToHuman(
                        this.mediaPlayer.volume
                    );
                    let volumeHasChanged =
                        Math.abs(newHumanVolume - this.state.volume) > 0.01;
                    let mutedHasChanged =
                        this.mediaPlayer.muted !== this.state.muted;
                    if (!volumeHasChanged && !mutedHasChanged) {
                        return;
                    }
                    this._updateVolumeSliderAndIcon();
                    if (this._notifyBackend) {
                        this.setStateAndNotifyBackend({
                            volume: newHumanVolume,
                            muted: this.mediaPlayer.muted,
                        });
                    }
                }
                _updateVolumeSliderAndIcon() {
                    let humanVolume = this.linearVolumeToHuman(
                        this.mediaPlayer.volume
                    );
                    if (
                        this.mediaPlayer.muted ||
                        this.mediaPlayer.volume === 0
                    ) {
                        this.volumeCurrent.style.width = '0';
                        let color = this._hasAudio ? 'white' : 'gray';
                        applyIcon(
                            this.muteButton,
                            'material/volume-off:fill',
                            color
                        );
                        this.volumeKnob.style.background = color;
                    } else {
                        this.volumeCurrent.style.width = `${humanVolume * 100}%`;
                        if (humanVolume < 0.5) {
                            applyIcon(
                                this.muteButton,
                                'material/volume-down:fill',
                                'white'
                            );
                        } else {
                            applyIcon(
                                this.muteButton,
                                'material/volume-up:fill',
                                'white'
                            );
                        }
                    }
                }
                _onVolumeWheelEvent(event) {
                    if (!this._hasAudio) {
                        return;
                    }
                    if (event.deltaY < 0) {
                        this._volumeUp();
                    } else if (event.deltaY !== 0) {
                        this._volumeDown();
                    } else {
                        return;
                    }
                    event.stopPropagation();
                    event.preventDefault();
                }
                _volumeUp() {
                    let humanVolume = this.linearVolumeToHuman(
                        this.mediaPlayer.volume
                    );
                    this.setVolume(Math.min(humanVolume + 0.1, 1));
                }
                _volumeDown() {
                    let humanVolume = this.linearVolumeToHuman(
                        this.mediaPlayer.volume
                    );
                    this.setVolume(Math.max(humanVolume - 0.1, 0));
                }
                _onVolumeDrag(event) {
                    this._notifyBackend = false;
                    this._setVolumeFromMousePosition(event);
                    this.interact();
                    return true;
                }
                _onVolumeDragEnd(event) {
                    this._notifyBackend = true;
                    this.setStateAndNotifyBackend({
                        volume: this.linearVolumeToHuman(
                            this.mediaPlayer.volume
                        ),
                    });
                }
                _setVolumeFromMousePosition(event) {
                    let rect = this.volumeOuter.getBoundingClientRect();
                    let volume = (event.clientX - rect.left) / rect.width;
                    volume = Math.min(1, Math.max(0, volume));
                    this.setVolume(volume);
                }
                _getProgressFractionFromMousePosition(event) {
                    let rect = this.timelineOuter.getBoundingClientRect();
                    return (event.clientX - rect.left) / rect.width;
                }
                _onTimelineDragStart(event) {
                    this.mediaPlayer.pause();
                    this._onTimelineDrag(event);
                    return true;
                }
                _onTimelineDrag(event) {
                    let progress =
                        this._getProgressFractionFromMousePosition(event);
                    this.timelinePlayed.style.width = `${progress * 100}%`;
                    this.mediaPlayer.currentTime =
                        this.mediaPlayer.duration * progress;
                    this.interact();
                }
                _onTimelineDragEnd(event) {
                    this.mediaPlayer.play();
                }
                _seekFromMousePosition(event) {
                    let progress =
                        this._getProgressFractionFromMousePosition(event);
                    this.mediaPlayer.currentTime =
                        this.mediaPlayer.duration * progress;
                }
                _onKeyPress(event) {
                    if (
                        !this.state.controls ||
                        event.altKey ||
                        event.ctrlKey ||
                        event.metaKey ||
                        event.shiftKey
                    ) {
                        return;
                    }
                    switch (event.key) {
                        case ' ':
                            if (this.mediaPlayer.paused) {
                                this.mediaPlayer.play();
                            } else {
                                this.mediaPlayer.pause();
                            }
                            break;
                        case 'm':
                            this.setMute(!this.mediaPlayer.muted);
                            break;
                        case 'f':
                            this.toggleFullscreen();
                            break;
                        case 'ArrowLeft':
                            this.mediaPlayer.currentTime -= 5;
                            break;
                        case 'ArrowRight':
                            this.mediaPlayer.currentTime += 5;
                            break;
                        case 'ArrowUp':
                            this._volumeUp();
                            break;
                        case 'ArrowDown':
                            this._volumeDown();
                            break;
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                            let percentage = parseInt(event.key) / 10;
                            this.mediaPlayer.currentTime =
                                this.mediaPlayer.duration * percentage;
                            this.interact();
                            break;
                        case 'Escape':
                            if (this._isFullScreen) {
                                this.toggleFullscreen();
                            }
                            break;
                        default:
                            return;
                    }
                    event.stopPropagation();
                    event.preventDefault();
                }
                grabKeyboardFocus() {
                    this.element.focus();
                }
                _onError(event) {
                    this.sendMessageToBackend({
                        type: 'onError',
                    });
                }
                _onPlaybackEnd(event) {
                    this.sendMessageToBackend({
                        type: 'onPlaybackEnd',
                    });
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 16;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 5;
                }
            }
            function eventMouseButtonToString(event) {
                return {
                    button: ['left', 'middle', 'right'][event.button],
                };
            }
            function eventMousePositionToString(event) {
                return {
                    x: event.clientX / pixelsPerRem,
                    y: event.clientY / pixelsPerRem,
                };
            }
            function findComponentUnderMouse(event) {
                let element2 = document.elementFromPoint(
                    event.clientX,
                    event.clientY
                );
                let component;
                while (true) {
                    component = tryGetComponentByElement(element2);
                    if (component !== null) {
                        break;
                    }
                    element2 = element2.parentElement;
                }
                while (component.isInjectedLayoutComponent()) {
                    component = component.parent;
                }
                return component.id;
            }
            class MouseEventListenerComponent extends SingleContainer {
                constructor() {
                    super(...arguments);
                    this._dragHandler = null;
                }
                createElement() {
                    return document.createElement('div');
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                    if (deltaState.reportPress) {
                        this.element.onclick = (e) => {
                            this.sendMessageToBackend({
                                type: 'press',
                                ...eventMouseButtonToString(e),
                                ...eventMousePositionToString(e),
                            });
                        };
                    } else {
                        this.element.onclick = null;
                    }
                    if (deltaState.reportMouseDown) {
                        this.element.onmousedown = (e) => {
                            this.sendMessageToBackend({
                                type: 'mouseDown',
                                ...eventMouseButtonToString(e),
                                ...eventMousePositionToString(e),
                            });
                        };
                    } else {
                        this.element.onmousedown = null;
                    }
                    if (deltaState.reportMouseUp) {
                        this.element.onmouseup = (e) => {
                            this.sendMessageToBackend({
                                type: 'mouseUp',
                                ...eventMouseButtonToString(e),
                                ...eventMousePositionToString(e),
                            });
                        };
                    } else {
                        this.element.onmouseup = null;
                    }
                    if (deltaState.reportMouseMove) {
                        this.element.onmousemove = (e) => {
                            this.sendMessageToBackend({
                                type: 'mouseMove',
                                ...eventMousePositionToString(e),
                            });
                        };
                    } else {
                        this.element.onmousemove = null;
                    }
                    if (deltaState.reportMouseEnter) {
                        this.element.onmouseenter = (e) => {
                            this.sendMessageToBackend({
                                type: 'mouseEnter',
                                ...eventMousePositionToString(e),
                            });
                        };
                    } else {
                        this.element.onmouseenter = null;
                    }
                    if (deltaState.reportMouseLeave) {
                        this.element.onmouseleave = (e) => {
                            this.sendMessageToBackend({
                                type: 'mouseLeave',
                                ...eventMousePositionToString(e),
                            });
                        };
                    } else {
                        this.element.onmouseleave = null;
                    }
                    if (
                        deltaState.reportDragStart ||
                        deltaState.reportDragMove ||
                        deltaState.reportDragEnd
                    ) {
                        if (this._dragHandler === null) {
                            this._dragHandler = this.addDragHandler({
                                element: this.element,
                                onStart: this._onDragStart.bind(this),
                                onMove: this._onDragMove.bind(this),
                                onEnd: this._onDragEnd.bind(this),
                            });
                        }
                    } else {
                        if (this._dragHandler !== null) {
                            this._dragHandler.disconnect();
                            this._dragHandler = null;
                        }
                    }
                }
                _onDragStart(event) {
                    if (this.state.reportDragStart) {
                        this._sendDragEvent('dragStart', event);
                    }
                    return true;
                }
                _onDragMove(event) {
                    if (this.state.reportDragMove) {
                        this._sendDragEvent('dragMove', event);
                    }
                }
                _onDragEnd(event) {
                    if (this.state.reportDragEnd) {
                        this._sendDragEvent('dragEnd', event);
                    }
                }
                _sendDragEvent(eventType, event) {
                    this.sendMessageToBackend({
                        type: eventType,
                        ...eventMouseButtonToString(event),
                        x: event.clientX / pixelsPerRem,
                        y: event.clientY / pixelsPerRem,
                        component: findComponentUnderMouse(event),
                    });
                }
            }
            class MultiLineTextInputComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add(
                        'rio-text-input',
                        'rio-input-box',
                        'mdc-ripple-surface'
                    );
                    element2.innerHTML = `
            <textarea placeholder=""></textarea>
            <div class="rio-input-box-label"></div>
            <div class="rio-input-box-plain-bar"></div>
            <div class="rio-input-box-color-bar"></div>
        `;
                    this.labelElement = element2.querySelector(
                        '.rio-input-box-label'
                    );
                    this.inputElement = element2.querySelector('textarea');
                    this.inputElement.addEventListener('blur', () => {
                        this.setStateAndNotifyBackend({
                            text: this.inputElement.value,
                        });
                    });
                    this.inputElement.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter' && event.shiftKey) {
                            this.state.text = this.inputElement.value;
                            this.sendMessageToBackend({
                                text: this.state.text,
                            });
                            event.preventDefault();
                        }
                        event.stopPropagation();
                    });
                    this.inputElement.addEventListener('mousedown', (event) => {
                        event.stopPropagation();
                    });
                    element2.addEventListener('click', (event) => {
                        this.inputElement.focus();
                        event.stopPropagation();
                    });
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.text !== void 0) {
                        this.inputElement.value = deltaState.text;
                    }
                    if (deltaState.label !== void 0) {
                        this.labelElement.textContent = deltaState.label;
                        updateInputBoxNaturalHeight(this, deltaState.label, 0);
                    }
                    if (deltaState.is_sensitive === true) {
                        this.inputElement.disabled = false;
                        this.element.classList.remove('rio-disabled-input');
                    } else if (deltaState.is_sensitive === false) {
                        this.inputElement.disabled = true;
                        this.element.classList.add('rio-disabled-input');
                    }
                    if (deltaState.is_valid === false) {
                        this.element.style.setProperty(
                            '--rio-local-text-color',
                            'var(--rio-global-danger-bg)'
                        );
                    } else if (deltaState.is_valid === true) {
                        this.element.style.removeProperty(
                            '--rio-local-text-color'
                        );
                    }
                }
                grabKeyboardFocus() {
                    this.inputElement.focus();
                }
                updateNaturalWidth(ctx) {
                    updateInputBoxNaturalWidth(this, 0);
                }
                updateNaturalHeight(ctx) {}
            }
            class NodeInputComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add(
                        'rio-node-editor-port',
                        'rio-node-editor-input'
                    );
                    element2.innerHTML = `
            <div class="rio-node-editor-port-circle"></div>
            <div class="rio-node-editor-port-text"></div>
        `;
                    this.textElement = element2.querySelector(
                        '.rio-node-editor-port-text'
                    );
                    this.circleElement = element2.querySelector(
                        '.rio-node-editor-port-circle'
                    );
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.name !== void 0) {
                        this.textElement.textContent = deltaState.name;
                        let textDimensions = getTextDimensions(
                            deltaState.name,
                            'text'
                        );
                        this.naturalWidth = textDimensions[0];
                        this.naturalHeight = textDimensions[1];
                    }
                    if (deltaState.color !== void 0) {
                        this.element.style.setProperty(
                            '--port-color',
                            colorToCssString(deltaState.color)
                        );
                    }
                }
                updateNaturalWidth(ctx) {}
                updateNaturalHeight(ctx) {}
            }
            class NodeOutputComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add(
                        'rio-node-editor-port',
                        'rio-node-editor-output'
                    );
                    element2.innerHTML = `
            <div class="rio-node-editor-port-circle"></div>
            <div class="rio-node-editor-port-text"></div>
        `;
                    this.textElement = element2.querySelector(
                        '.rio-node-editor-port-text'
                    );
                    this.circleElement = element2.querySelector(
                        '.rio-node-editor-port-circle'
                    );
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.name !== void 0) {
                        this.textElement.textContent = deltaState.name;
                        let textDimensions = getTextDimensions(
                            deltaState.name,
                            'text'
                        );
                        this.naturalWidth = textDimensions[0];
                        this.naturalHeight = textDimensions[1];
                    }
                    if (deltaState.color !== void 0) {
                        this.element.style.setProperty(
                            '--port-color',
                            colorToCssString(deltaState.color)
                        );
                    }
                }
                updateNaturalWidth(ctx) {}
                updateNaturalHeight(ctx) {}
            }
            class OverlayComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-overlay');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                }
                updateAllocatedWidth(ctx) {
                    let root = getRootComponent();
                    componentsById[this.state.content].allocatedWidth =
                        root.overlayWidth;
                }
                updateAllocatedHeight(ctx) {
                    let root = getRootComponent();
                    componentsById[this.state.content].allocatedHeight =
                        root.overlayHeight;
                    let element2 = componentsById[this.state.content].element;
                    element2.style.left = '0';
                    element2.style.top = '0';
                }
            }
            class PlaceholderComponent extends SingleContainer {
                createElement() {
                    return document.createElement('div');
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState._child_
                    );
                }
            }
            let fetchPlotlyPromise = null;
            function withPlotly(callback) {
                if (typeof window['Plotly'] !== 'undefined') {
                    callback();
                    return;
                }
                if (fetchPlotlyPromise !== null) {
                    fetchPlotlyPromise.then(callback);
                    return;
                }
                console.log('Fetching plotly.js');
                let script = document.createElement('script');
                script.src = '/rio/asset/plotly.min.js';
                fetchPlotlyPromise = new Promise((resolve) => {
                    script.onload = () => {
                        resolve(null);
                    };
                    document.head.appendChild(script);
                }).then(callback);
            }
            class PlotComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-plot');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.plot !== void 0) {
                        this.element.innerHTML = '';
                        if (deltaState.plot.type === 'plotly') {
                            let plot = deltaState.plot;
                            withPlotly(() => {
                                let plotJson = JSON.parse(plot.json);
                                window['Plotly'].newPlot(
                                    this.element,
                                    plotJson.data,
                                    plotJson.layout
                                );
                                this.updatePlotlyLayout();
                            });
                        } else {
                            this.element.innerHTML = deltaState.plot.svg;
                            let svgElement = this.element.querySelector('svg');
                            svgElement.style.width = '100%';
                            svgElement.style.height = '100%';
                        }
                    }
                    if (deltaState.background === null) {
                        this.element.style.background =
                            'var(--rio-local-plain-bg-variant)';
                    } else if (deltaState.background !== void 0) {
                        Object.assign(
                            this.element.style,
                            fillToCss(deltaState.background)
                        );
                    }
                    if (deltaState.corner_radius !== void 0) {
                        let [topLeft, topRight, bottomRight, bottomLeft] =
                            deltaState.corner_radius;
                        this.element.style.borderRadius = `${topLeft}rem ${topRight}rem ${bottomRight}rem ${bottomLeft}rem`;
                    }
                }
                updatePlotlyLayout() {
                    window['Plotly'].update(
                        this.element,
                        {},
                        {
                            width: this.allocatedWidth * pixelsPerRem,
                            height: this.allocatedHeight * pixelsPerRem,
                        }
                    );
                }
                updateAllocatedHeight(ctx) {
                    if (
                        this.state.plot.type === 'plotly' &&
                        window['Plotly'] !== void 0
                    ) {
                        this.updatePlotlyLayout();
                    }
                }
            }
            class PopupComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-popup');
                    this.anchorContainer = document.createElement('div');
                    this.anchorContainer.classList.add('rio-popup-anchor');
                    element2.appendChild(this.anchorContainer);
                    this.contentContainer = document.createElement('div');
                    this.contentContainer.classList.add('rio-popup-content');
                    element2.appendChild(this.contentContainer);
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.anchor,
                        this.anchorContainer
                    );
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content,
                        this.contentContainer
                    );
                    if (deltaState.is_open === true) {
                        this.open();
                    } else {
                        this.element.classList.remove('rio-popup-open');
                    }
                    if (deltaState.color !== void 0) {
                        applyColorSet(this.element, deltaState.color);
                    }
                }
                open() {
                    let element2 = this.element;
                    element2.classList.add('rio-popup-open');
                    let anchorRelativeX, anchorRelativeY;
                    let contentRelativeX, contentRelativeY;
                    let fixedOffsetXRem, fixedOffsetYRem;
                    if (this.state.direction === 'left') {
                        anchorRelativeX = 0;
                        anchorRelativeY = this.state.alignment;
                        contentRelativeX = 1;
                        contentRelativeY = this.state.alignment;
                        fixedOffsetXRem = -this.state.gap;
                        fixedOffsetYRem = 0;
                    } else if (this.state.direction === 'top') {
                        anchorRelativeX = this.state.alignment;
                        anchorRelativeY = 0;
                        contentRelativeX = this.state.alignment;
                        contentRelativeY = 1;
                        fixedOffsetXRem = 0;
                        fixedOffsetYRem = -this.state.gap;
                    } else if (this.state.direction === 'right') {
                        anchorRelativeX = 1;
                        anchorRelativeY = this.state.alignment;
                        contentRelativeX = 0;
                        contentRelativeY = this.state.alignment;
                        fixedOffsetXRem = this.state.gap;
                        fixedOffsetYRem = 0;
                    } else if (this.state.direction === 'bottom') {
                        anchorRelativeX = this.state.alignment;
                        anchorRelativeY = 1;
                        contentRelativeX = this.state.alignment;
                        contentRelativeY = 0;
                        fixedOffsetXRem = 0;
                        fixedOffsetYRem = this.state.gap;
                    } else if (this.state.direction === 'center') {
                        anchorRelativeX = 0.5;
                        anchorRelativeY = 0.5;
                        contentRelativeX = 0.5;
                        contentRelativeY = 0.5;
                        fixedOffsetXRem = 0;
                        fixedOffsetYRem = 0;
                    }
                    let screenWidth = window.innerWidth;
                    let screenHeight = window.innerHeight;
                    let anchorRect =
                        this.anchorContainer.getBoundingClientRect();
                    let popupWidth = this.contentContainer.scrollWidth;
                    let popupHeight = this.contentContainer.scrollHeight;
                    let anchorPointX =
                        anchorRect.left + anchorRect.width * anchorRelativeX;
                    let anchorPointY =
                        anchorRect.top + anchorRect.height * anchorRelativeY;
                    let popupPointX = popupWidth * contentRelativeX;
                    let popupPointY = popupHeight * contentRelativeY;
                    let spawnPointX =
                        anchorPointX -
                        popupPointX +
                        fixedOffsetXRem * pixelsPerRem;
                    let spawnPointY =
                        anchorPointY -
                        popupPointY +
                        fixedOffsetYRem * pixelsPerRem;
                    let margin = 1 * pixelsPerRem;
                    let minX = margin;
                    let maxX = screenWidth - popupWidth - margin;
                    let minY = margin;
                    let maxY = screenHeight - popupHeight - margin;
                    spawnPointX = Math.min(Math.max(spawnPointX, minX), maxX);
                    spawnPointY = Math.min(Math.max(spawnPointY, minY), maxY);
                    this.contentContainer.style.left = spawnPointX + 'px';
                    this.contentContainer.style.top = spawnPointY + 'px';
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth =
                        componentsById[this.state.anchor].requestedWidth;
                }
                updateAllocatedWidth(ctx) {
                    let anchorInst = componentsById[this.state.anchor];
                    anchorInst.allocatedWidth = this.allocatedWidth;
                    let contentInst = componentsById[this.state.content];
                    contentInst.allocatedWidth = contentInst.requestedWidth;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight =
                        componentsById[this.state.anchor].requestedHeight;
                }
                updateAllocatedHeight(ctx) {
                    let anchorInst = componentsById[this.state.anchor];
                    anchorInst.allocatedHeight = this.allocatedHeight;
                    let contentInst = componentsById[this.state.content];
                    contentInst.allocatedHeight = contentInst.requestedHeight;
                    let anchorElem = anchorInst.element;
                    anchorElem.style.left = '0';
                    anchorElem.style.top = '0';
                    let contentElem = contentInst.element;
                    contentElem.style.left = '0';
                    contentElem.style.top = '0';
                }
            }
            /**
             * @license
             * Copyright 2016 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var cssPropertyNameMap = {
                animation: {
                    prefixed: '-webkit-animation',
                    standard: 'animation',
                },
                transform: {
                    prefixed: '-webkit-transform',
                    standard: 'transform',
                },
                transition: {
                    prefixed: '-webkit-transition',
                    standard: 'transition',
                },
            };
            function isWindow(windowObj) {
                return (
                    Boolean(windowObj.document) &&
                    typeof windowObj.document.createElement === 'function'
                );
            }
            function getCorrectPropertyName(windowObj, cssProperty) {
                if (isWindow(windowObj) && cssProperty in cssPropertyNameMap) {
                    var el = windowObj.document.createElement('div');
                    var _a = cssPropertyNameMap[cssProperty],
                        standard = _a.standard,
                        prefixed = _a.prefixed;
                    var isStandard = standard in el.style;
                    return isStandard ? standard : prefixed;
                }
                return cssProperty;
            }
            /**
             * @license
             * Copyright 2017 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var cssClasses$1 = {
                CLOSED_CLASS: 'mdc-linear-progress--closed',
                CLOSED_ANIMATION_OFF_CLASS:
                    'mdc-linear-progress--closed-animation-off',
                INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
                REVERSED_CLASS: 'mdc-linear-progress--reversed',
                ANIMATION_READY_CLASS: 'mdc-linear-progress--animation-ready',
            };
            var strings$1 = {
                ARIA_HIDDEN: 'aria-hidden',
                ARIA_VALUEMAX: 'aria-valuemax',
                ARIA_VALUEMIN: 'aria-valuemin',
                ARIA_VALUENOW: 'aria-valuenow',
                BUFFER_BAR_SELECTOR: '.mdc-linear-progress__buffer-bar',
                FLEX_BASIS: 'flex-basis',
                PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
            };
            var animationDimensionPercentages = {
                PRIMARY_HALF: 0.8367142,
                PRIMARY_FULL: 2.00611057,
                SECONDARY_QUARTER: 0.37651913,
                SECONDARY_HALF: 0.84386165,
                SECONDARY_FULL: 1.60277782,
            };
            /**
             * @license
             * Copyright 2017 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var MDCLinearProgressFoundation =
                /** @class */
                (function (_super) {
                    __extends(MDCLinearProgressFoundation2, _super);
                    function MDCLinearProgressFoundation2(adapter) {
                        var _this =
                            _super.call(
                                this,
                                __assign(
                                    __assign(
                                        {},
                                        MDCLinearProgressFoundation2.defaultAdapter
                                    ),
                                    adapter
                                )
                            ) || this;
                        _this.observer = null;
                        return _this;
                    }
                    Object.defineProperty(
                        MDCLinearProgressFoundation2,
                        'cssClasses',
                        {
                            get: function () {
                                return cssClasses$1;
                            },
                            enumerable: false,
                            configurable: true,
                        }
                    );
                    Object.defineProperty(
                        MDCLinearProgressFoundation2,
                        'strings',
                        {
                            get: function () {
                                return strings$1;
                            },
                            enumerable: false,
                            configurable: true,
                        }
                    );
                    Object.defineProperty(
                        MDCLinearProgressFoundation2,
                        'defaultAdapter',
                        {
                            get: function () {
                                return {
                                    addClass: function () {
                                        return void 0;
                                    },
                                    attachResizeObserver: function () {
                                        return null;
                                    },
                                    forceLayout: function () {
                                        return void 0;
                                    },
                                    getWidth: function () {
                                        return 0;
                                    },
                                    hasClass: function () {
                                        return false;
                                    },
                                    setBufferBarStyle: function () {
                                        return null;
                                    },
                                    setPrimaryBarStyle: function () {
                                        return null;
                                    },
                                    setStyle: function () {
                                        return void 0;
                                    },
                                    removeAttribute: function () {
                                        return void 0;
                                    },
                                    removeClass: function () {
                                        return void 0;
                                    },
                                    setAttribute: function () {
                                        return void 0;
                                    },
                                };
                            },
                            enumerable: false,
                            configurable: true,
                        }
                    );
                    MDCLinearProgressFoundation2.prototype.init = function () {
                        var _this = this;
                        this.determinate = !this.adapter.hasClass(
                            cssClasses$1.INDETERMINATE_CLASS
                        );
                        this.adapter.addClass(
                            cssClasses$1.ANIMATION_READY_CLASS
                        );
                        this.progress = 0;
                        this.buffer = 1;
                        this.observer = this.adapter.attachResizeObserver(
                            function (entries) {
                                var e_1, _a;
                                if (_this.determinate) {
                                    return;
                                }
                                try {
                                    for (
                                        var entries_1 = __values(entries),
                                            entries_1_1 = entries_1.next();
                                        !entries_1_1.done;
                                        entries_1_1 = entries_1.next()
                                    ) {
                                        var entry = entries_1_1.value;
                                        if (entry.contentRect) {
                                            _this.calculateAndSetDimensions(
                                                entry.contentRect.width
                                            );
                                        }
                                    }
                                } catch (e_1_1) {
                                    e_1 = { error: e_1_1 };
                                } finally {
                                    try {
                                        if (
                                            entries_1_1 &&
                                            !entries_1_1.done &&
                                            (_a = entries_1.return)
                                        )
                                            _a.call(entries_1);
                                    } finally {
                                        if (e_1) throw e_1.error;
                                    }
                                }
                            }
                        );
                        if (!this.determinate && this.observer) {
                            this.calculateAndSetDimensions(
                                this.adapter.getWidth()
                            );
                        }
                    };
                    MDCLinearProgressFoundation2.prototype.setDeterminate =
                        function (isDeterminate) {
                            this.determinate = isDeterminate;
                            if (this.determinate) {
                                this.adapter.removeClass(
                                    cssClasses$1.INDETERMINATE_CLASS
                                );
                                this.adapter.setAttribute(
                                    strings$1.ARIA_VALUENOW,
                                    this.progress.toString()
                                );
                                this.adapter.setAttribute(
                                    strings$1.ARIA_VALUEMAX,
                                    '1'
                                );
                                this.adapter.setAttribute(
                                    strings$1.ARIA_VALUEMIN,
                                    '0'
                                );
                                this.setPrimaryBarProgress(this.progress);
                                this.setBufferBarProgress(this.buffer);
                                return;
                            }
                            if (this.observer) {
                                this.calculateAndSetDimensions(
                                    this.adapter.getWidth()
                                );
                            }
                            this.adapter.addClass(
                                cssClasses$1.INDETERMINATE_CLASS
                            );
                            this.adapter.removeAttribute(
                                strings$1.ARIA_VALUENOW
                            );
                            this.adapter.removeAttribute(
                                strings$1.ARIA_VALUEMAX
                            );
                            this.adapter.removeAttribute(
                                strings$1.ARIA_VALUEMIN
                            );
                            this.setPrimaryBarProgress(1);
                            this.setBufferBarProgress(1);
                        };
                    MDCLinearProgressFoundation2.prototype.isDeterminate =
                        function () {
                            return this.determinate;
                        };
                    MDCLinearProgressFoundation2.prototype.setProgress =
                        function (value) {
                            this.progress = value;
                            if (this.determinate) {
                                this.setPrimaryBarProgress(value);
                                this.adapter.setAttribute(
                                    strings$1.ARIA_VALUENOW,
                                    value.toString()
                                );
                            }
                        };
                    MDCLinearProgressFoundation2.prototype.getProgress =
                        function () {
                            return this.progress;
                        };
                    MDCLinearProgressFoundation2.prototype.setBuffer =
                        function (value) {
                            this.buffer = value;
                            if (this.determinate) {
                                this.setBufferBarProgress(value);
                            }
                        };
                    MDCLinearProgressFoundation2.prototype.getBuffer =
                        function () {
                            return this.buffer;
                        };
                    MDCLinearProgressFoundation2.prototype.open = function () {
                        this.adapter.removeClass(cssClasses$1.CLOSED_CLASS);
                        this.adapter.removeClass(
                            cssClasses$1.CLOSED_ANIMATION_OFF_CLASS
                        );
                        this.adapter.removeAttribute(strings$1.ARIA_HIDDEN);
                    };
                    MDCLinearProgressFoundation2.prototype.close = function () {
                        this.adapter.addClass(cssClasses$1.CLOSED_CLASS);
                        this.adapter.setAttribute(
                            strings$1.ARIA_HIDDEN,
                            'true'
                        );
                    };
                    MDCLinearProgressFoundation2.prototype.isClosed =
                        function () {
                            return this.adapter.hasClass(
                                cssClasses$1.CLOSED_CLASS
                            );
                        };
                    MDCLinearProgressFoundation2.prototype.handleTransitionEnd =
                        function () {
                            if (
                                this.adapter.hasClass(cssClasses$1.CLOSED_CLASS)
                            ) {
                                this.adapter.addClass(
                                    cssClasses$1.CLOSED_ANIMATION_OFF_CLASS
                                );
                            }
                        };
                    MDCLinearProgressFoundation2.prototype.destroy =
                        function () {
                            _super.prototype.destroy.call(this);
                            if (this.observer) {
                                this.observer.disconnect();
                            }
                        };
                    MDCLinearProgressFoundation2.prototype.restartAnimation =
                        function () {
                            this.adapter.removeClass(
                                cssClasses$1.ANIMATION_READY_CLASS
                            );
                            this.adapter.forceLayout();
                            this.adapter.addClass(
                                cssClasses$1.ANIMATION_READY_CLASS
                            );
                        };
                    MDCLinearProgressFoundation2.prototype.setPrimaryBarProgress =
                        function (progressValue) {
                            var value = 'scaleX(' + progressValue + ')';
                            var transformProp =
                                typeof window !== 'undefined'
                                    ? getCorrectPropertyName(
                                          window,
                                          'transform'
                                      )
                                    : 'transform';
                            this.adapter.setPrimaryBarStyle(
                                transformProp,
                                value
                            );
                        };
                    MDCLinearProgressFoundation2.prototype.setBufferBarProgress =
                        function (progressValue) {
                            var value = progressValue * 100 + '%';
                            this.adapter.setBufferBarStyle(
                                strings$1.FLEX_BASIS,
                                value
                            );
                        };
                    MDCLinearProgressFoundation2.prototype.calculateAndSetDimensions =
                        function (width) {
                            var primaryHalf =
                                width *
                                animationDimensionPercentages.PRIMARY_HALF;
                            var primaryFull =
                                width *
                                animationDimensionPercentages.PRIMARY_FULL;
                            var secondaryQuarter =
                                width *
                                animationDimensionPercentages.SECONDARY_QUARTER;
                            var secondaryHalf =
                                width *
                                animationDimensionPercentages.SECONDARY_HALF;
                            var secondaryFull =
                                width *
                                animationDimensionPercentages.SECONDARY_FULL;
                            this.adapter.setStyle(
                                '--mdc-linear-progress-primary-half',
                                primaryHalf + 'px'
                            );
                            this.adapter.setStyle(
                                '--mdc-linear-progress-primary-half-neg',
                                -primaryHalf + 'px'
                            );
                            this.adapter.setStyle(
                                '--mdc-linear-progress-primary-full',
                                primaryFull + 'px'
                            );
                            this.adapter.setStyle(
                                '--mdc-linear-progress-primary-full-neg',
                                -primaryFull + 'px'
                            );
                            this.adapter.setStyle(
                                '--mdc-linear-progress-secondary-quarter',
                                secondaryQuarter + 'px'
                            );
                            this.adapter.setStyle(
                                '--mdc-linear-progress-secondary-quarter-neg',
                                -secondaryQuarter + 'px'
                            );
                            this.adapter.setStyle(
                                '--mdc-linear-progress-secondary-half',
                                secondaryHalf + 'px'
                            );
                            this.adapter.setStyle(
                                '--mdc-linear-progress-secondary-half-neg',
                                -secondaryHalf + 'px'
                            );
                            this.adapter.setStyle(
                                '--mdc-linear-progress-secondary-full',
                                secondaryFull + 'px'
                            );
                            this.adapter.setStyle(
                                '--mdc-linear-progress-secondary-full-neg',
                                -secondaryFull + 'px'
                            );
                            this.restartAnimation();
                        };
                    return MDCLinearProgressFoundation2;
                })(MDCFoundation);
            /**
             * @license
             * Copyright 2017 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var MDCLinearProgress =
                /** @class */
                (function (_super) {
                    __extends(MDCLinearProgress2, _super);
                    function MDCLinearProgress2() {
                        return (
                            (_super !== null &&
                                _super.apply(this, arguments)) ||
                            this
                        );
                    }
                    MDCLinearProgress2.attachTo = function (root) {
                        return new MDCLinearProgress2(root);
                    };
                    Object.defineProperty(
                        MDCLinearProgress2.prototype,
                        'determinate',
                        {
                            set: function (value) {
                                this.foundation.setDeterminate(value);
                            },
                            enumerable: false,
                            configurable: true,
                        }
                    );
                    Object.defineProperty(
                        MDCLinearProgress2.prototype,
                        'progress',
                        {
                            set: function (value) {
                                this.foundation.setProgress(value);
                            },
                            enumerable: false,
                            configurable: true,
                        }
                    );
                    Object.defineProperty(
                        MDCLinearProgress2.prototype,
                        'buffer',
                        {
                            set: function (value) {
                                this.foundation.setBuffer(value);
                            },
                            enumerable: false,
                            configurable: true,
                        }
                    );
                    MDCLinearProgress2.prototype.open = function () {
                        this.foundation.open();
                    };
                    MDCLinearProgress2.prototype.close = function () {
                        this.foundation.close();
                    };
                    MDCLinearProgress2.prototype.initialSyncWithDOM =
                        function () {
                            var _this = this;
                            this.root.addEventListener(
                                'transitionend',
                                function () {
                                    _this.foundation.handleTransitionEnd();
                                }
                            );
                        };
                    MDCLinearProgress2.prototype.getDefaultFoundation =
                        function () {
                            var _this = this;
                            var adapter = {
                                addClass: function (className) {
                                    _this.root.classList.add(className);
                                },
                                forceLayout: function () {
                                    _this.root.getBoundingClientRect();
                                },
                                setBufferBarStyle: function (
                                    styleProperty,
                                    value
                                ) {
                                    var bufferBar = _this.root.querySelector(
                                        MDCLinearProgressFoundation.strings
                                            .BUFFER_BAR_SELECTOR
                                    );
                                    if (bufferBar) {
                                        bufferBar.style.setProperty(
                                            styleProperty,
                                            value
                                        );
                                    }
                                },
                                setPrimaryBarStyle: function (
                                    styleProperty,
                                    value
                                ) {
                                    var primaryBar = _this.root.querySelector(
                                        MDCLinearProgressFoundation.strings
                                            .PRIMARY_BAR_SELECTOR
                                    );
                                    if (primaryBar) {
                                        primaryBar.style.setProperty(
                                            styleProperty,
                                            value
                                        );
                                    }
                                },
                                hasClass: function (className) {
                                    return _this.root.classList.contains(
                                        className
                                    );
                                },
                                removeAttribute: function (attributeName) {
                                    _this.root.removeAttribute(attributeName);
                                },
                                removeClass: function (className) {
                                    _this.root.classList.remove(className);
                                },
                                setAttribute: function (attributeName, value) {
                                    _this.root.setAttribute(
                                        attributeName,
                                        value
                                    );
                                },
                                setStyle: function (name, value) {
                                    _this.root.style.setProperty(name, value);
                                },
                                attachResizeObserver: function (callback) {
                                    var RO = window.ResizeObserver;
                                    if (RO) {
                                        var ro = new RO(callback);
                                        ro.observe(_this.root);
                                        return ro;
                                    }
                                    return null;
                                },
                                getWidth: function () {
                                    return _this.root.offsetWidth;
                                },
                            };
                            return new MDCLinearProgressFoundation(adapter);
                        };
                    return MDCLinearProgress2;
                })(MDCComponent);
            class ProgressBarComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('mdc-linear-progress');
                    element2.setAttribute('role', 'progressbar');
                    element2.innerHTML = `
<div class="mdc-linear-progress__buffer">
    <div class="mdc-linear-progress__buffer-bar"></div>
    <div class="mdc-linear-progress__buffer-dots"></div>
</div>
<div class="mdc-linear-progress__bar mdc-linear-progress__primary-bar">
    <span class="mdc-linear-progress__bar-inner"></span>
</div>
<div class="mdc-linear-progress__bar mdc-linear-progress__secondary-bar">
    <span class="mdc-linear-progress__bar-inner"></span>
</div>
        `;
                    this.mdcProgress = new MDCLinearProgress(element2);
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.progress === void 0);
                    else if (deltaState.progress === null) {
                        this.mdcProgress.determinate = false;
                    } else {
                        this.mdcProgress.determinate = true;
                        this.mdcProgress.progress = deltaState.progress;
                    }
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 3;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 0.2;
                }
            }
            class ProgressCircleComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.innerHTML = `
            <svg viewBox="25 25 50 50">
                <circle class="progress" cx="50" cy="50" r="20"></circle>
            </svg>
        `;
                    element2.classList.add('rio-progress-circle');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.progress !== void 0) {
                        if (deltaState.progress === null) {
                            this.element.classList.add('spinning');
                        } else {
                            this.element.classList.remove('spinning');
                            let fullCircle = 40 * Math.PI;
                            this.element.style.setProperty(
                                '--dasharray',
                                `${deltaState.progress * fullCircle}, ${(1 - deltaState.progress) * fullCircle}`
                            );
                        }
                    }
                    if (deltaState.color !== void 0) {
                        applyColorSet(
                            this.element,
                            deltaState.color === 'keep'
                                ? 'accent-to-plain'
                                : deltaState.color
                        );
                    }
                }
            }
            function numberToRem(num) {
                return `${num}rem`;
            }
            const JS_TO_CSS_VALUE = {
                fill: fillToCssString,
                stroke_color: colorToCssString,
                stroke_width: numberToRem,
                corner_radius: (radii) =>
                    radii.map((num) => `${num}rem`).join(' '),
                shadow_color: colorToCssString,
                shadow_radius: numberToRem,
                shadow_offset_x: numberToRem,
                shadow_offset_y: numberToRem,
            };
            class RectangleComponent extends SingleContainer {
                constructor() {
                    super(...arguments);
                    this.mdcRipple = null;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-rectangle');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    let element2 = this.element;
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                    if (deltaState.transition_time !== void 0) {
                        element2.style.transitionDuration = `${deltaState.transition_time}s`;
                    }
                    if (deltaState.cursor !== void 0) {
                        if (deltaState.cursor === 'default') {
                            element2.style.removeProperty('cursor');
                        } else {
                            element2.style.cursor = deltaState.cursor;
                        }
                    }
                    if (deltaState.ripple === true) {
                        if (this.mdcRipple === null) {
                            this.mdcRipple = new MDCRipple(element2);
                            element2.classList.add('mdc-ripple-surface');
                            element2.classList.add('rio-rectangle-ripple');
                        }
                    } else if (deltaState.ripple === false) {
                        if (this.mdcRipple !== null) {
                            this.mdcRipple.destroy();
                            this.mdcRipple = null;
                            element2.classList.remove('mdc-ripple-surface');
                            element2.classList.remove('rio-rectangle-ripple');
                        }
                    }
                    for (let [attrName, js_to_css] of Object.entries(
                        JS_TO_CSS_VALUE
                    )) {
                        let value = deltaState[attrName];
                        if (value !== void 0) {
                            element2.style.setProperty(
                                `--rio-rectangle-${attrName}`,
                                js_to_css(value)
                            );
                        }
                        let hoverValue = deltaState['hover_' + attrName];
                        if (hoverValue !== void 0) {
                            if (hoverValue === null) {
                                element2.style.setProperty(
                                    `--rio-rectangle-hover-${attrName}`,
                                    `var(--rio-rectangle-${attrName})`
                                );
                            } else {
                                element2.style.setProperty(
                                    `--rio-rectangle-hover-${attrName}`,
                                    js_to_css(hoverValue)
                                );
                            }
                        }
                    }
                }
                updateAllocatedHeight(ctx) {
                    super.updateAllocatedHeight(ctx);
                    if (this.mdcRipple !== null) {
                        requestAnimationFrame(() => {
                            if (this.mdcRipple !== null) {
                                this.mdcRipple.layout();
                            }
                        });
                    }
                }
            }
            function easeIn(t) {
                return Math.pow(t, 3);
            }
            function easeOut(t) {
                return 1 - easeIn(1 - t);
            }
            function easeInOut(t) {
                return t < 0.5
                    ? easeIn(t * 2) / 2
                    : easeOut(t * 2 - 1) / 2 + 0.5;
            }
            class LayoutContext {
                constructor() {
                    this._immediateReLayoutCallbacks = [];
                }
                updateRequestedWidthRecursive(component) {
                    if (!component.isLayoutDirty) return;
                    for (let child of component.children) {
                        this.updateRequestedWidthRecursive(child);
                    }
                    component.updateNaturalWidth(this);
                    component.requestedWidth = Math.max(
                        component.naturalWidth,
                        component.state._size_[0]
                    );
                }
                updateAllocatedWidthRecursive(component) {
                    if (!component.isLayoutDirty) return;
                    let children = Array.from(component.children);
                    let childAllocatedWidths = children.map(
                        (child) => child.allocatedWidth
                    );
                    component.updateAllocatedWidth(this);
                    for (let i = 0; i < children.length; i++) {
                        let child = children[i];
                        if (child.allocatedWidth !== childAllocatedWidths[i]) {
                            child.isLayoutDirty = true;
                        }
                        if (child.isLayoutDirty) {
                            this.updateAllocatedWidthRecursive(child);
                        }
                        let element2 = child.element;
                        element2.style.width = `${child.allocatedWidth * pixelsPerRem}px`;
                    }
                }
                updateRequestedHeightRecursive(component) {
                    if (!component.isLayoutDirty) return;
                    for (let child of component.children) {
                        this.updateRequestedHeightRecursive(child);
                    }
                    component.updateNaturalHeight(this);
                    component.requestedHeight = Math.max(
                        component.naturalHeight,
                        component.state._size_[1]
                    );
                }
                updateAllocatedHeightRecursive(component) {
                    if (!component.isLayoutDirty) return;
                    let children = Array.from(component.children);
                    let childAllocatedHeights = children.map(
                        (child) => child.allocatedHeight
                    );
                    component.updateAllocatedHeight(this);
                    for (let i = 0; i < children.length; i++) {
                        let child = children[i];
                        if (
                            child.allocatedHeight !== childAllocatedHeights[i]
                        ) {
                            child.isLayoutDirty = true;
                        }
                        if (child.isLayoutDirty) {
                            this.updateAllocatedHeightRecursive(child);
                        }
                        child.isLayoutDirty = false;
                        let element2 = child.element;
                        element2.style.height = `${child.allocatedHeight * pixelsPerRem}px`;
                    }
                }
                updateLayout() {
                    let rootComponent = getRootComponent();
                    this.updateRequestedWidthRecursive(rootComponent);
                    this.updateAllocatedWidthRecursive(rootComponent);
                    this.updateRequestedHeightRecursive(rootComponent);
                    this.updateAllocatedHeightRecursive(rootComponent);
                }
                /// Signal to the layout engine that it should re-layout the component tree
                /// immediately after the current layout cycle finishes. The given function
                /// will be called before the re-layout happens, allowing the caller to
                /// dirty components or do other things.
                requestImmediateReLayout(callback) {
                    this._immediateReLayoutCallbacks.push(callback);
                }
            }
            function updateLayout() {
                let context = new LayoutContext();
                while (true) {
                    context.updateLayout();
                    if (context._immediateReLayoutCallbacks.length === 0) {
                        break;
                    }
                    for (let callback of context._immediateReLayoutCallbacks) {
                        callback();
                    }
                    context._immediateReLayoutCallbacks = [];
                }
            }
            let HEADER_PADDING = 0.6;
            class RevealerComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.animationIsRunning = false;
                    this.openFractionBeforeEase = -1;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-revealer');
                    element2.innerHTML = `
            <div class="rio-revealer-header">
                <div class="rio-revealer-label"></div>
                <div class="rio-revealer-arrow"></div>
            </div>
            <div class="rio-revealer-content-outer">
                <div class="rio-revealer-content-inner"></div>
            </div>
`;
                    this.headerElement = element2.querySelector(
                        '.rio-revealer-header'
                    );
                    this.labelElement = this.headerElement.querySelector(
                        '.rio-revealer-label'
                    );
                    this.arrowElement = this.headerElement.querySelector(
                        '.rio-revealer-arrow'
                    );
                    this.contentInnerElement = element2.querySelector(
                        '.rio-revealer-content-inner'
                    );
                    this.contentOuterElement = element2.querySelector(
                        '.rio-revealer-content-outer'
                    );
                    applyIcon(
                        this.arrowElement,
                        'material/expand-more',
                        'currentColor'
                    );
                    this.headerElement.onclick = (e) => {
                        this.state.is_open = !this.state.is_open;
                        this.setStateAndNotifyBackend({
                            is_open: this.state.is_open,
                        });
                        if (this.state.is_open) {
                            element2.classList.add('rio-revealer-open');
                        } else {
                            element2.classList.remove('rio-revealer-open');
                        }
                        this.startAnimationIfNotRunning();
                    };
                    this.headerElement.onmouseenter = () => {
                        this.element.style.background =
                            'var(--rio-local-plain-bg-variant)';
                    };
                    this.headerElement.onmouseleave = () => {
                        this.element.style.removeProperty('background');
                    };
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.header === null) {
                        this.headerElement.style.display = 'none';
                    } else if (deltaState.header !== void 0) {
                        this.headerElement.style.removeProperty('display');
                        this.labelElement.textContent = deltaState.header;
                    }
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content,
                        this.contentInnerElement
                    );
                    if (deltaState.header_style !== void 0) {
                        Object.assign(
                            this.labelElement.style,
                            textStyleToCss(deltaState.header_style)
                        );
                        if (deltaState.header_style === 'heading1') {
                            this.headerScale = 2;
                        } else if (deltaState.header_style === 'heading2') {
                            this.headerScale = 1.5;
                        } else if (deltaState.header_style === 'heading3') {
                            this.headerScale = 1.2;
                        } else if (deltaState.header_style === 'text') {
                            this.headerScale = 1;
                        } else {
                            this.headerScale = deltaState.header_style.fontSize;
                        }
                        let cssPadding = `${HEADER_PADDING * this.headerScale}rem`;
                        this.headerElement.style.padding = cssPadding;
                        let arrowSize = this.headerScale * 1;
                        this.arrowElement.style.width = `${arrowSize}rem`;
                        this.arrowElement.style.height = `${arrowSize}rem`;
                        this.arrowElement.style.color =
                            this.labelElement.style.color;
                    }
                    if (deltaState.is_open !== void 0) {
                        if (this.openFractionBeforeEase === -1) {
                            this.openFractionBeforeEase = deltaState.is_open
                                ? 1
                                : 0;
                        } else {
                            this.state.is_open = deltaState.is_open;
                            this.startAnimationIfNotRunning();
                        }
                        if (this.state.is_open) {
                            this.element.classList.add('rio-revealer-open');
                        } else {
                            this.element.classList.remove('rio-revealer-open');
                        }
                    }
                    if (
                        deltaState.header !== void 0 ||
                        deltaState.header_style !== void 0
                    ) {
                        let headerText = firstDefined(
                            deltaState.header,
                            this.state.header
                        );
                        if (headerText !== null) {
                            let headerStyle = firstDefined(
                                deltaState.header_style,
                                this.state.header_style
                            );
                            [this.labelWidth, this.labelHeight] =
                                getTextDimensions(headerText, headerStyle);
                        }
                    }
                    this.makeLayoutDirty();
                }
                /// If the animation is not yet running, start it. Does nothing otherwise.
                /// This does not modify the state in any way.
                startAnimationIfNotRunning() {
                    if (this.animationIsRunning) {
                        return;
                    }
                    this.animationIsRunning = true;
                    this.lastAnimationTick = Date.now();
                    requestAnimationFrame(() => this.animationWorker());
                }
                animationWorker() {
                    let now = Date.now();
                    let timePassed = now - this.lastAnimationTick;
                    this.lastAnimationTick = now;
                    let direction = this.state.is_open ? 1 : -1;
                    this.openFractionBeforeEase =
                        this.openFractionBeforeEase +
                        (direction * timePassed) / 200;
                    this.openFractionBeforeEase = Math.max(
                        0,
                        Math.min(1, this.openFractionBeforeEase)
                    );
                    this.makeLayoutDirty();
                    updateLayout();
                    let target = this.state.is_open ? 1 : 0;
                    if (this.openFractionBeforeEase === target) {
                        this.animationIsRunning = false;
                    } else {
                        requestAnimationFrame(() => this.animationWorker());
                    }
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth =
                        componentsById[this.state.content].requestedWidth;
                    if (this.state.header !== null) {
                        let headerWidth =
                            this.labelWidth +
                            4 +
                            2 * HEADER_PADDING * this.headerScale;
                        this.naturalWidth = Math.max(
                            this.naturalWidth,
                            headerWidth
                        );
                    }
                }
                updateAllocatedWidth(ctx) {
                    if (this.openFractionBeforeEase > 0) {
                        componentsById[this.state.content].allocatedWidth =
                            this.allocatedWidth;
                    }
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 0;
                    if (this.state.header !== null) {
                        this.naturalHeight +=
                            this.labelHeight +
                            2 * HEADER_PADDING * this.headerScale;
                    }
                    if (this.openFractionBeforeEase > 0) {
                        let t = easeInOut(this.openFractionBeforeEase);
                        let innerHeight =
                            componentsById[this.state.content].requestedHeight;
                        this.naturalHeight += t * innerHeight;
                    }
                }
                updateAllocatedHeight(ctx) {
                    if (this.openFractionBeforeEase === 0) {
                        return;
                    }
                    let headerHeight =
                        this.state.header === null
                            ? 0
                            : this.labelHeight +
                              2 * HEADER_PADDING * this.headerScale;
                    let child = componentsById[this.state.content];
                    child.allocatedHeight = Math.max(
                        this.allocatedHeight - headerHeight,
                        componentsById[this.state.content].requestedHeight
                    );
                    let element2 = child.element;
                    element2.style.left = '0';
                    element2.style.top = '0';
                }
            }
            const NATURAL_SIZE = 1;
            class ScrollContainerComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.isFirstLayout = true;
                    this.assumeVerticalScrollBarWillBeNeeded = true;
                    this.numSequentialIncorrectAssumptions = 0;
                    this.wasScrolledToBottom = null;
                }
                shouldLayoutWithVerticalScrollbar() {
                    switch (this.state.scroll_y) {
                        case 'always':
                            return true;
                        case 'auto':
                            return this.assumeVerticalScrollBarWillBeNeeded;
                        case 'never':
                            return false;
                    }
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-scroll-container');
                    this.childContainer = document.createElement('div');
                    element2.appendChild(this.childContainer);
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content,
                        this.childContainer
                    );
                }
                updateNaturalWidth(ctx) {
                    if (this.state.scroll_x === 'never') {
                        let child = componentsById[this.state.content];
                        this.naturalWidth = child.requestedWidth;
                    } else {
                        this.naturalWidth = NATURAL_SIZE;
                    }
                    if (this.shouldLayoutWithVerticalScrollbar()) {
                        this.naturalWidth += scrollBarSize;
                    }
                }
                updateAllocatedWidth(ctx) {
                    let child = componentsById[this.state.content];
                    if (
                        this.state.sticky_bottom &&
                        this.numSequentialIncorrectAssumptions === 0
                    ) {
                        this.wasScrolledToBottom =
                            this._checkIfScrolledToBottom(child);
                    }
                    let availableWidth = this.allocatedWidth;
                    if (this.shouldLayoutWithVerticalScrollbar()) {
                        availableWidth -= scrollBarSize;
                    }
                    if (child.requestedWidth > availableWidth) {
                        child.allocatedWidth = child.requestedWidth;
                        this.element.style.overflowX = 'scroll';
                    } else {
                        child.allocatedWidth = availableWidth;
                        this.element.style.overflowX =
                            this.state.scroll_x === 'always'
                                ? 'scroll'
                                : 'hidden';
                    }
                    this.childContainer.style.width = `${child.allocatedWidth}rem`;
                }
                updateNaturalHeight(ctx) {
                    if (this.state.scroll_y === 'never') {
                        let child = componentsById[this.state.content];
                        this.naturalHeight = child.requestedHeight;
                    } else {
                        this.naturalHeight = NATURAL_SIZE;
                    }
                    if (this.element.style.overflowX === 'scroll') {
                        this.naturalHeight += scrollBarSize;
                    }
                }
                updateAllocatedHeight(ctx) {
                    let child = componentsById[this.state.content];
                    let availableHeight = this.allocatedHeight;
                    if (this.element.style.overflowX === 'scroll') {
                        availableHeight -= scrollBarSize;
                    }
                    let newAllocatedHeight;
                    if (child.requestedHeight > availableHeight) {
                        newAllocatedHeight = child.requestedHeight;
                        this.element.style.overflowY = 'scroll';
                    } else {
                        newAllocatedHeight = availableHeight;
                        if (this.state.scroll_y === 'always') {
                            this.element.style.overflowY = 'scroll';
                        } else {
                            this.element.style.overflowY = 'hidden';
                        }
                    }
                    let hasVerticalScrollbar =
                        this.element.style.overflowY === 'scroll';
                    if (
                        this.state.scroll_y === 'auto' &&
                        this.assumeVerticalScrollBarWillBeNeeded !==
                            hasVerticalScrollbar
                    ) {
                        if (
                            this.numSequentialIncorrectAssumptions == 0 ||
                            !this.assumeVerticalScrollBarWillBeNeeded
                        ) {
                            this.numSequentialIncorrectAssumptions++;
                            this.assumeVerticalScrollBarWillBeNeeded =
                                !this.assumeVerticalScrollBarWillBeNeeded;
                            child.allocatedHeight = 7.77777777;
                            ctx.requestImmediateReLayout(() => {
                                this.makeLayoutDirty();
                            });
                            return;
                        }
                    }
                    this.numSequentialIncorrectAssumptions = 0;
                    child.allocatedHeight = newAllocatedHeight;
                    this.childContainer.style.height = `${child.allocatedHeight}rem`;
                    if (this.isFirstLayout) {
                        this.isFirstLayout = false;
                        this.element.style.height = `${this.allocatedHeight}rem`;
                        this.element.scroll({
                            top:
                                (child.allocatedHeight - this.allocatedHeight) *
                                pixelsPerRem *
                                this.state.initial_y,
                            left:
                                (child.allocatedWidth - this.allocatedWidth) *
                                pixelsPerRem *
                                this.state.initial_y,
                            behavior: 'instant',
                        });
                    } else if (
                        this.state.sticky_bottom &&
                        this.wasScrolledToBottom
                    ) {
                        this.element.style.height = `${this.allocatedHeight}rem`;
                        this.element.scroll({
                            top: child.allocatedHeight * pixelsPerRem + 999,
                            left: this.element.scrollLeft,
                            behavior: 'instant',
                        });
                    }
                }
                _checkIfScrolledToBottom(child) {
                    let visibleHeight = this.allocatedHeight;
                    if (this.element.style.overflowX === 'scroll') {
                        visibleHeight -= scrollBarSize;
                    }
                    return (
                        (this.element.scrollTop + 1) / pixelsPerRem +
                            visibleHeight >=
                        child.allocatedHeight - 1e-5
                    );
                }
            }
            class ScrollTargetComponent extends SingleContainer {
                createElement() {
                    return document.createElement('a');
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                    if (deltaState.id !== void 0) {
                        this.element.id = deltaState.id;
                    }
                }
            }
            class SeparatorComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-separator');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.color === void 0);
                    else if (deltaState.color === null) {
                        this.element.style.setProperty(
                            '--separator-color',
                            'var(--rio-local-text-color)'
                        );
                        this.element.style.setProperty(
                            '--separator-opacity',
                            '0.3'
                        );
                    } else {
                        this.element.style.setProperty(
                            '--separator-color',
                            colorToCssString(deltaState.color)
                        );
                        this.element.style.setProperty(
                            '--separator-opacity',
                            '1'
                        );
                    }
                    if (deltaState.orientation !== void 0) {
                        this.makeLayoutDirty();
                    }
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 1 / pixelsPerRem;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 1 / pixelsPerRem;
                }
            }
            /**
             * @license
             * Copyright 2020 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var cssClasses = {
                DISABLED: 'mdc-slider--disabled',
                DISCRETE: 'mdc-slider--discrete',
                INPUT: 'mdc-slider__input',
                RANGE: 'mdc-slider--range',
                THUMB: 'mdc-slider__thumb',
                // Applied when thumb is in the focused state.
                THUMB_FOCUSED: 'mdc-slider__thumb--focused',
                THUMB_KNOB: 'mdc-slider__thumb-knob',
                // Class added to the top thumb (for overlapping thumbs in range slider).
                THUMB_TOP: 'mdc-slider__thumb--top',
                THUMB_WITH_INDICATOR: 'mdc-slider__thumb--with-indicator',
                TICK_MARKS: 'mdc-slider--tick-marks',
                TICK_MARKS_CONTAINER: 'mdc-slider__tick-marks',
                TICK_MARK_ACTIVE: 'mdc-slider__tick-mark--active',
                TICK_MARK_INACTIVE: 'mdc-slider__tick-mark--inactive',
                TRACK: 'mdc-slider__track',
                // The active track fill element that will be scaled as the value changes.
                TRACK_ACTIVE: 'mdc-slider__track--active_fill',
                VALUE_INDICATOR_CONTAINER:
                    'mdc-slider__value-indicator-container',
                VALUE_INDICATOR_TEXT: 'mdc-slider__value-indicator-text',
            };
            var numbers = {
                // Default step size.
                STEP_SIZE: 1,
                // Default minimum difference between the start and end values.
                MIN_RANGE: 0,
                // Minimum absolute difference between clientX of move event / down event
                // for which to update thumb, in the case of overlapping thumbs.
                // This is needed to reduce chances of choosing the thumb based on
                // pointer jitter.
                THUMB_UPDATE_MIN_PX: 5,
            };
            var attributes = {
                ARIA_VALUETEXT: 'aria-valuetext',
                INPUT_DISABLED: 'disabled',
                INPUT_MIN: 'min',
                INPUT_MAX: 'max',
                INPUT_VALUE: 'value',
                INPUT_STEP: 'step',
                DATA_MIN_RANGE: 'data-min-range',
            };
            var events = {
                CHANGE: 'MDCSlider:change',
                INPUT: 'MDCSlider:input',
            };
            var strings = {
                VAR_VALUE_INDICATOR_CARET_LEFT:
                    '--slider-value-indicator-caret-left',
                VAR_VALUE_INDICATOR_CARET_RIGHT:
                    '--slider-value-indicator-caret-right',
                VAR_VALUE_INDICATOR_CARET_TRANSFORM:
                    '--slider-value-indicator-caret-transform',
                VAR_VALUE_INDICATOR_CONTAINER_LEFT:
                    '--slider-value-indicator-container-left',
                VAR_VALUE_INDICATOR_CONTAINER_RIGHT:
                    '--slider-value-indicator-container-right',
                VAR_VALUE_INDICATOR_CONTAINER_TRANSFORM:
                    '--slider-value-indicator-container-transform',
            };
            /**
             * @license
             * Copyright 2020 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var AnimationFrame =
                /** @class */
                (function () {
                    function AnimationFrame2() {
                        this.rafIDs = /* @__PURE__ */ new Map();
                    }
                    AnimationFrame2.prototype.request = function (
                        key,
                        callback
                    ) {
                        var _this = this;
                        this.cancel(key);
                        var frameID = requestAnimationFrame(function (frame) {
                            _this.rafIDs.delete(key);
                            callback(frame);
                        });
                        this.rafIDs.set(key, frameID);
                    };
                    AnimationFrame2.prototype.cancel = function (key) {
                        var rafID = this.rafIDs.get(key);
                        if (rafID) {
                            cancelAnimationFrame(rafID);
                            this.rafIDs.delete(key);
                        }
                    };
                    AnimationFrame2.prototype.cancelAll = function () {
                        var _this = this;
                        this.rafIDs.forEach(function (_, key) {
                            _this.cancel(key);
                        });
                    };
                    AnimationFrame2.prototype.getQueue = function () {
                        var queue = [];
                        this.rafIDs.forEach(function (_, key) {
                            queue.push(key);
                        });
                        return queue;
                    };
                    return AnimationFrame2;
                })();
            /**
             * @license
             * Copyright 2020 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var TickMark;
            (function (TickMark2) {
                TickMark2[(TickMark2['ACTIVE'] = 0)] = 'ACTIVE';
                TickMark2[(TickMark2['INACTIVE'] = 1)] = 'INACTIVE';
            })(TickMark || (TickMark = {}));
            var Thumb;
            (function (Thumb2) {
                Thumb2[(Thumb2['START'] = 1)] = 'START';
                Thumb2[(Thumb2['END'] = 2)] = 'END';
            })(Thumb || (Thumb = {}));
            /**
             * @license
             * Copyright 2020 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var AnimationKeys;
            (function (AnimationKeys2) {
                AnimationKeys2['SLIDER_UPDATE'] = 'slider_update';
            })(AnimationKeys || (AnimationKeys = {}));
            var HAS_WINDOW = typeof window !== 'undefined';
            var MDCSliderFoundation =
                /** @class */
                (function (_super) {
                    __extends(MDCSliderFoundation2, _super);
                    function MDCSliderFoundation2(adapter) {
                        var _this =
                            _super.call(
                                this,
                                __assign(
                                    __assign(
                                        {},
                                        MDCSliderFoundation2.defaultAdapter
                                    ),
                                    adapter
                                )
                            ) || this;
                        _this.initialStylesRemoved = false;
                        _this.isDisabled = false;
                        _this.isDiscrete = false;
                        _this.step = numbers.STEP_SIZE;
                        _this.minRange = numbers.MIN_RANGE;
                        _this.hasTickMarks = false;
                        _this.isRange = false;
                        _this.thumb = null;
                        _this.downEventClientX = null;
                        _this.startThumbKnobWidth = 0;
                        _this.endThumbKnobWidth = 0;
                        _this.animFrame = new AnimationFrame();
                        return _this;
                    }
                    Object.defineProperty(
                        MDCSliderFoundation2,
                        'defaultAdapter',
                        {
                            get: function () {
                                return {
                                    hasClass: function () {
                                        return false;
                                    },
                                    addClass: function () {
                                        return void 0;
                                    },
                                    removeClass: function () {
                                        return void 0;
                                    },
                                    addThumbClass: function () {
                                        return void 0;
                                    },
                                    removeThumbClass: function () {
                                        return void 0;
                                    },
                                    getAttribute: function () {
                                        return null;
                                    },
                                    getInputValue: function () {
                                        return '';
                                    },
                                    setInputValue: function () {
                                        return void 0;
                                    },
                                    getInputAttribute: function () {
                                        return null;
                                    },
                                    setInputAttribute: function () {
                                        return null;
                                    },
                                    removeInputAttribute: function () {
                                        return null;
                                    },
                                    focusInput: function () {
                                        return void 0;
                                    },
                                    isInputFocused: function () {
                                        return false;
                                    },
                                    shouldHideFocusStylesForPointerEvents:
                                        function () {
                                            return false;
                                        },
                                    getThumbKnobWidth: function () {
                                        return 0;
                                    },
                                    getValueIndicatorContainerWidth:
                                        function () {
                                            return 0;
                                        },
                                    getThumbBoundingClientRect: function () {
                                        return {
                                            top: 0,
                                            right: 0,
                                            bottom: 0,
                                            left: 0,
                                            width: 0,
                                            height: 0,
                                        };
                                    },
                                    getBoundingClientRect: function () {
                                        return {
                                            top: 0,
                                            right: 0,
                                            bottom: 0,
                                            left: 0,
                                            width: 0,
                                            height: 0,
                                        };
                                    },
                                    isRTL: function () {
                                        return false;
                                    },
                                    setThumbStyleProperty: function () {
                                        return void 0;
                                    },
                                    removeThumbStyleProperty: function () {
                                        return void 0;
                                    },
                                    setTrackActiveStyleProperty: function () {
                                        return void 0;
                                    },
                                    removeTrackActiveStyleProperty:
                                        function () {
                                            return void 0;
                                        },
                                    setValueIndicatorText: function () {
                                        return void 0;
                                    },
                                    getValueToAriaValueTextFn: function () {
                                        return null;
                                    },
                                    updateTickMarks: function () {
                                        return void 0;
                                    },
                                    setPointerCapture: function () {
                                        return void 0;
                                    },
                                    emitChangeEvent: function () {
                                        return void 0;
                                    },
                                    emitInputEvent: function () {
                                        return void 0;
                                    },
                                    emitDragStartEvent: function () {
                                        return void 0;
                                    },
                                    emitDragEndEvent: function () {
                                        return void 0;
                                    },
                                    registerEventHandler: function () {
                                        return void 0;
                                    },
                                    deregisterEventHandler: function () {
                                        return void 0;
                                    },
                                    registerThumbEventHandler: function () {
                                        return void 0;
                                    },
                                    deregisterThumbEventHandler: function () {
                                        return void 0;
                                    },
                                    registerInputEventHandler: function () {
                                        return void 0;
                                    },
                                    deregisterInputEventHandler: function () {
                                        return void 0;
                                    },
                                    registerBodyEventHandler: function () {
                                        return void 0;
                                    },
                                    deregisterBodyEventHandler: function () {
                                        return void 0;
                                    },
                                    registerWindowEventHandler: function () {
                                        return void 0;
                                    },
                                    deregisterWindowEventHandler: function () {
                                        return void 0;
                                    },
                                };
                            },
                            enumerable: false,
                            configurable: true,
                        }
                    );
                    MDCSliderFoundation2.prototype.init = function () {
                        var _this = this;
                        this.isDisabled = this.adapter.hasClass(
                            cssClasses.DISABLED
                        );
                        this.isDiscrete = this.adapter.hasClass(
                            cssClasses.DISCRETE
                        );
                        this.hasTickMarks = this.adapter.hasClass(
                            cssClasses.TICK_MARKS
                        );
                        this.isRange = this.adapter.hasClass(cssClasses.RANGE);
                        var min = this.convertAttributeValueToNumber(
                            this.adapter.getInputAttribute(
                                attributes.INPUT_MIN,
                                this.isRange ? Thumb.START : Thumb.END
                            ),
                            attributes.INPUT_MIN
                        );
                        var max = this.convertAttributeValueToNumber(
                            this.adapter.getInputAttribute(
                                attributes.INPUT_MAX,
                                Thumb.END
                            ),
                            attributes.INPUT_MAX
                        );
                        var value = this.convertAttributeValueToNumber(
                            this.adapter.getInputAttribute(
                                attributes.INPUT_VALUE,
                                Thumb.END
                            ),
                            attributes.INPUT_VALUE
                        );
                        var valueStart = this.isRange
                            ? this.convertAttributeValueToNumber(
                                  this.adapter.getInputAttribute(
                                      attributes.INPUT_VALUE,
                                      Thumb.START
                                  ),
                                  attributes.INPUT_VALUE
                              )
                            : min;
                        var stepAttr = this.adapter.getInputAttribute(
                            attributes.INPUT_STEP,
                            Thumb.END
                        );
                        var step = stepAttr
                            ? this.convertAttributeValueToNumber(
                                  stepAttr,
                                  attributes.INPUT_STEP
                              )
                            : this.step;
                        var minRangeAttr = this.adapter.getAttribute(
                            attributes.DATA_MIN_RANGE
                        );
                        var minRange = minRangeAttr
                            ? this.convertAttributeValueToNumber(
                                  minRangeAttr,
                                  attributes.DATA_MIN_RANGE
                              )
                            : this.minRange;
                        this.validateProperties({
                            min,
                            max,
                            value,
                            valueStart,
                            step,
                            minRange,
                        });
                        this.min = min;
                        this.max = max;
                        this.value = value;
                        this.valueStart = valueStart;
                        this.step = step;
                        this.minRange = minRange;
                        this.numDecimalPlaces = getNumDecimalPlaces(this.step);
                        this.valueBeforeDownEvent = value;
                        this.valueStartBeforeDownEvent = valueStart;
                        this.mousedownOrTouchstartListener =
                            this.handleMousedownOrTouchstart.bind(this);
                        this.moveListener = this.handleMove.bind(this);
                        this.pointerdownListener =
                            this.handlePointerdown.bind(this);
                        this.pointerupListener =
                            this.handlePointerup.bind(this);
                        this.thumbMouseenterListener =
                            this.handleThumbMouseenter.bind(this);
                        this.thumbMouseleaveListener =
                            this.handleThumbMouseleave.bind(this);
                        this.inputStartChangeListener = function () {
                            _this.handleInputChange(Thumb.START);
                        };
                        this.inputEndChangeListener = function () {
                            _this.handleInputChange(Thumb.END);
                        };
                        this.inputStartFocusListener = function () {
                            _this.handleInputFocus(Thumb.START);
                        };
                        this.inputEndFocusListener = function () {
                            _this.handleInputFocus(Thumb.END);
                        };
                        this.inputStartBlurListener = function () {
                            _this.handleInputBlur(Thumb.START);
                        };
                        this.inputEndBlurListener = function () {
                            _this.handleInputBlur(Thumb.END);
                        };
                        this.resizeListener = this.handleResize.bind(this);
                        this.registerEventHandlers();
                    };
                    MDCSliderFoundation2.prototype.destroy = function () {
                        this.deregisterEventHandlers();
                    };
                    MDCSliderFoundation2.prototype.setMin = function (value) {
                        this.min = value;
                        if (!this.isRange) {
                            this.valueStart = value;
                        }
                        this.updateUI();
                    };
                    MDCSliderFoundation2.prototype.setMax = function (value) {
                        this.max = value;
                        this.updateUI();
                    };
                    MDCSliderFoundation2.prototype.getMin = function () {
                        return this.min;
                    };
                    MDCSliderFoundation2.prototype.getMax = function () {
                        return this.max;
                    };
                    MDCSliderFoundation2.prototype.getValue = function () {
                        return this.value;
                    };
                    MDCSliderFoundation2.prototype.setValue = function (value) {
                        if (
                            this.isRange &&
                            value < this.valueStart + this.minRange
                        ) {
                            throw new Error(
                                'end thumb value (' +
                                    value +
                                    ') must be >= start thumb ' +
                                    ('value (' +
                                        this.valueStart +
                                        ') + min range (' +
                                        this.minRange +
                                        ')')
                            );
                        }
                        this.updateValue(value, Thumb.END);
                    };
                    MDCSliderFoundation2.prototype.getValueStart = function () {
                        if (!this.isRange) {
                            throw new Error(
                                '`valueStart` is only applicable for range sliders.'
                            );
                        }
                        return this.valueStart;
                    };
                    MDCSliderFoundation2.prototype.setValueStart = function (
                        valueStart
                    ) {
                        if (!this.isRange) {
                            throw new Error(
                                '`valueStart` is only applicable for range sliders.'
                            );
                        }
                        if (
                            this.isRange &&
                            valueStart > this.value - this.minRange
                        ) {
                            throw new Error(
                                'start thumb value (' +
                                    valueStart +
                                    ') must be <= end thumb ' +
                                    ('value (' +
                                        this.value +
                                        ') - min range (' +
                                        this.minRange +
                                        ')')
                            );
                        }
                        this.updateValue(valueStart, Thumb.START);
                    };
                    MDCSliderFoundation2.prototype.setStep = function (value) {
                        this.step = value;
                        this.numDecimalPlaces = getNumDecimalPlaces(value);
                        this.updateUI();
                    };
                    MDCSliderFoundation2.prototype.setMinRange = function (
                        value
                    ) {
                        if (!this.isRange) {
                            throw new Error(
                                '`minRange` is only applicable for range sliders.'
                            );
                        }
                        if (value < 0) {
                            throw new Error(
                                '`minRange` must be non-negative. ' +
                                    ('Current value: ' + value)
                            );
                        }
                        if (this.value - this.valueStart < value) {
                            throw new Error(
                                'start thumb value (' +
                                    this.valueStart +
                                    ') and end thumb value ' +
                                    ('(' +
                                        this.value +
                                        ') must differ by at least ' +
                                        value +
                                        '.')
                            );
                        }
                        this.minRange = value;
                    };
                    MDCSliderFoundation2.prototype.setIsDiscrete = function (
                        value
                    ) {
                        this.isDiscrete = value;
                        this.updateValueIndicatorUI();
                        this.updateTickMarksUI();
                    };
                    MDCSliderFoundation2.prototype.getStep = function () {
                        return this.step;
                    };
                    MDCSliderFoundation2.prototype.getMinRange = function () {
                        if (!this.isRange) {
                            throw new Error(
                                '`minRange` is only applicable for range sliders.'
                            );
                        }
                        return this.minRange;
                    };
                    MDCSliderFoundation2.prototype.setHasTickMarks = function (
                        value
                    ) {
                        this.hasTickMarks = value;
                        this.updateTickMarksUI();
                    };
                    MDCSliderFoundation2.prototype.getDisabled = function () {
                        return this.isDisabled;
                    };
                    MDCSliderFoundation2.prototype.setDisabled = function (
                        disabled
                    ) {
                        this.isDisabled = disabled;
                        if (disabled) {
                            this.adapter.addClass(cssClasses.DISABLED);
                            if (this.isRange) {
                                this.adapter.setInputAttribute(
                                    attributes.INPUT_DISABLED,
                                    '',
                                    Thumb.START
                                );
                            }
                            this.adapter.setInputAttribute(
                                attributes.INPUT_DISABLED,
                                '',
                                Thumb.END
                            );
                        } else {
                            this.adapter.removeClass(cssClasses.DISABLED);
                            if (this.isRange) {
                                this.adapter.removeInputAttribute(
                                    attributes.INPUT_DISABLED,
                                    Thumb.START
                                );
                            }
                            this.adapter.removeInputAttribute(
                                attributes.INPUT_DISABLED,
                                Thumb.END
                            );
                        }
                    };
                    MDCSliderFoundation2.prototype.getIsRange = function () {
                        return this.isRange;
                    };
                    MDCSliderFoundation2.prototype.layout = function (_a) {
                        var _b = _a === void 0 ? {} : _a,
                            skipUpdateUI = _b.skipUpdateUI;
                        this.rect = this.adapter.getBoundingClientRect();
                        if (this.isRange) {
                            this.startThumbKnobWidth =
                                this.adapter.getThumbKnobWidth(Thumb.START);
                            this.endThumbKnobWidth =
                                this.adapter.getThumbKnobWidth(Thumb.END);
                        }
                        if (!skipUpdateUI) {
                            this.updateUI();
                        }
                    };
                    MDCSliderFoundation2.prototype.handleResize = function () {
                        this.layout();
                    };
                    MDCSliderFoundation2.prototype.handleDown = function (
                        event
                    ) {
                        if (this.isDisabled) return;
                        this.valueStartBeforeDownEvent = this.valueStart;
                        this.valueBeforeDownEvent = this.value;
                        var clientX =
                            event.clientX != null
                                ? event.clientX
                                : event.targetTouches[0].clientX;
                        this.downEventClientX = clientX;
                        var value = this.mapClientXOnSliderScale(clientX);
                        this.thumb = this.getThumbFromDownEvent(clientX, value);
                        if (this.thumb === null) return;
                        this.handleDragStart(event, value, this.thumb);
                        this.updateValue(value, this.thumb, {
                            emitInputEvent: true,
                        });
                    };
                    MDCSliderFoundation2.prototype.handleMove = function (
                        event
                    ) {
                        if (this.isDisabled) return;
                        event.preventDefault();
                        var clientX =
                            event.clientX != null
                                ? event.clientX
                                : event.targetTouches[0].clientX;
                        var dragAlreadyStarted = this.thumb != null;
                        this.thumb = this.getThumbFromMoveEvent(clientX);
                        if (this.thumb === null) return;
                        var value = this.mapClientXOnSliderScale(clientX);
                        if (!dragAlreadyStarted) {
                            this.handleDragStart(event, value, this.thumb);
                            this.adapter.emitDragStartEvent(value, this.thumb);
                        }
                        this.updateValue(value, this.thumb, {
                            emitInputEvent: true,
                        });
                    };
                    MDCSliderFoundation2.prototype.handleUp = function () {
                        var _a, _b;
                        if (this.isDisabled || this.thumb === null) return;
                        if (
                            (_b = (_a = this.adapter)
                                .shouldHideFocusStylesForPointerEvents) ===
                                null || _b === void 0
                                ? void 0
                                : _b.call(_a)
                        ) {
                            this.handleInputBlur(this.thumb);
                        }
                        var oldValue =
                            this.thumb === Thumb.START
                                ? this.valueStartBeforeDownEvent
                                : this.valueBeforeDownEvent;
                        var newValue =
                            this.thumb === Thumb.START
                                ? this.valueStart
                                : this.value;
                        if (oldValue !== newValue) {
                            this.adapter.emitChangeEvent(newValue, this.thumb);
                        }
                        this.adapter.emitDragEndEvent(newValue, this.thumb);
                        this.thumb = null;
                    };
                    MDCSliderFoundation2.prototype.handleThumbMouseenter =
                        function () {
                            if (!this.isDiscrete || !this.isRange) return;
                            this.adapter.addThumbClass(
                                cssClasses.THUMB_WITH_INDICATOR,
                                Thumb.START
                            );
                            this.adapter.addThumbClass(
                                cssClasses.THUMB_WITH_INDICATOR,
                                Thumb.END
                            );
                        };
                    MDCSliderFoundation2.prototype.handleThumbMouseleave =
                        function () {
                            var _a, _b;
                            if (!this.isDiscrete || !this.isRange) return;
                            if (
                                (!((_b = (_a = this.adapter)
                                    .shouldHideFocusStylesForPointerEvents) ===
                                    null || _b === void 0
                                    ? void 0
                                    : _b.call(_a)) &&
                                    (this.adapter.isInputFocused(Thumb.START) ||
                                        this.adapter.isInputFocused(
                                            Thumb.END
                                        ))) ||
                                this.thumb
                            ) {
                                return;
                            }
                            this.adapter.removeThumbClass(
                                cssClasses.THUMB_WITH_INDICATOR,
                                Thumb.START
                            );
                            this.adapter.removeThumbClass(
                                cssClasses.THUMB_WITH_INDICATOR,
                                Thumb.END
                            );
                        };
                    MDCSliderFoundation2.prototype.handleMousedownOrTouchstart =
                        function (event) {
                            var _this = this;
                            var moveEventType =
                                event.type === 'mousedown'
                                    ? 'mousemove'
                                    : 'touchmove';
                            this.adapter.registerBodyEventHandler(
                                moveEventType,
                                this.moveListener
                            );
                            var upHandler = function () {
                                _this.handleUp();
                                _this.adapter.deregisterBodyEventHandler(
                                    moveEventType,
                                    _this.moveListener
                                );
                                _this.adapter.deregisterEventHandler(
                                    'mouseup',
                                    upHandler
                                );
                                _this.adapter.deregisterEventHandler(
                                    'touchend',
                                    upHandler
                                );
                            };
                            this.adapter.registerBodyEventHandler(
                                'mouseup',
                                upHandler
                            );
                            this.adapter.registerBodyEventHandler(
                                'touchend',
                                upHandler
                            );
                            this.handleDown(event);
                        };
                    MDCSliderFoundation2.prototype.handlePointerdown =
                        function (event) {
                            var isPrimaryButton = event.button === 0;
                            if (!isPrimaryButton) return;
                            if (event.pointerId != null) {
                                this.adapter.setPointerCapture(event.pointerId);
                            }
                            this.adapter.registerEventHandler(
                                'pointermove',
                                this.moveListener
                            );
                            this.handleDown(event);
                        };
                    MDCSliderFoundation2.prototype.handleInputChange =
                        function (thumb) {
                            var value = Number(
                                this.adapter.getInputValue(thumb)
                            );
                            if (thumb === Thumb.START) {
                                this.setValueStart(value);
                            } else {
                                this.setValue(value);
                            }
                            this.adapter.emitChangeEvent(
                                thumb === Thumb.START
                                    ? this.valueStart
                                    : this.value,
                                thumb
                            );
                            this.adapter.emitInputEvent(
                                thumb === Thumb.START
                                    ? this.valueStart
                                    : this.value,
                                thumb
                            );
                        };
                    MDCSliderFoundation2.prototype.handleInputFocus = function (
                        thumb
                    ) {
                        this.adapter.addThumbClass(
                            cssClasses.THUMB_FOCUSED,
                            thumb
                        );
                        if (!this.isDiscrete) return;
                        this.adapter.addThumbClass(
                            cssClasses.THUMB_WITH_INDICATOR,
                            thumb
                        );
                        if (this.isRange) {
                            var otherThumb =
                                thumb === Thumb.START ? Thumb.END : Thumb.START;
                            this.adapter.addThumbClass(
                                cssClasses.THUMB_WITH_INDICATOR,
                                otherThumb
                            );
                        }
                    };
                    MDCSliderFoundation2.prototype.handleInputBlur = function (
                        thumb
                    ) {
                        this.adapter.removeThumbClass(
                            cssClasses.THUMB_FOCUSED,
                            thumb
                        );
                        if (!this.isDiscrete) return;
                        this.adapter.removeThumbClass(
                            cssClasses.THUMB_WITH_INDICATOR,
                            thumb
                        );
                        if (this.isRange) {
                            var otherThumb =
                                thumb === Thumb.START ? Thumb.END : Thumb.START;
                            this.adapter.removeThumbClass(
                                cssClasses.THUMB_WITH_INDICATOR,
                                otherThumb
                            );
                        }
                    };
                    MDCSliderFoundation2.prototype.handleDragStart = function (
                        event,
                        value,
                        thumb
                    ) {
                        var _a, _b;
                        this.adapter.emitDragStartEvent(value, thumb);
                        this.adapter.focusInput(thumb);
                        if (
                            (_b = (_a = this.adapter)
                                .shouldHideFocusStylesForPointerEvents) ===
                                null || _b === void 0
                                ? void 0
                                : _b.call(_a)
                        ) {
                            this.handleInputFocus(thumb);
                        }
                        event.preventDefault();
                    };
                    MDCSliderFoundation2.prototype.getThumbFromDownEvent =
                        function (clientX, value) {
                            if (!this.isRange) return Thumb.END;
                            var thumbStartRect =
                                this.adapter.getThumbBoundingClientRect(
                                    Thumb.START
                                );
                            var thumbEndRect =
                                this.adapter.getThumbBoundingClientRect(
                                    Thumb.END
                                );
                            var inThumbStartBounds =
                                clientX >= thumbStartRect.left &&
                                clientX <= thumbStartRect.right;
                            var inThumbEndBounds =
                                clientX >= thumbEndRect.left &&
                                clientX <= thumbEndRect.right;
                            if (inThumbStartBounds && inThumbEndBounds) {
                                return null;
                            }
                            if (inThumbStartBounds) {
                                return Thumb.START;
                            }
                            if (inThumbEndBounds) {
                                return Thumb.END;
                            }
                            if (value < this.valueStart) {
                                return Thumb.START;
                            }
                            if (value > this.value) {
                                return Thumb.END;
                            }
                            return value - this.valueStart <= this.value - value
                                ? Thumb.START
                                : Thumb.END;
                        };
                    MDCSliderFoundation2.prototype.getThumbFromMoveEvent =
                        function (clientX) {
                            if (this.thumb !== null) return this.thumb;
                            if (this.downEventClientX === null) {
                                throw new Error(
                                    '`downEventClientX` is null after move event.'
                                );
                            }
                            var moveDistanceUnderThreshold =
                                Math.abs(this.downEventClientX - clientX) <
                                numbers.THUMB_UPDATE_MIN_PX;
                            if (moveDistanceUnderThreshold) return this.thumb;
                            var draggedThumbToLeft =
                                clientX < this.downEventClientX;
                            if (draggedThumbToLeft) {
                                return this.adapter.isRTL()
                                    ? Thumb.END
                                    : Thumb.START;
                            } else {
                                return this.adapter.isRTL()
                                    ? Thumb.START
                                    : Thumb.END;
                            }
                        };
                    MDCSliderFoundation2.prototype.updateUI = function (thumb) {
                        if (thumb) {
                            this.updateThumbAndInputAttributes(thumb);
                        } else {
                            this.updateThumbAndInputAttributes(Thumb.START);
                            this.updateThumbAndInputAttributes(Thumb.END);
                        }
                        this.updateThumbAndTrackUI(thumb);
                        this.updateValueIndicatorUI(thumb);
                        this.updateTickMarksUI();
                    };
                    MDCSliderFoundation2.prototype.updateThumbAndInputAttributes =
                        function (thumb) {
                            if (!thumb) return;
                            var value =
                                this.isRange && thumb === Thumb.START
                                    ? this.valueStart
                                    : this.value;
                            var valueStr = String(value);
                            this.adapter.setInputAttribute(
                                attributes.INPUT_VALUE,
                                valueStr,
                                thumb
                            );
                            if (this.isRange && thumb === Thumb.START) {
                                this.adapter.setInputAttribute(
                                    attributes.INPUT_MIN,
                                    String(value + this.minRange),
                                    Thumb.END
                                );
                            } else if (this.isRange && thumb === Thumb.END) {
                                this.adapter.setInputAttribute(
                                    attributes.INPUT_MAX,
                                    String(value - this.minRange),
                                    Thumb.START
                                );
                            }
                            if (
                                this.adapter.getInputValue(thumb) !== valueStr
                            ) {
                                this.adapter.setInputValue(valueStr, thumb);
                            }
                            var valueToAriaValueTextFn =
                                this.adapter.getValueToAriaValueTextFn();
                            if (valueToAriaValueTextFn) {
                                this.adapter.setInputAttribute(
                                    attributes.ARIA_VALUETEXT,
                                    valueToAriaValueTextFn(value, thumb),
                                    thumb
                                );
                            }
                        };
                    MDCSliderFoundation2.prototype.updateValueIndicatorUI =
                        function (thumb) {
                            if (!this.isDiscrete) return;
                            var value =
                                this.isRange && thumb === Thumb.START
                                    ? this.valueStart
                                    : this.value;
                            this.adapter.setValueIndicatorText(
                                value,
                                thumb === Thumb.START ? Thumb.START : Thumb.END
                            );
                            if (!thumb && this.isRange) {
                                this.adapter.setValueIndicatorText(
                                    this.valueStart,
                                    Thumb.START
                                );
                            }
                        };
                    MDCSliderFoundation2.prototype.updateTickMarksUI =
                        function () {
                            if (!this.isDiscrete || !this.hasTickMarks) return;
                            var numTickMarksInactiveStart =
                                (this.valueStart - this.min) / this.step;
                            var numTickMarksActive =
                                (this.value - this.valueStart) / this.step + 1;
                            var numTickMarksInactiveEnd =
                                (this.max - this.value) / this.step;
                            var tickMarksInactiveStart = Array.from({
                                length: numTickMarksInactiveStart,
                            }).fill(TickMark.INACTIVE);
                            var tickMarksActive = Array.from({
                                length: numTickMarksActive,
                            }).fill(TickMark.ACTIVE);
                            var tickMarksInactiveEnd = Array.from({
                                length: numTickMarksInactiveEnd,
                            }).fill(TickMark.INACTIVE);
                            this.adapter.updateTickMarks(
                                tickMarksInactiveStart
                                    .concat(tickMarksActive)
                                    .concat(tickMarksInactiveEnd)
                            );
                        };
                    MDCSliderFoundation2.prototype.mapClientXOnSliderScale =
                        function (clientX) {
                            var xPos = clientX - this.rect.left;
                            var pctComplete = xPos / this.rect.width;
                            if (this.adapter.isRTL()) {
                                pctComplete = 1 - pctComplete;
                            }
                            var value =
                                this.min + pctComplete * (this.max - this.min);
                            if (value === this.max || value === this.min) {
                                return value;
                            }
                            return Number(
                                this.quantize(value).toFixed(
                                    this.numDecimalPlaces
                                )
                            );
                        };
                    MDCSliderFoundation2.prototype.quantize = function (value) {
                        var numSteps = Math.round(
                            (value - this.min) / this.step
                        );
                        return this.min + numSteps * this.step;
                    };
                    MDCSliderFoundation2.prototype.updateValue = function (
                        value,
                        thumb,
                        _a
                    ) {
                        var _b = _a === void 0 ? {} : _a,
                            emitInputEvent = _b.emitInputEvent;
                        value = this.clampValue(value, thumb);
                        if (this.isRange && thumb === Thumb.START) {
                            if (this.valueStart === value) return;
                            this.valueStart = value;
                        } else {
                            if (this.value === value) return;
                            this.value = value;
                        }
                        this.updateUI(thumb);
                        if (emitInputEvent) {
                            this.adapter.emitInputEvent(
                                thumb === Thumb.START
                                    ? this.valueStart
                                    : this.value,
                                thumb
                            );
                        }
                    };
                    MDCSliderFoundation2.prototype.clampValue = function (
                        value,
                        thumb
                    ) {
                        value = Math.min(Math.max(value, this.min), this.max);
                        var thumbStartMovedPastThumbEnd =
                            this.isRange &&
                            thumb === Thumb.START &&
                            value > this.value - this.minRange;
                        if (thumbStartMovedPastThumbEnd) {
                            return this.value - this.minRange;
                        }
                        var thumbEndMovedPastThumbStart =
                            this.isRange &&
                            thumb === Thumb.END &&
                            value < this.valueStart + this.minRange;
                        if (thumbEndMovedPastThumbStart) {
                            return this.valueStart + this.minRange;
                        }
                        return value;
                    };
                    MDCSliderFoundation2.prototype.updateThumbAndTrackUI =
                        function (thumb) {
                            var _this = this;
                            var _a = this,
                                max = _a.max,
                                min = _a.min;
                            var pctComplete =
                                (this.value - this.valueStart) / (max - min);
                            var rangePx = pctComplete * this.rect.width;
                            var isRtl = this.adapter.isRTL();
                            var transformProp = HAS_WINDOW
                                ? getCorrectPropertyName(window, 'transform')
                                : 'transform';
                            if (this.isRange) {
                                var thumbLeftPos_1 = this.adapter.isRTL()
                                    ? ((max - this.value) / (max - min)) *
                                      this.rect.width
                                    : ((this.valueStart - min) / (max - min)) *
                                      this.rect.width;
                                var thumbRightPos_1 = thumbLeftPos_1 + rangePx;
                                this.animFrame.request(
                                    AnimationKeys.SLIDER_UPDATE,
                                    function () {
                                        var trackAnimatesFromRight =
                                            (!isRtl && thumb === Thumb.START) ||
                                            (isRtl && thumb !== Thumb.START);
                                        if (trackAnimatesFromRight) {
                                            _this.adapter.setTrackActiveStyleProperty(
                                                'transform-origin',
                                                'right'
                                            );
                                            _this.adapter.setTrackActiveStyleProperty(
                                                'left',
                                                'auto'
                                            );
                                            _this.adapter.setTrackActiveStyleProperty(
                                                'right',
                                                _this.rect.width -
                                                    thumbRightPos_1 +
                                                    'px'
                                            );
                                        } else {
                                            _this.adapter.setTrackActiveStyleProperty(
                                                'transform-origin',
                                                'left'
                                            );
                                            _this.adapter.setTrackActiveStyleProperty(
                                                'right',
                                                'auto'
                                            );
                                            _this.adapter.setTrackActiveStyleProperty(
                                                'left',
                                                thumbLeftPos_1 + 'px'
                                            );
                                        }
                                        _this.adapter.setTrackActiveStyleProperty(
                                            transformProp,
                                            'scaleX(' + pctComplete + ')'
                                        );
                                        var thumbStartPos = isRtl
                                            ? thumbRightPos_1
                                            : thumbLeftPos_1;
                                        var thumbEndPos = _this.adapter.isRTL()
                                            ? thumbLeftPos_1
                                            : thumbRightPos_1;
                                        if (
                                            thumb === Thumb.START ||
                                            !thumb ||
                                            !_this.initialStylesRemoved
                                        ) {
                                            _this.adapter.setThumbStyleProperty(
                                                transformProp,
                                                'translateX(' +
                                                    thumbStartPos +
                                                    'px)',
                                                Thumb.START
                                            );
                                            _this.alignValueIndicator(
                                                Thumb.START,
                                                thumbStartPos
                                            );
                                        }
                                        if (
                                            thumb === Thumb.END ||
                                            !thumb ||
                                            !_this.initialStylesRemoved
                                        ) {
                                            _this.adapter.setThumbStyleProperty(
                                                transformProp,
                                                'translateX(' +
                                                    thumbEndPos +
                                                    'px)',
                                                Thumb.END
                                            );
                                            _this.alignValueIndicator(
                                                Thumb.END,
                                                thumbEndPos
                                            );
                                        }
                                        _this.removeInitialStyles(isRtl);
                                        _this.updateOverlappingThumbsUI(
                                            thumbStartPos,
                                            thumbEndPos,
                                            thumb
                                        );
                                    }
                                );
                            } else {
                                this.animFrame.request(
                                    AnimationKeys.SLIDER_UPDATE,
                                    function () {
                                        var thumbStartPos = isRtl
                                            ? _this.rect.width - rangePx
                                            : rangePx;
                                        _this.adapter.setThumbStyleProperty(
                                            transformProp,
                                            'translateX(' +
                                                thumbStartPos +
                                                'px)',
                                            Thumb.END
                                        );
                                        _this.alignValueIndicator(
                                            Thumb.END,
                                            thumbStartPos
                                        );
                                        _this.adapter.setTrackActiveStyleProperty(
                                            transformProp,
                                            'scaleX(' + pctComplete + ')'
                                        );
                                        _this.removeInitialStyles(isRtl);
                                    }
                                );
                            }
                        };
                    MDCSliderFoundation2.prototype.alignValueIndicator =
                        function (thumb, thumbPos) {
                            if (!this.isDiscrete) return;
                            var thumbHalfWidth =
                                this.adapter.getThumbBoundingClientRect(thumb)
                                    .width / 2;
                            var containerWidth =
                                this.adapter.getValueIndicatorContainerWidth(
                                    thumb
                                );
                            var sliderWidth =
                                this.adapter.getBoundingClientRect().width;
                            if (
                                containerWidth / 2 >
                                thumbPos + thumbHalfWidth
                            ) {
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CARET_LEFT,
                                    thumbHalfWidth + 'px',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CARET_RIGHT,
                                    'auto',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CARET_TRANSFORM,
                                    'translateX(-50%)',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CONTAINER_LEFT,
                                    '0',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CONTAINER_RIGHT,
                                    'auto',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CONTAINER_TRANSFORM,
                                    'none',
                                    thumb
                                );
                            } else if (
                                containerWidth / 2 >
                                sliderWidth - thumbPos + thumbHalfWidth
                            ) {
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CARET_LEFT,
                                    'auto',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CARET_RIGHT,
                                    thumbHalfWidth + 'px',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CARET_TRANSFORM,
                                    'translateX(50%)',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CONTAINER_LEFT,
                                    'auto',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CONTAINER_RIGHT,
                                    '0',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CONTAINER_TRANSFORM,
                                    'none',
                                    thumb
                                );
                            } else {
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CARET_LEFT,
                                    '50%',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CARET_RIGHT,
                                    'auto',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CARET_TRANSFORM,
                                    'translateX(-50%)',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CONTAINER_LEFT,
                                    '50%',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CONTAINER_RIGHT,
                                    'auto',
                                    thumb
                                );
                                this.adapter.setThumbStyleProperty(
                                    strings.VAR_VALUE_INDICATOR_CONTAINER_TRANSFORM,
                                    'translateX(-50%)',
                                    thumb
                                );
                            }
                        };
                    MDCSliderFoundation2.prototype.removeInitialStyles =
                        function (isRtl) {
                            if (this.initialStylesRemoved) return;
                            var position = isRtl ? 'right' : 'left';
                            this.adapter.removeThumbStyleProperty(
                                position,
                                Thumb.END
                            );
                            if (this.isRange) {
                                this.adapter.removeThumbStyleProperty(
                                    position,
                                    Thumb.START
                                );
                            }
                            this.initialStylesRemoved = true;
                            this.resetTrackAndThumbAnimation();
                        };
                    MDCSliderFoundation2.prototype.resetTrackAndThumbAnimation =
                        function () {
                            var _this = this;
                            if (!this.isDiscrete) return;
                            var transitionProp = HAS_WINDOW
                                ? getCorrectPropertyName(window, 'transition')
                                : 'transition';
                            var transitionDefault = 'none 0s ease 0s';
                            this.adapter.setThumbStyleProperty(
                                transitionProp,
                                transitionDefault,
                                Thumb.END
                            );
                            if (this.isRange) {
                                this.adapter.setThumbStyleProperty(
                                    transitionProp,
                                    transitionDefault,
                                    Thumb.START
                                );
                            }
                            this.adapter.setTrackActiveStyleProperty(
                                transitionProp,
                                transitionDefault
                            );
                            requestAnimationFrame(function () {
                                _this.adapter.removeThumbStyleProperty(
                                    transitionProp,
                                    Thumb.END
                                );
                                _this.adapter.removeTrackActiveStyleProperty(
                                    transitionProp
                                );
                                if (_this.isRange) {
                                    _this.adapter.removeThumbStyleProperty(
                                        transitionProp,
                                        Thumb.START
                                    );
                                }
                            });
                        };
                    MDCSliderFoundation2.prototype.updateOverlappingThumbsUI =
                        function (thumbStartPos, thumbEndPos, thumb) {
                            var thumbsOverlap = false;
                            if (this.adapter.isRTL()) {
                                var startThumbLeftEdge =
                                    thumbStartPos -
                                    this.startThumbKnobWidth / 2;
                                var endThumbRightEdge =
                                    thumbEndPos + this.endThumbKnobWidth / 2;
                                thumbsOverlap =
                                    endThumbRightEdge >= startThumbLeftEdge;
                            } else {
                                var startThumbRightEdge =
                                    thumbStartPos +
                                    this.startThumbKnobWidth / 2;
                                var endThumbLeftEdge =
                                    thumbEndPos - this.endThumbKnobWidth / 2;
                                thumbsOverlap =
                                    startThumbRightEdge >= endThumbLeftEdge;
                            }
                            if (thumbsOverlap) {
                                this.adapter.addThumbClass(
                                    cssClasses.THUMB_TOP,
                                    // If no thumb was dragged (in the case of initial layout), end
                                    // thumb is on top by default.
                                    thumb || Thumb.END
                                );
                                this.adapter.removeThumbClass(
                                    cssClasses.THUMB_TOP,
                                    thumb === Thumb.START
                                        ? Thumb.END
                                        : Thumb.START
                                );
                            } else {
                                this.adapter.removeThumbClass(
                                    cssClasses.THUMB_TOP,
                                    Thumb.START
                                );
                                this.adapter.removeThumbClass(
                                    cssClasses.THUMB_TOP,
                                    Thumb.END
                                );
                            }
                        };
                    MDCSliderFoundation2.prototype.convertAttributeValueToNumber =
                        function (attributeValue, attributeName) {
                            if (attributeValue === null) {
                                throw new Error(
                                    'MDCSliderFoundation: `' +
                                        attributeName +
                                        '` must be non-null.'
                                );
                            }
                            var value = Number(attributeValue);
                            if (isNaN(value)) {
                                throw new Error(
                                    'MDCSliderFoundation: `' +
                                        attributeName +
                                        '` value is `' +
                                        attributeValue +
                                        '`, but must be a number.'
                                );
                            }
                            return value;
                        };
                    MDCSliderFoundation2.prototype.validateProperties =
                        function (_a) {
                            var min = _a.min,
                                max = _a.max,
                                value = _a.value,
                                valueStart = _a.valueStart,
                                step = _a.step,
                                minRange = _a.minRange;
                            if (min >= max) {
                                throw new Error(
                                    'MDCSliderFoundation: min must be strictly less than max. ' +
                                        ('Current: [min: ' +
                                            min +
                                            ', max: ' +
                                            max +
                                            ']')
                                );
                            }
                            if (step <= 0) {
                                throw new Error(
                                    'MDCSliderFoundation: step must be a positive number. ' +
                                        ('Current step: ' + step)
                                );
                            }
                            if (this.isRange) {
                                if (
                                    value < min ||
                                    value > max ||
                                    valueStart < min ||
                                    valueStart > max
                                ) {
                                    throw new Error(
                                        'MDCSliderFoundation: values must be in [min, max] range. ' +
                                            ('Current values: [start value: ' +
                                                valueStart +
                                                ', end value: ') +
                                            (value +
                                                ', min: ' +
                                                min +
                                                ', max: ' +
                                                max +
                                                ']')
                                    );
                                }
                                if (valueStart > value) {
                                    throw new Error(
                                        'MDCSliderFoundation: start value must be <= end value. ' +
                                            ('Current values: [start value: ' +
                                                valueStart +
                                                ', end value: ' +
                                                value +
                                                ']')
                                    );
                                }
                                if (minRange < 0) {
                                    throw new Error(
                                        'MDCSliderFoundation: minimum range must be non-negative. ' +
                                            ('Current min range: ' + minRange)
                                    );
                                }
                                if (value - valueStart < minRange) {
                                    throw new Error(
                                        'MDCSliderFoundation: start value and end value must differ by at least ' +
                                            (minRange +
                                                '. Current values: [start value: ' +
                                                valueStart +
                                                ', ') +
                                            ('end value: ' + value + ']')
                                    );
                                }
                                var numStepsValueStartFromMin =
                                    (valueStart - min) / step;
                                var numStepsValueFromMin = (value - min) / step;
                                if (
                                    !Number.isInteger(
                                        parseFloat(
                                            numStepsValueStartFromMin.toFixed(6)
                                        )
                                    ) ||
                                    !Number.isInteger(
                                        parseFloat(
                                            numStepsValueFromMin.toFixed(6)
                                        )
                                    )
                                ) {
                                    throw new Error(
                                        'MDCSliderFoundation: Slider values must be valid based on the ' +
                                            ('step value (' +
                                                step +
                                                '). Current values: [start value: ') +
                                            (valueStart +
                                                ', end value: ' +
                                                value +
                                                ', min: ' +
                                                min +
                                                ']')
                                    );
                                }
                            } else {
                                if (value < min || value > max) {
                                    throw new Error(
                                        'MDCSliderFoundation: value must be in [min, max] range. ' +
                                            ('Current values: [value: ' +
                                                value +
                                                ', min: ' +
                                                min +
                                                ', max: ' +
                                                max +
                                                ']')
                                    );
                                }
                                var numStepsValueFromMin = (value - min) / step;
                                if (
                                    !Number.isInteger(
                                        parseFloat(
                                            numStepsValueFromMin.toFixed(6)
                                        )
                                    )
                                ) {
                                    throw new Error(
                                        'MDCSliderFoundation: Slider value must be valid based on the ' +
                                            ('step value (' +
                                                step +
                                                '). Current value: ' +
                                                value)
                                    );
                                }
                            }
                        };
                    MDCSliderFoundation2.prototype.registerEventHandlers =
                        function () {
                            this.adapter.registerWindowEventHandler(
                                'resize',
                                this.resizeListener
                            );
                            if (MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS) {
                                this.adapter.registerEventHandler(
                                    'pointerdown',
                                    this.pointerdownListener
                                );
                                this.adapter.registerEventHandler(
                                    'pointerup',
                                    this.pointerupListener
                                );
                            } else {
                                this.adapter.registerEventHandler(
                                    'mousedown',
                                    this.mousedownOrTouchstartListener
                                );
                                this.adapter.registerEventHandler(
                                    'touchstart',
                                    this.mousedownOrTouchstartListener
                                );
                            }
                            if (this.isRange) {
                                this.adapter.registerThumbEventHandler(
                                    Thumb.START,
                                    'mouseenter',
                                    this.thumbMouseenterListener
                                );
                                this.adapter.registerThumbEventHandler(
                                    Thumb.START,
                                    'mouseleave',
                                    this.thumbMouseleaveListener
                                );
                                this.adapter.registerInputEventHandler(
                                    Thumb.START,
                                    'change',
                                    this.inputStartChangeListener
                                );
                                this.adapter.registerInputEventHandler(
                                    Thumb.START,
                                    'focus',
                                    this.inputStartFocusListener
                                );
                                this.adapter.registerInputEventHandler(
                                    Thumb.START,
                                    'blur',
                                    this.inputStartBlurListener
                                );
                            }
                            this.adapter.registerThumbEventHandler(
                                Thumb.END,
                                'mouseenter',
                                this.thumbMouseenterListener
                            );
                            this.adapter.registerThumbEventHandler(
                                Thumb.END,
                                'mouseleave',
                                this.thumbMouseleaveListener
                            );
                            this.adapter.registerInputEventHandler(
                                Thumb.END,
                                'change',
                                this.inputEndChangeListener
                            );
                            this.adapter.registerInputEventHandler(
                                Thumb.END,
                                'focus',
                                this.inputEndFocusListener
                            );
                            this.adapter.registerInputEventHandler(
                                Thumb.END,
                                'blur',
                                this.inputEndBlurListener
                            );
                        };
                    MDCSliderFoundation2.prototype.deregisterEventHandlers =
                        function () {
                            this.adapter.deregisterWindowEventHandler(
                                'resize',
                                this.resizeListener
                            );
                            if (MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS) {
                                this.adapter.deregisterEventHandler(
                                    'pointerdown',
                                    this.pointerdownListener
                                );
                                this.adapter.deregisterEventHandler(
                                    'pointerup',
                                    this.pointerupListener
                                );
                            } else {
                                this.adapter.deregisterEventHandler(
                                    'mousedown',
                                    this.mousedownOrTouchstartListener
                                );
                                this.adapter.deregisterEventHandler(
                                    'touchstart',
                                    this.mousedownOrTouchstartListener
                                );
                            }
                            if (this.isRange) {
                                this.adapter.deregisterThumbEventHandler(
                                    Thumb.START,
                                    'mouseenter',
                                    this.thumbMouseenterListener
                                );
                                this.adapter.deregisterThumbEventHandler(
                                    Thumb.START,
                                    'mouseleave',
                                    this.thumbMouseleaveListener
                                );
                                this.adapter.deregisterInputEventHandler(
                                    Thumb.START,
                                    'change',
                                    this.inputStartChangeListener
                                );
                                this.adapter.deregisterInputEventHandler(
                                    Thumb.START,
                                    'focus',
                                    this.inputStartFocusListener
                                );
                                this.adapter.deregisterInputEventHandler(
                                    Thumb.START,
                                    'blur',
                                    this.inputStartBlurListener
                                );
                            }
                            this.adapter.deregisterThumbEventHandler(
                                Thumb.END,
                                'mouseenter',
                                this.thumbMouseenterListener
                            );
                            this.adapter.deregisterThumbEventHandler(
                                Thumb.END,
                                'mouseleave',
                                this.thumbMouseleaveListener
                            );
                            this.adapter.deregisterInputEventHandler(
                                Thumb.END,
                                'change',
                                this.inputEndChangeListener
                            );
                            this.adapter.deregisterInputEventHandler(
                                Thumb.END,
                                'focus',
                                this.inputEndFocusListener
                            );
                            this.adapter.deregisterInputEventHandler(
                                Thumb.END,
                                'blur',
                                this.inputEndBlurListener
                            );
                        };
                    MDCSliderFoundation2.prototype.handlePointerup =
                        function () {
                            this.handleUp();
                            this.adapter.deregisterEventHandler(
                                'pointermove',
                                this.moveListener
                            );
                        };
                    MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS =
                        HAS_WINDOW &&
                        Boolean(window.PointerEvent) && // #setPointerCapture is buggy on iOS, so we can't use pointer events
                        // until the following bug is fixed:
                        // https://bugs.webkit.org/show_bug.cgi?id=220196
                        !isIOS();
                    return MDCSliderFoundation2;
                })(MDCFoundation);
            function isIOS() {
                return (
                    [
                        'iPad Simulator',
                        'iPhone Simulator',
                        'iPod Simulator',
                        'iPad',
                        'iPhone',
                        'iPod',
                    ].includes(navigator.platform) ||
                    (navigator.userAgent.includes('Mac') &&
                        'ontouchend' in document)
                );
            }
            function getNumDecimalPlaces(n) {
                var match = /(?:\.(\d+))?(?:[eE]([+\-]?\d+))?$/.exec(String(n));
                if (!match) return 0;
                var fraction = match[1] || '';
                var exponent = match[2] || 0;
                return Math.max(
                    0,
                    // lower limit
                    (fraction === '0' ? 0 : fraction.length) - Number(exponent)
                );
            }
            /**
             * @license
             * Copyright 2020 Google Inc.
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */
            var MDCSlider =
                /** @class */
                (function (_super) {
                    __extends(MDCSlider2, _super);
                    function MDCSlider2() {
                        var _this =
                            (_super !== null &&
                                _super.apply(this, arguments)) ||
                            this;
                        _this.skipInitialUIUpdate = false;
                        _this.valueToAriaValueTextFn = null;
                        return _this;
                    }
                    MDCSlider2.attachTo = function (root, options) {
                        if (options === void 0) {
                            options = {};
                        }
                        return new MDCSlider2(root, void 0, options);
                    };
                    MDCSlider2.prototype.getDefaultFoundation = function () {
                        var _this = this;
                        var adapter = {
                            hasClass: function (className) {
                                return _this.root.classList.contains(className);
                            },
                            addClass: function (className) {
                                _this.root.classList.add(className);
                            },
                            removeClass: function (className) {
                                _this.root.classList.remove(className);
                            },
                            addThumbClass: function (className, thumb) {
                                _this
                                    .getThumbEl(thumb)
                                    .classList.add(className);
                            },
                            removeThumbClass: function (className, thumb) {
                                _this
                                    .getThumbEl(thumb)
                                    .classList.remove(className);
                            },
                            getAttribute: function (attribute) {
                                return _this.root.getAttribute(attribute);
                            },
                            getInputValue: function (thumb) {
                                return _this.getInput(thumb).value;
                            },
                            setInputValue: function (value, thumb) {
                                _this.getInput(thumb).value = value;
                            },
                            getInputAttribute: function (attribute, thumb) {
                                return _this
                                    .getInput(thumb)
                                    .getAttribute(attribute);
                            },
                            setInputAttribute: function (
                                attribute,
                                value,
                                thumb
                            ) {
                                _this
                                    .getInput(thumb)
                                    .setAttribute(attribute, value);
                            },
                            removeInputAttribute: function (attribute, thumb) {
                                _this
                                    .getInput(thumb)
                                    .removeAttribute(attribute);
                            },
                            focusInput: function (thumb) {
                                _this.getInput(thumb).focus();
                            },
                            isInputFocused: function (thumb) {
                                return (
                                    _this.getInput(thumb) ===
                                    document.activeElement
                                );
                            },
                            shouldHideFocusStylesForPointerEvents: function () {
                                return false;
                            },
                            getThumbKnobWidth: function (thumb) {
                                return _this
                                    .getThumbEl(thumb)
                                    .querySelector('.' + cssClasses.THUMB_KNOB)
                                    .getBoundingClientRect().width;
                            },
                            getThumbBoundingClientRect: function (thumb) {
                                return _this
                                    .getThumbEl(thumb)
                                    .getBoundingClientRect();
                            },
                            getBoundingClientRect: function () {
                                return _this.root.getBoundingClientRect();
                            },
                            getValueIndicatorContainerWidth: function (thumb) {
                                return _this
                                    .getThumbEl(thumb)
                                    .querySelector(
                                        '.' +
                                            cssClasses.VALUE_INDICATOR_CONTAINER
                                    )
                                    .getBoundingClientRect().width;
                            },
                            isRTL: function () {
                                return (
                                    getComputedStyle(_this.root).direction ===
                                    'rtl'
                                );
                            },
                            setThumbStyleProperty: function (
                                propertyName,
                                value,
                                thumb
                            ) {
                                _this
                                    .getThumbEl(thumb)
                                    .style.setProperty(propertyName, value);
                            },
                            removeThumbStyleProperty: function (
                                propertyName,
                                thumb
                            ) {
                                _this
                                    .getThumbEl(thumb)
                                    .style.removeProperty(propertyName);
                            },
                            setTrackActiveStyleProperty: function (
                                propertyName,
                                value
                            ) {
                                _this.trackActive.style.setProperty(
                                    propertyName,
                                    value
                                );
                            },
                            removeTrackActiveStyleProperty: function (
                                propertyName
                            ) {
                                _this.trackActive.style.removeProperty(
                                    propertyName
                                );
                            },
                            setValueIndicatorText: function (value, thumb) {
                                var valueIndicatorEl = _this
                                    .getThumbEl(thumb)
                                    .querySelector(
                                        '.' + cssClasses.VALUE_INDICATOR_TEXT
                                    );
                                valueIndicatorEl.textContent = String(value);
                            },
                            getValueToAriaValueTextFn: function () {
                                return _this.valueToAriaValueTextFn;
                            },
                            updateTickMarks: function (tickMarks) {
                                var tickMarksContainer =
                                    _this.root.querySelector(
                                        '.' + cssClasses.TICK_MARKS_CONTAINER
                                    );
                                if (!tickMarksContainer) {
                                    tickMarksContainer =
                                        document.createElement('div');
                                    tickMarksContainer.classList.add(
                                        cssClasses.TICK_MARKS_CONTAINER
                                    );
                                    var track = _this.root.querySelector(
                                        '.' + cssClasses.TRACK
                                    );
                                    track.appendChild(tickMarksContainer);
                                }
                                if (
                                    tickMarks.length !==
                                    tickMarksContainer.children.length
                                ) {
                                    while (tickMarksContainer.firstChild) {
                                        tickMarksContainer.removeChild(
                                            tickMarksContainer.firstChild
                                        );
                                    }
                                    _this.addTickMarks(
                                        tickMarksContainer,
                                        tickMarks
                                    );
                                } else {
                                    _this.updateTickMarks(
                                        tickMarksContainer,
                                        tickMarks
                                    );
                                }
                            },
                            setPointerCapture: function (pointerId) {
                                _this.root.setPointerCapture(pointerId);
                            },
                            emitChangeEvent: function (value, thumb) {
                                _this.emit(events.CHANGE, { value, thumb });
                            },
                            emitInputEvent: function (value, thumb) {
                                _this.emit(events.INPUT, { value, thumb });
                            },
                            emitDragStartEvent: function (_, thumb) {
                                _this.getRipple(thumb).activate();
                            },
                            emitDragEndEvent: function (_, thumb) {
                                _this.getRipple(thumb).deactivate();
                            },
                            registerEventHandler: function (evtType, handler) {
                                _this.listen(evtType, handler);
                            },
                            deregisterEventHandler: function (
                                evtType,
                                handler
                            ) {
                                _this.unlisten(evtType, handler);
                            },
                            registerThumbEventHandler: function (
                                thumb,
                                evtType,
                                handler
                            ) {
                                _this
                                    .getThumbEl(thumb)
                                    .addEventListener(evtType, handler);
                            },
                            deregisterThumbEventHandler: function (
                                thumb,
                                evtType,
                                handler
                            ) {
                                _this
                                    .getThumbEl(thumb)
                                    .removeEventListener(evtType, handler);
                            },
                            registerInputEventHandler: function (
                                thumb,
                                evtType,
                                handler
                            ) {
                                _this
                                    .getInput(thumb)
                                    .addEventListener(evtType, handler);
                            },
                            deregisterInputEventHandler: function (
                                thumb,
                                evtType,
                                handler
                            ) {
                                _this
                                    .getInput(thumb)
                                    .removeEventListener(evtType, handler);
                            },
                            registerBodyEventHandler: function (
                                evtType,
                                handler
                            ) {
                                document.body.addEventListener(
                                    evtType,
                                    handler
                                );
                            },
                            deregisterBodyEventHandler: function (
                                evtType,
                                handler
                            ) {
                                document.body.removeEventListener(
                                    evtType,
                                    handler
                                );
                            },
                            registerWindowEventHandler: function (
                                evtType,
                                handler
                            ) {
                                window.addEventListener(evtType, handler);
                            },
                            deregisterWindowEventHandler: function (
                                evtType,
                                handler
                            ) {
                                window.removeEventListener(evtType, handler);
                            },
                            // tslint:enable:object-literal-sort-keys
                        };
                        return new MDCSliderFoundation(adapter);
                    };
                    MDCSlider2.prototype.initialize = function (_a) {
                        var _b = _a === void 0 ? {} : _a,
                            skipInitialUIUpdate = _b.skipInitialUIUpdate;
                        this.inputs = [].slice.call(
                            this.root.querySelectorAll('.' + cssClasses.INPUT)
                        );
                        this.thumbs = [].slice.call(
                            this.root.querySelectorAll('.' + cssClasses.THUMB)
                        );
                        this.trackActive = this.root.querySelector(
                            '.' + cssClasses.TRACK_ACTIVE
                        );
                        this.ripples = this.createRipples();
                        if (skipInitialUIUpdate) {
                            this.skipInitialUIUpdate = true;
                        }
                    };
                    MDCSlider2.prototype.initialSyncWithDOM = function () {
                        this.foundation.layout({
                            skipUpdateUI: this.skipInitialUIUpdate,
                        });
                    };
                    MDCSlider2.prototype.layout = function () {
                        this.foundation.layout();
                    };
                    MDCSlider2.prototype.getValueStart = function () {
                        return this.foundation.getValueStart();
                    };
                    MDCSlider2.prototype.setValueStart = function (valueStart) {
                        this.foundation.setValueStart(valueStart);
                    };
                    MDCSlider2.prototype.getValue = function () {
                        return this.foundation.getValue();
                    };
                    MDCSlider2.prototype.setValue = function (value) {
                        this.foundation.setValue(value);
                    };
                    MDCSlider2.prototype.getDisabled = function () {
                        return this.foundation.getDisabled();
                    };
                    MDCSlider2.prototype.setDisabled = function (disabled) {
                        this.foundation.setDisabled(disabled);
                    };
                    MDCSlider2.prototype.setValueToAriaValueTextFn = function (
                        mapFn
                    ) {
                        this.valueToAriaValueTextFn = mapFn;
                    };
                    MDCSlider2.prototype.getThumbEl = function (thumb) {
                        return thumb === Thumb.END
                            ? this.thumbs[this.thumbs.length - 1]
                            : this.thumbs[0];
                    };
                    MDCSlider2.prototype.getInput = function (thumb) {
                        return thumb === Thumb.END
                            ? this.inputs[this.inputs.length - 1]
                            : this.inputs[0];
                    };
                    MDCSlider2.prototype.getRipple = function (thumb) {
                        return thumb === Thumb.END
                            ? this.ripples[this.ripples.length - 1]
                            : this.ripples[0];
                    };
                    MDCSlider2.prototype.addTickMarks = function (
                        tickMarkContainer,
                        tickMarks
                    ) {
                        var fragment = document.createDocumentFragment();
                        for (var i = 0; i < tickMarks.length; i++) {
                            var div = document.createElement('div');
                            var tickMarkClass =
                                tickMarks[i] === TickMark.ACTIVE
                                    ? cssClasses.TICK_MARK_ACTIVE
                                    : cssClasses.TICK_MARK_INACTIVE;
                            div.classList.add(tickMarkClass);
                            fragment.appendChild(div);
                        }
                        tickMarkContainer.appendChild(fragment);
                    };
                    MDCSlider2.prototype.updateTickMarks = function (
                        tickMarkContainer,
                        tickMarks
                    ) {
                        var tickMarkEls = Array.from(
                            tickMarkContainer.children
                        );
                        for (var i = 0; i < tickMarkEls.length; i++) {
                            if (tickMarks[i] === TickMark.ACTIVE) {
                                tickMarkEls[i].classList.add(
                                    cssClasses.TICK_MARK_ACTIVE
                                );
                                tickMarkEls[i].classList.remove(
                                    cssClasses.TICK_MARK_INACTIVE
                                );
                            } else {
                                tickMarkEls[i].classList.add(
                                    cssClasses.TICK_MARK_INACTIVE
                                );
                                tickMarkEls[i].classList.remove(
                                    cssClasses.TICK_MARK_ACTIVE
                                );
                            }
                        }
                    };
                    MDCSlider2.prototype.createRipples = function () {
                        var ripples = [];
                        var rippleSurfaces = [].slice.call(
                            this.root.querySelectorAll('.' + cssClasses.THUMB)
                        );
                        var _loop_1 = function (i2) {
                            var rippleSurface = rippleSurfaces[i2];
                            var input = this_1.inputs[i2];
                            var adapter = __assign(
                                __assign({}, MDCRipple.createAdapter(this_1)),
                                {
                                    addClass: function (className) {
                                        rippleSurface.classList.add(className);
                                    },
                                    computeBoundingRect: function () {
                                        return rippleSurface.getBoundingClientRect();
                                    },
                                    deregisterInteractionHandler: function (
                                        evtType,
                                        handler
                                    ) {
                                        input.removeEventListener(
                                            evtType,
                                            handler
                                        );
                                    },
                                    isSurfaceActive: function () {
                                        return matches(input, ':active');
                                    },
                                    isUnbounded: function () {
                                        return true;
                                    },
                                    registerInteractionHandler: function (
                                        evtType,
                                        handler
                                    ) {
                                        input.addEventListener(
                                            evtType,
                                            handler,
                                            applyPassive()
                                        );
                                    },
                                    removeClass: function (className) {
                                        rippleSurface.classList.remove(
                                            className
                                        );
                                    },
                                    updateCssVariable: function (
                                        varName,
                                        value
                                    ) {
                                        rippleSurface.style.setProperty(
                                            varName,
                                            value
                                        );
                                    },
                                }
                            );
                            var ripple = new MDCRipple(
                                rippleSurface,
                                new MDCRippleFoundation(adapter)
                            );
                            ripple.unbounded = true;
                            ripples.push(ripple);
                        };
                        var this_1 = this;
                        for (var i = 0; i < rippleSurfaces.length; i++) {
                            _loop_1(i);
                        }
                        return ripples;
                    };
                    return MDCSlider2;
                })(MDCComponent);
            class SliderComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    return element2;
                }
                onSliderChange(event) {
                    let value = this.mdcSlider.getValue();
                    if (value !== this.state.value) {
                        this.setStateAndNotifyBackend({
                            value,
                        });
                    }
                }
                updateElement(deltaState, latentComponents) {
                    if (
                        deltaState.minimum !== void 0 ||
                        deltaState.maximum !== void 0 ||
                        deltaState.step_size !== void 0
                    ) {
                        let min = firstDefined(
                            deltaState.minimum,
                            this.state.minimum
                        );
                        let max = firstDefined(
                            deltaState.maximum,
                            this.state.maximum
                        );
                        let step = firstDefined(
                            deltaState.step_size,
                            this.state.step_size
                        );
                        step = step == 0 ? 1e-4 : step;
                        let value = firstDefined(
                            deltaState.value,
                            this.state.value
                        );
                        this.element.innerHTML = `
            <div class="mdc-slider" style="pointer-events: auto">
                <input class="mdc-slider__input" type="range" min="${min}" max="${max}" value="${value}" step="${step}">
                <div class="mdc-slider__track">
                    <div class="mdc-slider__track--inactive"></div>
                    <div class="mdc-slider__track--active">
                        <div class="mdc-slider__track--active_fill"></div>
                    </div>
                </div>
                <div class="mdc-slider__thumb">
                    <div class="mdc-slider__thumb-knob"></div>
                </div>
            </div>
            `;
                        this.mdcSlider = new MDCSlider(
                            this.element.firstElementChild
                        );
                        this.mdcSlider.listen(
                            'MDCSlider:change',
                            this.onSliderChange.bind(this)
                        );
                    }
                    if (deltaState.value !== void 0) {
                        let value = deltaState.value;
                        value = Math.max(
                            value,
                            firstDefined(deltaState.minimum, this.state.minimum)
                        );
                        value = Math.min(
                            value,
                            firstDefined(deltaState.maximum, this.state.maximum)
                        );
                        let step = firstDefined(
                            deltaState.step_size,
                            this.state.step_size
                        );
                        step = step == 0 ? 1e-4 : step;
                        value = Math.round(value / step) * step;
                    }
                    if (deltaState.is_sensitive !== void 0) {
                        this.mdcSlider.setDisabled(!deltaState.is_sensitive);
                    }
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 6;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 48 / pixelsPerRem;
                }
                updateAllocatedHeight(ctx) {
                    this.mdcSlider.layout();
                }
            }
            const switchDuration = 0.8;
            const progressBarFadeDuration = 0.2;
            class SlideshowComponent extends SingleContainer {
                constructor() {
                    super(...arguments);
                    this.isPaused = false;
                    this.currentChildIndex = 0;
                    this.waitTimeProgress = 0;
                    this.switchProgress = 0;
                    this.progressBarOpacity = 1;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-slideshow');
                    element2.innerHTML = `
<div class="slideshow-child-container">
</div>
<div class="slideshow-progress"> </div>
`;
                    this.childContainer = element2.querySelector(
                        '.slideshow-child-container'
                    );
                    this.progressBar = element2.querySelector(
                        '.slideshow-progress'
                    );
                    element2.addEventListener('mouseenter', () => {
                        this.isPaused = true;
                    });
                    element2.addEventListener('mouseleave', () => {
                        this.isPaused = false;
                    });
                    this.lastUpdateAt = Date.now() / 1e3;
                    requestAnimationFrame(this.updateLoop.bind(this));
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.children !== void 0) {
                        this.replaceChildren(
                            latentComponents,
                            deltaState.children,
                            this.childContainer,
                            true
                        );
                        let ii = 0;
                        for (let child of Array.from(
                            this.childContainer.children
                        )) {
                            if (!(child instanceof HTMLElement)) {
                                continue;
                            }
                            if (ii == this.currentChildIndex) {
                                child.style.transform = 'translateX(0%)';
                            } else {
                                child.style.transform = 'translateX(-100%)';
                            }
                            ++ii;
                        }
                        this.makeLayoutDirty();
                    }
                    if (deltaState.corner_radius !== void 0) {
                        let [topLeft, topRight, bottomRight, bottomLeft] =
                            deltaState.corner_radius;
                        this.element.style.borderRadius = `${topLeft}rem ${topRight}rem ${bottomRight}rem ${bottomLeft}rem`;
                    }
                }
                async updateLoop() {
                    if (!this.element.isConnected) {
                        return;
                    }
                    let children = Array.from(this.childContainer.children);
                    if (children.length <= 1) {
                        return;
                    }
                    const now = Date.now() / 1e3;
                    const passedTime = now - this.lastUpdateAt;
                    if (this.waitTimeProgress == 1) {
                        this.switchProgress = Math.min(
                            this.switchProgress + passedTime / switchDuration,
                            1
                        );
                        let offset = easeInOut(this.switchProgress);
                        this.outgoingChild.style.transform = `translateX(${-100 * offset}%)`;
                        this.incomingChild.style.transform = `translateX(${-100 * (offset - 1)}%)`;
                        this.progressBarOpacity = Math.max(
                            this.progressBarOpacity -
                                passedTime / progressBarFadeDuration,
                            0
                        );
                        this.progressBar.style.opacity = easeOut(
                            this.progressBarOpacity
                        ).toString();
                        if (this.switchProgress == 1) {
                            this.waitTimeProgress = 0;
                            this.progressBarOpacity = 1;
                        }
                    } else if (!this.isPaused) {
                        this.waitTimeProgress = Math.min(
                            this.waitTimeProgress +
                                passedTime / this.state.linger_time,
                            1
                        );
                        this.progressBar.style.width = `${this.waitTimeProgress * 100}%`;
                        this.progressBarOpacity = Math.min(
                            this.progressBarOpacity +
                                passedTime / progressBarFadeDuration,
                            1
                        );
                        this.progressBar.style.opacity = easeIn(
                            this.progressBarOpacity
                        ).toString();
                        if (this.waitTimeProgress == 1) {
                            this.switchProgress = 0;
                            this.outgoingChild =
                                children[this.currentChildIndex];
                            this.currentChildIndex =
                                (this.currentChildIndex + 1) % children.length;
                            this.incomingChild =
                                children[this.currentChildIndex];
                        }
                    } else {
                        this.progressBarOpacity = Math.max(
                            this.progressBarOpacity -
                                passedTime / progressBarFadeDuration,
                            0
                        );
                        this.progressBar.style.opacity = easeOut(
                            this.progressBarOpacity
                        ).toString();
                        if (this.progressBarOpacity === 0) {
                            this.waitTimeProgress = 0;
                        }
                    }
                    this.lastUpdateAt = now;
                    requestAnimationFrame(this.updateLoop.bind(this));
                }
            }
            class StackComponent extends SingleContainer {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-stack');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceChildren(latentComponents, deltaState.children);
                }
            }
            class SwitchComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-switch');
                    let containerElement = document.createElement('div');
                    element2.appendChild(containerElement);
                    let checkboxElement = document.createElement('input');
                    checkboxElement.type = 'checkbox';
                    containerElement.appendChild(checkboxElement);
                    let knobElement = document.createElement('div');
                    knobElement.classList.add('knob');
                    containerElement.appendChild(knobElement);
                    checkboxElement.addEventListener('change', () => {
                        this.setStateAndNotifyBackend({
                            is_on: checkboxElement.checked,
                        });
                    });
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.is_on !== void 0) {
                        if (deltaState.is_on) {
                            this.element.classList.add('is-on');
                        } else {
                            this.element.classList.remove('is-on');
                        }
                        let checkboxElement =
                            this.element.querySelector('input');
                        if (
                            (checkboxElement == null
                                ? void 0
                                : checkboxElement.checked) !== deltaState.is_on
                        ) {
                            checkboxElement.checked = deltaState.is_on;
                        }
                    }
                    if (deltaState.is_sensitive === true) {
                        this.element.classList.remove(
                            'rio-switcheroo-disabled'
                        );
                        let checkbox = this.element.querySelector('input');
                        checkbox.disabled = false;
                    } else if (deltaState.is_sensitive === false) {
                        this.element.classList.add('rio-switcheroo-disabled');
                        let checkbox = this.element.querySelector('input');
                        checkbox.disabled = true;
                    }
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth = 3.18;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight = 1.54;
                }
            }
            const ACCELERATION = 350;
            const MARKER_FADE_DURATION = 0.18;
            const OPTION_MARGIN = 0.5;
            const ICON_HEIGHT = 1.8;
            const ICON_MARGIN = 0.5;
            const TEXT_STYLE = {
                fontName: 'Roboto',
                fill: [0, 0, 0, 1],
                fontSize: 1,
                italic: false,
                fontWeight: 'bold',
                underlined: false,
                allCaps: false,
            };
            const TEXT_STYLE_CSS_OPTIONS = textStyleToCss(TEXT_STYLE);
            class SwitcherBarComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.markerCurLeft = 0;
                    this.markerCurTop = 0;
                    this.markerCurWidth = 0;
                    this.markerCurHeight = 0;
                    this.markerCurVelocity = 0;
                    this.lastAnimationTickAt = -1;
                    this.isInitialized = false;
                }
                createElement() {
                    let elementOuter = document.createElement('div');
                    elementOuter.classList.add('rio-switcher-bar');
                    this.innerElement = document.createElement('div');
                    elementOuter.appendChild(this.innerElement);
                    this.markerElement = document.createElement('div');
                    this.markerElement.classList.add('rio-switcher-bar-marker');
                    return elementOuter;
                }
                /// Instantly move the marker to the position stored in the instance
                placeMarkerToState() {
                    let easedFade = easeInOut(this.markerCurFade);
                    let scaledWidth = this.markerCurWidth * easedFade;
                    let scaledHeight = this.markerCurHeight * easedFade;
                    let left =
                        this.markerCurLeft +
                        (this.markerCurWidth - scaledWidth) / 2;
                    let top =
                        this.markerCurTop +
                        (this.markerCurHeight - scaledHeight) / 2;
                    this.markerElement.style.left = `${left}rem`;
                    this.markerElement.style.top = `${top}rem`;
                    this.markerElement.style.width = `${scaledWidth}rem`;
                    this.markerElement.style.height = `${scaledHeight}rem`;
                    this.markerOptionsElement.style.left = `-${left}rem`;
                    this.markerOptionsElement.style.top = `-${top}rem`;
                }
                /// If an item is selected, returns the position and size the marker should
                /// be in order to highlight the selected item. Returns `null` if no item is
                /// currently selected.
                getMarkerTarget() {
                    if (this.state.selectedName === null) {
                        return null;
                    }
                    let selectedIndex = this.state.names.indexOf(
                        this.state.selectedName
                    );
                    console.assert(selectedIndex !== -1);
                    if (this.state.orientation == 'horizontal') {
                        let additionalWidth =
                            this.allocatedWidth - this.naturalWidth;
                        let left = 0;
                        if (this.state.names.length === 1) {
                            left = additionalWidth / 2;
                        } else {
                            let spacing =
                                additionalWidth /
                                    (this.state.names.length - 1) +
                                this.state.spacing;
                            left = spacing * selectedIndex;
                        }
                        for (let i = 0; i < selectedIndex; i++) {
                            left += this.optionWidths[i];
                        }
                        return [
                            left,
                            0,
                            this.optionWidths[selectedIndex],
                            this.naturalHeight,
                        ];
                    } else {
                        let additionalHeight =
                            this.allocatedHeight - this.naturalHeight;
                        let top = 0;
                        if (this.state.names.length === 1) {
                            top = additionalHeight / 2;
                        } else {
                            let spacing =
                                additionalHeight /
                                    (this.state.names.length - 1) +
                                this.state.spacing;
                            top = spacing * selectedIndex;
                        }
                        for (let i = 0; i < selectedIndex; i++) {
                            top += this.optionHeights[i];
                        }
                        return [
                            0,
                            top,
                            this.naturalWidth,
                            this.optionHeights[selectedIndex],
                        ];
                    }
                }
                /// Instantly move the marker to the currently selected item
                moveMarkerInstantlyIfAnimationIsntRunning() {
                    if (this.lastAnimationTickAt !== -1) {
                        return;
                    }
                    let target = this.getMarkerTarget();
                    if (target === null) {
                        return;
                    }
                    this.markerCurLeft = target[0];
                    this.markerCurTop = target[1];
                    this.markerCurWidth = target[2];
                    this.markerCurHeight = target[3];
                    this.placeMarkerToState();
                }
                moveAnimationWorker(deltaTime) {
                    let target = this.getMarkerTarget();
                    if (target === null) {
                        return false;
                    }
                    let curPos, targetPos;
                    if (this.state.orientation == 'horizontal') {
                        curPos = this.markerCurLeft;
                        targetPos = target[0];
                    } else {
                        curPos = this.markerCurTop;
                        targetPos = target[1];
                    }
                    let signedRemainingDistance = targetPos - curPos;
                    let accelerationFactor;
                    let brakingDistance =
                        Math.pow(this.markerCurVelocity, 2) /
                        (2 * ACCELERATION);
                    if (
                        Math.sign(signedRemainingDistance) !=
                        Math.sign(this.markerCurVelocity)
                    ) {
                        accelerationFactor = 3;
                    } else if (
                        Math.abs(signedRemainingDistance) < brakingDistance
                    ) {
                        accelerationFactor = -1;
                    } else {
                        accelerationFactor = 1;
                    }
                    let currentAcceleration =
                        ACCELERATION *
                        accelerationFactor *
                        Math.sign(signedRemainingDistance);
                    this.markerCurVelocity += currentAcceleration * deltaTime;
                    let deltaDistance = this.markerCurVelocity * deltaTime;
                    let t;
                    if (
                        Math.abs(deltaDistance) >=
                        Math.abs(signedRemainingDistance)
                    ) {
                        t = 1;
                    } else {
                        t = deltaDistance / signedRemainingDistance;
                    }
                    this.markerCurLeft += t * (target[0] - this.markerCurLeft);
                    this.markerCurTop += t * (target[1] - this.markerCurTop);
                    this.markerCurWidth +=
                        t * (target[2] - this.markerCurWidth);
                    this.markerCurHeight +=
                        t * (target[3] - this.markerCurHeight);
                    return t !== 1;
                }
                fadeAnimationWorker(deltaTime) {
                    let target = this.state.selectedName === null ? 0 : 1;
                    let amount =
                        (Math.sign(target - this.markerCurFade) * deltaTime) /
                        MARKER_FADE_DURATION;
                    this.markerCurFade += amount;
                    this.markerCurFade = Math.min(
                        Math.max(this.markerCurFade, 0),
                        1
                    );
                    return this.markerCurFade !== target;
                }
                animationWorker() {
                    let now = Date.now();
                    let deltaTime = (now - this.lastAnimationTickAt) / 1e3;
                    this.lastAnimationTickAt = now;
                    let moveKeepGoing = this.moveAnimationWorker(deltaTime);
                    let fadeKeepGoing = this.fadeAnimationWorker(deltaTime);
                    let keepGoing = moveKeepGoing || fadeKeepGoing;
                    this.placeMarkerToState();
                    if (keepGoing) {
                        requestAnimationFrame(this.animationWorker.bind(this));
                    } else {
                        this.lastAnimationTickAt = -1;
                    }
                }
                startAnimationIfNotRunning() {
                    if (this.lastAnimationTickAt !== -1) {
                        return;
                    }
                    this.lastAnimationTickAt = Date.now();
                    this.markerCurVelocity = 0;
                    this.animationWorker();
                }
                /// High level function to update the marker. It will animate the marker as
                /// appropriate.
                switchMarkerToSelectedName() {
                    let target = this.getMarkerTarget();
                    if (target === null) {
                        this.startAnimationIfNotRunning();
                        return;
                    }
                    if (this.markerCurFade === 0) {
                        this.markerCurLeft = target[0];
                        this.markerCurTop = target[1];
                        this.markerCurWidth = target[2];
                        this.markerCurHeight = target[3];
                        this.placeMarkerToState();
                    }
                    this.startAnimationIfNotRunning();
                }
                buildContent(deltaState) {
                    let result = document.createElement('div');
                    result.classList.add('rio-switcher-bar-options');
                    Object.assign(result.style, TEXT_STYLE_CSS_OPTIONS);
                    result.style.removeProperty('color');
                    let names = firstDefined(
                        deltaState.names,
                        this.state.names
                    );
                    let iconSvgSources = firstDefined(
                        deltaState.icon_svg_sources,
                        this.state.icon_svg_sources
                    );
                    for (let i = 0; i < names.length; i++) {
                        let name = names[i];
                        let iconSvg = iconSvgSources[i];
                        let optionElement = document.createElement('div');
                        optionElement.classList.add('rio-switcher-bar-option');
                        optionElement.style.padding = `${OPTION_MARGIN}rem`;
                        result.appendChild(optionElement);
                        let iconElement;
                        if (iconSvg !== null) {
                            optionElement.innerHTML = iconSvg;
                            iconElement = optionElement.children[0];
                            iconElement.style.width = `${ICON_HEIGHT}rem`;
                            iconElement.style.height = `${ICON_HEIGHT}rem`;
                            iconElement.style.marginBottom = `${ICON_MARGIN}rem`;
                            iconElement.style.fill = 'currentColor';
                        }
                        let textElement = document.createElement('div');
                        optionElement.appendChild(textElement);
                        textElement.textContent = name;
                        MDCRipple.attachTo(optionElement);
                        optionElement.addEventListener('click', (event) => {
                            if (this.state.selectedName === name) {
                                if (this.state.allow_none) {
                                    this.state.selectedName = null;
                                } else {
                                    return;
                                }
                            } else {
                                this.state.selectedName = name;
                            }
                            this.switchMarkerToSelectedName();
                            this.sendMessageToBackend({
                                name: this.state.selectedName,
                            });
                            event.stopPropagation();
                        });
                    }
                    if (this.state.orientation == 'horizontal') {
                        result.style.width = `${this.allocatedWidth}rem`;
                    } else {
                        result.style.height = `${this.allocatedHeight}rem`;
                    }
                    return result;
                }
                updateElement(deltaState, latentComponents) {
                    let markerPositionNeedsUpdate = false;
                    let needsReLayout = false;
                    if (
                        deltaState.names !== void 0 ||
                        deltaState.icon_svg_sources !== void 0
                    ) {
                        {
                            this.optionWidths = [];
                            this.optionHeights = [];
                            let names = firstDefined(
                                deltaState.names,
                                this.state.names
                            );
                            let iconSvgSources = firstDefined(
                                deltaState.icon_svg_sources,
                                this.state.icon_svg_sources
                            );
                            for (let i = 0; i < names.length; i++) {
                                let name = names[i];
                                let iconSvg = iconSvgSources[i];
                                let [width, height] = getTextDimensions(
                                    name,
                                    TEXT_STYLE
                                );
                                if (iconSvg !== null) {
                                    width = Math.max(width, ICON_HEIGHT);
                                    height += ICON_HEIGHT + ICON_MARGIN;
                                }
                                width += 2 * OPTION_MARGIN;
                                height += 2 * OPTION_MARGIN;
                                this.optionWidths.push(width);
                                this.optionHeights.push(height);
                            }
                        }
                        {
                            this.markerElement.innerHTML = '';
                            this.innerElement.innerHTML = '';
                            this.backgroundOptionsElement =
                                this.buildContent(deltaState);
                            this.innerElement.appendChild(
                                this.backgroundOptionsElement
                            );
                            this.innerElement.appendChild(this.markerElement);
                            this.markerOptionsElement =
                                this.buildContent(deltaState);
                            this.markerElement.appendChild(
                                this.markerOptionsElement
                            );
                        }
                        markerPositionNeedsUpdate = true;
                        needsReLayout = true;
                    }
                    if (deltaState.color !== void 0) {
                        applyColorSet(
                            this.markerElement,
                            deltaState.color === 'keep'
                                ? 'accent-to-plain'
                                : deltaState.color
                        );
                    }
                    if (deltaState.orientation !== void 0) {
                        let flexDirection =
                            deltaState.orientation == 'vertical'
                                ? 'column'
                                : 'row';
                        this.element.style.flexDirection = flexDirection;
                        this.backgroundOptionsElement.style.flexDirection =
                            flexDirection;
                        this.markerOptionsElement.style.flexDirection =
                            flexDirection;
                        markerPositionNeedsUpdate = true;
                        needsReLayout = true;
                    }
                    if (deltaState.spacing !== void 0) {
                        markerPositionNeedsUpdate = true;
                        needsReLayout = true;
                    }
                    if (deltaState.selectedName !== void 0) {
                        if (this.isInitialized) {
                            this.state.selectedName = deltaState.selectedName;
                            this.switchMarkerToSelectedName();
                        } else {
                            markerPositionNeedsUpdate = true;
                            this.markerCurFade =
                                deltaState.selectedName === null ? 0 : 1;
                        }
                    }
                    this.isInitialized = true;
                    Object.assign(this.state, deltaState);
                    if (markerPositionNeedsUpdate) {
                        this.moveMarkerInstantlyIfAnimationIsntRunning();
                    }
                    if (needsReLayout) {
                        this.makeLayoutDirty();
                    }
                }
                updateNaturalWidth(ctx) {
                    if (this.state.orientation == 'horizontal') {
                        this.naturalWidth =
                            this.state.spacing * (this.state.names.length - 1);
                        this.optionWidths.forEach((width) => {
                            this.naturalWidth += width;
                        });
                    } else {
                        this.naturalWidth = 0;
                        this.optionWidths.forEach((width) => {
                            this.naturalWidth = Math.max(
                                this.naturalWidth,
                                width
                            );
                        });
                    }
                }
                updateNaturalHeight(ctx) {
                    if (this.state.orientation == 'horizontal') {
                        this.naturalHeight = 0;
                        this.optionHeights.forEach((height) => {
                            this.naturalHeight = Math.max(
                                this.naturalHeight,
                                height
                            );
                        });
                    } else {
                        this.naturalHeight =
                            this.state.spacing * (this.state.names.length - 1);
                        this.optionHeights.forEach((height) => {
                            this.naturalHeight += height;
                        });
                    }
                }
                updateAllocatedHeight(ctx) {
                    let width, height;
                    if (this.state.orientation == 'horizontal') {
                        width = `${this.allocatedWidth}rem`;
                        height = '';
                    } else {
                        width = '';
                        height = `${this.allocatedHeight}rem`;
                    }
                    this.backgroundOptionsElement.style.width = width;
                    this.backgroundOptionsElement.style.height = height;
                    this.markerOptionsElement.style.width = width;
                    this.markerOptionsElement.style.height = height;
                    this.moveMarkerInstantlyIfAnimationIsntRunning();
                }
            }
            const TRANSITION_TIME = 0.35;
            class SwitcherComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.previousChildRequestedWidth = 0;
                    this.previousChildRequestedHeight = 0;
                    this.isDeterminingLayout = true;
                    this.animationStartedAt = -1;
                    this.activeChildInstance = null;
                    this.activeChildContainer = null;
                    this.isInitialized = false;
                    this.hasBeenLaidOut = false;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-switcher');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (
                        !this.isInitialized ||
                        (deltaState.content !== void 0 &&
                            deltaState.content !== this.state.content)
                    ) {
                        console.assert(deltaState.content !== void 0);
                        if (this.activeChildContainer !== null) {
                            this.replaceFirstChild(
                                latentComponents,
                                null,
                                this.activeChildContainer
                            );
                            this.activeChildContainer.remove();
                            this.activeChildContainer = null;
                            this.activeChildInstance = null;
                        }
                        if (deltaState.content === null) {
                            this.activeChildContainer = null;
                            this.activeChildInstance = null;
                        } else {
                            this.activeChildContainer =
                                document.createElement('div');
                            this.activeChildContainer.style.left = '0';
                            this.activeChildContainer.style.top = '0';
                            this.element.appendChild(this.activeChildContainer);
                            this.replaceFirstChild(
                                latentComponents,
                                deltaState.content,
                                this.activeChildContainer
                            );
                            this.activeChildInstance =
                                componentsById[deltaState.content];
                        }
                        this.makeLayoutDirty();
                    }
                    this.isInitialized = true;
                }
                startAnimationIfNotRunning() {
                    if (this.animationStartedAt !== -1) {
                        return;
                    }
                    this.animationStartedAt = Date.now();
                    requestAnimationFrame(() => {
                        this.makeLayoutDirty();
                        updateLayout();
                    });
                }
                updateNaturalWidth(ctx) {
                    let childRequestedWidth, childRequestedHeight;
                    if (this.activeChildInstance === null) {
                        childRequestedWidth = 0;
                        childRequestedHeight = 0;
                    } else {
                        childRequestedWidth =
                            this.activeChildInstance.requestedWidth;
                        childRequestedHeight =
                            this.activeChildInstance.requestedHeight;
                    }
                    if (
                        this.previousChildRequestedWidth !==
                            childRequestedWidth ||
                        this.previousChildRequestedHeight !==
                            childRequestedHeight
                    ) {
                        console.debug(
                            'Detected child size change, starting animation'
                        );
                        this.isDeterminingLayout = true;
                        this.previousChildRequestedWidth = childRequestedWidth;
                        this.previousChildRequestedHeight =
                            childRequestedHeight;
                    }
                    if (this.isDeterminingLayout) {
                        this.naturalWidth = childRequestedWidth;
                        return;
                    }
                    let now = Date.now();
                    let linearT = Math.min(
                        1,
                        (now - this.animationStartedAt) / 1e3 / TRANSITION_TIME
                    );
                    let easedT = easeInOut(linearT);
                    this.naturalWidth =
                        this.initialRequestedWidth +
                        easedT *
                            (childRequestedWidth - this.initialRequestedWidth);
                    this.naturalHeight =
                        this.initialRequestedHeight +
                        easedT *
                            (childRequestedHeight -
                                this.initialRequestedHeight);
                    if (linearT < 1) {
                        requestAnimationFrame(() => {
                            this.makeLayoutDirty();
                            updateLayout();
                        });
                    } else {
                        this.initialRequestedWidth = Math.max(
                            this.naturalWidth,
                            this.state._size_[0]
                        );
                        this.initialRequestedHeight = Math.max(
                            this.naturalHeight,
                            this.state._size_[1]
                        );
                        this.animationStartedAt = -1;
                    }
                }
                updateAllocatedWidth(ctx) {
                    if (this.isDeterminingLayout) {
                        if (this.activeChildInstance !== null) {
                            this.activeChildInstance.allocatedWidth =
                                this.allocatedWidth;
                        }
                        return;
                    }
                }
                updateNaturalHeight(ctx) {
                    if (this.isDeterminingLayout) {
                        this.naturalHeight =
                            this.activeChildInstance === null
                                ? 0
                                : this.activeChildInstance.requestedHeight;
                        return;
                    }
                }
                updateAllocatedHeight(ctx) {
                    if (this.isDeterminingLayout) {
                        if (this.activeChildInstance !== null) {
                            this.activeChildInstance.allocatedHeight =
                                this.allocatedHeight;
                        }
                        this.isDeterminingLayout = false;
                        if (!this.hasBeenLaidOut) {
                            this.hasBeenLaidOut = true;
                            this.initialRequestedWidth = this.allocatedWidth;
                            this.initialRequestedHeight = this.allocatedHeight;
                            return;
                        }
                        if (this.animationStartedAt === -1) {
                            this.animationStartedAt = Date.now();
                        }
                        ctx.requestImmediateReLayout(() => {
                            this.makeLayoutDirty();
                        });
                        return;
                    }
                }
            }
            class Column {
                constructor(name, values) {
                    this.name = name;
                    this.values = values;
                    this.dataType = this._determineDataType(values);
                    this.alignment =
                        this.dataType === 'number' ? 'right' : 'left';
                }
                _determineDataType(values) {
                    if (values.length === 0) {
                        return 'empty';
                    }
                    if (typeof values[0] === 'number') {
                        return 'number';
                    }
                    return 'text';
                }
            }
            function dataToColumns(data) {
                let columns = [];
                if (Array.isArray(data)) {
                    let numColumns = data.length === 0 ? 0 : data[0].length;
                    for (let i = 0; i < numColumns; i++) {
                        let values = data.map((row) => row[i]);
                        columns.push(new Column('', values));
                    }
                } else {
                    for (let [name, values] of Object.entries(data)) {
                        columns.push(new Column(name, values));
                    }
                }
                return columns;
            }
            class SortOrder {
                constructor() {
                    this.sortOrder = [];
                }
                add(columnName, ascending) {
                    this.sortOrder = this.sortOrder.filter(
                        (it) => it[0] !== columnName
                    );
                    this.sortOrder.unshift([columnName, ascending ? 1 : -1]);
                }
                sort(columns) {
                    if (columns.length === 0) {
                        return;
                    }
                    let valuesByColumnName = {};
                    for (let column of columns) {
                        valuesByColumnName[column.name] = column.values;
                    }
                    function cmp(i, j) {
                        for (let [columnName, multiplier] of this.sortOrder) {
                            let values = valuesByColumnName[columnName];
                            if (values === void 0) {
                                continue;
                            }
                            let a = values[i];
                            let b = values[j];
                            if (a < b) {
                                return -1 * multiplier;
                            } else if (a > b) {
                                return 1 * multiplier;
                            }
                        }
                        return 0;
                    }
                    let indices = [...columns[0].values.keys()];
                    indices.sort(cmp.bind(this));
                    for (let column of columns) {
                        column.values = indices.map((i) => column.values[i]);
                    }
                }
            }
            class TableComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.sortOrder = new SortOrder();
                    this.headerCells = [];
                    this.rowNumberCells = [];
                    this.dataCells = [];
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-table');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.data !== void 0) {
                        this.state.data = dataToColumns(deltaState.data);
                        this.displayData();
                        if (
                            deltaState.show_row_numbers ??
                            this.state.show_row_numbers
                        ) {
                            this.showRowNumbers();
                        }
                        if (Array.isArray(deltaState.data)) {
                            this.hideColumnHeaders();
                        } else {
                            this.showColumnHeaders();
                        }
                    } else if (
                        deltaState.show_row_numbers !== void 0 &&
                        deltaState.show_row_numbers !==
                            this.state.show_row_numbers
                    ) {
                        if (deltaState.show_row_numbers) {
                            this.showRowNumbers();
                        } else {
                            this.hideRowNumbers();
                        }
                    }
                    this.makeLayoutDirty();
                    [this.naturalWidth, this.naturalHeight] =
                        getElementDimensions(this.element);
                }
                // Natural size is set in updateElement
                updateNaturalWidth(ctx) {}
                updateNaturalHeight(ctx) {}
                displayData() {
                    for (let element2 of this.dataCells) {
                        element2.remove();
                    }
                    this.dataCells = [];
                    let columnNr = 2;
                    for (let column of this.state.data) {
                        for (let [rowNr, value] of column.values.entries()) {
                            let cell = document.createElement('span');
                            cell.textContent = `${value}`;
                            cell.style.textAlign = column.alignment;
                            cell.style.gridRow = `${rowNr + 2}`;
                            cell.style.gridColumn = `${columnNr}`;
                            this.element.appendChild(cell);
                            this.dataCells.push(cell);
                        }
                        columnNr++;
                    }
                }
                showRowNumbers() {
                    this.hideRowNumbers();
                    let numRows =
                        this.state.data.length === 0
                            ? 0
                            : this.state.data[0].values.length;
                    for (let i = 0; i < numRows; i++) {
                        let cell = document.createElement('span');
                        cell.textContent = `${i + 1}.`;
                        cell.style.textAlign = 'right';
                        cell.style.opacity = '0.5';
                        cell.style.gridRow = `${i + 2}`;
                        cell.style.gridColumn = '1';
                        this.element.appendChild(cell);
                        this.rowNumberCells.push(cell);
                    }
                }
                hideRowNumbers() {
                    for (let element2 of this.rowNumberCells) {
                        element2.remove();
                    }
                    this.rowNumberCells = [];
                }
                showColumnHeaders() {
                    this.hideColumnHeaders();
                    for (let [i, column] of this.state.data.entries()) {
                        let cell = document.createElement('span');
                        cell.classList.add('header');
                        cell.textContent = column.name;
                        cell.style.textAlign = column.alignment;
                        cell.style.opacity = '0.5';
                        cell.addEventListener(
                            'click',
                            this.onHeaderClick.bind(this, column.name)
                        );
                        cell.style.gridRow = '1';
                        cell.style.gridColumn = `${i + 2}`;
                        this.element.appendChild(cell);
                        this.headerCells.push(cell);
                    }
                }
                hideColumnHeaders() {
                    for (let element2 of this.headerCells) {
                        element2.remove();
                    }
                    this.headerCells = [];
                }
                onHeaderClick(columnName, event) {
                    let clickedHeader = event.target;
                    if (clickedHeader.tagName !== 'SPAN') {
                        clickedHeader = clickedHeader.parentElement;
                    }
                    let ascending = clickedHeader.dataset.sort !== 'ascending';
                    for (let cell of this.headerCells) {
                        delete cell.dataset.sort;
                    }
                    clickedHeader.dataset.sort = ascending
                        ? 'ascending'
                        : 'descending';
                    this.sortOrder.add(columnName, ascending);
                    this.sortOrder.sort(this.state.data);
                    this.displayData();
                    event.stopPropagation();
                }
            }
            class TextComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-text');
                    this.inner = document.createElement('div');
                    element2.appendChild(this.inner);
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.text !== void 0) {
                        this.inner.textContent = deltaState.text;
                    }
                    switch (deltaState.wrap) {
                        case false:
                            this.inner.style.whiteSpace = 'pre';
                            this.inner.style.textOverflow = 'clip';
                            break;
                        case true:
                            this.inner.style.whiteSpace = 'pre-wrap';
                            this.inner.style.textOverflow = 'clip';
                            break;
                        case 'ellipsize':
                            this.inner.style.whiteSpace = 'pre';
                            this.inner.style.textOverflow = 'ellipsis';
                            break;
                    }
                    if (deltaState.selectable !== void 0) {
                        this.inner.style.pointerEvents = deltaState.selectable
                            ? 'auto'
                            : 'none';
                    }
                    if (deltaState.style !== void 0) {
                        Object.assign(
                            this.inner.style,
                            textStyleToCss(deltaState.style)
                        );
                    }
                    if (deltaState.justify !== void 0) {
                        this.inner.style.textAlign = deltaState.justify;
                    }
                    if (
                        deltaState.text !== void 0 ||
                        deltaState.wrap !== void 0 ||
                        deltaState.style !== void 0
                    ) {
                        this.makeLayoutDirty();
                        this.cachedNoWrapDimensions = getTextDimensions(
                            this.element.textContent,
                            this.state.style
                        );
                    }
                }
                updateNaturalWidth(ctx) {
                    if (this.state.wrap === false) {
                        this.naturalWidth = this.cachedNoWrapDimensions[0];
                    } else {
                        this.naturalWidth = 0;
                    }
                }
                updateNaturalHeight(ctx) {
                    if (this.state.wrap === true) {
                        this.naturalHeight = getTextDimensions(
                            this.state.text,
                            this.state.style,
                            this.allocatedWidth
                        )[1];
                    } else {
                        this.naturalHeight = this.cachedNoWrapDimensions[1];
                    }
                }
            }
            class TextInputComponent extends ComponentBase {
                constructor() {
                    super(...arguments);
                    this.prefixTextWidth = 0;
                    this.suffixTextWidth = 0;
                }
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add(
                        'rio-text-input',
                        'rio-input-box',
                        'mdc-ripple-surface'
                    );
                    element2.innerHTML = `
            <input type="text" style="order: 2" placeholder="">
            <div class="rio-text-input-hint-text rio-text-input-prefix-text" style="order: 1"></div>
            <div class="rio-text-input-hint-text rio-text-input-suffix-text" style="order: 3"></div>
            <div class="rio-input-box-label"></div>
            <div class="rio-input-box-plain-bar"></div>
            <div class="rio-input-box-color-bar"></div>
        `;
                    this.labelElement = element2.querySelector(
                        '.rio-input-box-label'
                    );
                    [this.prefixTextElement, this.suffixTextElement] =
                        Array.from(
                            element2.querySelectorAll(
                                '.rio-text-input-hint-text'
                            )
                        );
                    this.inputElement = element2.querySelector('input');
                    this.inputElement.addEventListener('blur', () => {
                        this.setStateAndNotifyBackend({
                            text: this.inputElement.value,
                        });
                    });
                    this.inputElement.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter') {
                            this.state.text = this.inputElement.value;
                            this.sendMessageToBackend({
                                text: this.state.text,
                            });
                        }
                        event.stopPropagation();
                    });
                    this.prefixTextElement.addEventListener(
                        'mousedown',
                        (event) => {
                            event.stopPropagation();
                        }
                    );
                    this.suffixTextElement.addEventListener(
                        'mousedown',
                        (event) => {
                            event.stopPropagation();
                        }
                    );
                    this.prefixTextElement.addEventListener(
                        'click',
                        (event) => {
                            this.inputElement.focus();
                            this.inputElement.setSelectionRange(0, 0);
                            event.stopPropagation();
                        }
                    );
                    this.suffixTextElement.addEventListener(
                        'click',
                        (event) => {
                            this.inputElement.focus();
                            this.inputElement.setSelectionRange(
                                this.inputElement.value.length,
                                this.inputElement.value.length
                            );
                            event.stopPropagation();
                        }
                    );
                    this.inputElement.addEventListener('mousedown', (event) => {
                        event.stopPropagation();
                    });
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.text !== void 0) {
                        this.inputElement.value = deltaState.text;
                    }
                    if (deltaState.label !== void 0) {
                        this.labelElement.textContent = deltaState.label;
                        updateInputBoxNaturalHeight(this, deltaState.label, 0);
                    }
                    if (deltaState.prefix_text === '') {
                        this.prefixTextElement.style.display = 'none';
                        this.prefixTextWidth = 0;
                        this.inputElement.style.paddingLeft = `${HORIZONTAL_PADDING}rem`;
                        this.makeLayoutDirty();
                    } else if (deltaState.prefix_text !== void 0) {
                        this.prefixTextElement.textContent =
                            deltaState.prefix_text;
                        this.prefixTextElement.style.removeProperty('display');
                        this.inputElement.style.removeProperty('padding-left');
                        this.prefixTextWidth =
                            getTextDimensions(
                                deltaState.prefix_text,
                                'text'
                            )[0] + 0.2;
                        this.makeLayoutDirty();
                    }
                    if (deltaState.suffix_text === '') {
                        this.suffixTextElement.style.display = 'none';
                        this.suffixTextWidth = 0;
                        this.inputElement.style.paddingRight = `${HORIZONTAL_PADDING}rem`;
                        this.makeLayoutDirty();
                    } else if (deltaState.suffix_text !== void 0) {
                        this.suffixTextElement.textContent =
                            deltaState.suffix_text;
                        this.suffixTextElement.style.removeProperty('display');
                        this.inputElement.style.removeProperty('padding-right');
                        this.suffixTextWidth =
                            getTextDimensions(
                                deltaState.suffix_text,
                                'text'
                            )[0] + 0.2;
                        this.makeLayoutDirty();
                    }
                    if (deltaState.is_secret !== void 0) {
                        this.inputElement.type = deltaState.is_secret
                            ? 'password'
                            : 'text';
                    }
                    if (deltaState.is_sensitive === true) {
                        this.inputElement.disabled = false;
                        this.element.classList.remove('rio-disabled-input');
                    } else if (deltaState.is_sensitive === false) {
                        this.inputElement.disabled = true;
                        this.element.classList.add('rio-disabled-input');
                    }
                    if (deltaState.is_valid === false) {
                        this.element.style.setProperty(
                            '--rio-local-text-color',
                            'var(--rio-global-danger-bg)'
                        );
                    } else if (deltaState.is_valid === true) {
                        this.element.style.removeProperty(
                            '--rio-local-text-color'
                        );
                    }
                }
                grabKeyboardFocus() {
                    this.inputElement.focus();
                }
                updateNaturalWidth(ctx) {
                    updateInputBoxNaturalWidth(
                        this,
                        this.prefixTextWidth + this.suffixTextWidth
                    );
                }
                updateNaturalHeight(ctx) {}
            }
            class ThemeContextSwitcherComponent extends SingleContainer {
                createElement() {
                    let element2 = document.createElement('div');
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    this.replaceFirstChild(
                        latentComponents,
                        deltaState.content
                    );
                    if (deltaState.color !== void 0) {
                        applyColorSet(this.element, deltaState.color);
                    }
                }
            }
            class TooltipComponent extends ComponentBase {
                createElement() {
                    let element2 = document.createElement('div');
                    element2.classList.add('rio-tooltip');
                    element2.innerHTML = `
            <div class="rio-tooltip-anchor"></div>
            <div class="rio-tooltip-label rio-switcheroo-hud"></div>
        `;
                    this.anchorContainer = element2.querySelector(
                        '.rio-tooltip-anchor'
                    );
                    this.labelElement =
                        element2.querySelector('.rio-tooltip-label');
                    this.anchorContainer.addEventListener('mouseover', () => {
                        this.labelElement.style.opacity = '1';
                    });
                    this.anchorContainer.addEventListener('mouseout', () => {
                        this.labelElement.style.opacity = '0';
                    });
                    return element2;
                }
                updateElement(deltaState, latentComponents) {
                    if (deltaState.anchor !== void 0) {
                        this.replaceFirstChild(
                            latentComponents,
                            deltaState.anchor,
                            this.anchorContainer
                        );
                    }
                    if (deltaState.tip_component !== void 0) {
                        this.replaceFirstChild(
                            latentComponents,
                            deltaState.tip_component,
                            this.labelElement
                        );
                    }
                    if (deltaState.position !== void 0) {
                        let left, top, right, bottom, transform;
                        const theOne = 'calc(100% + 0.5rem)';
                        if (deltaState.position === 'left') {
                            left = 'unset';
                            top = '50%';
                            right = theOne;
                            bottom = 'unset';
                            transform = 'translateY(-50%)';
                        } else if (deltaState.position === 'top') {
                            left = '50%';
                            top = 'unset';
                            right = 'unset';
                            bottom = theOne;
                            transform = 'translateX(-50%)';
                        } else if (deltaState.position === 'right') {
                            left = theOne;
                            top = '50%';
                            right = 'unset';
                            bottom = 'unset';
                            transform = 'translateY(-50%)';
                        } else {
                            left = '50%';
                            top = theOne;
                            right = 'unset';
                            bottom = 'unset';
                            transform = 'translateX(-50%)';
                        }
                        this.labelElement.style.left = left;
                        this.labelElement.style.top = top;
                        this.labelElement.style.right = right;
                        this.labelElement.style.bottom = bottom;
                        this.labelElement.style.transform = transform;
                    }
                }
                updateNaturalWidth(ctx) {
                    this.naturalWidth =
                        componentsById[this.state.anchor].requestedWidth;
                }
                updateAllocatedWidth(ctx) {
                    let anchor = componentsById[this.state.anchor];
                    let tip = componentsById[this.state.tip_component];
                    anchor.allocatedWidth = this.allocatedWidth;
                    tip.allocatedWidth = tip.naturalWidth;
                }
                updateNaturalHeight(ctx) {
                    this.naturalHeight =
                        componentsById[this.state.anchor].requestedHeight;
                }
                updateAllocatedHeight(ctx) {
                    let anchor = componentsById[this.state.anchor];
                    let tip = componentsById[this.state.tip_component];
                    anchor.allocatedHeight = this.allocatedHeight;
                    tip.allocatedHeight = tip.naturalHeight;
                    anchor.element.style.left = '0';
                    anchor.element.style.top = '0';
                    tip.element.style.left = '0';
                    tip.element.style.top = '0';
                }
            }
            const COMPONENT_CLASSES = {
                'Align-builtin': AlignComponent,
                'BuildFailed-builtin': BuildFailedComponent,
                'Button-builtin': ButtonComponent,
                'Card-builtin': CardComponent,
                'ClassContainer-builtin': ClassContainerComponent,
                'CodeExplorer-builtin': CodeExplorerComponent,
                'ColorPicker-builtin': ColorPickerComponent,
                'Column-builtin': ColumnComponent,
                'ComponentTree-builtin': ComponentTreeComponent,
                'CustomListItem-builtin': CustomListItemComponent,
                'DebuggerConnector-builtin': DebuggerConnectorComponent,
                'Drawer-builtin': DrawerComponent,
                'Dropdown-builtin': DropdownComponent,
                'FlowContainer-builtin': FlowComponent,
                'FundamentalRootComponent-builtin': FundamentalRootComponent,
                'Grid-builtin': GridComponent,
                'HeadingListItem-builtin': HeadingListItemComponent,
                'Html-builtin': HtmlComponent,
                'Icon-builtin': IconComponent,
                'Image-builtin': ImageComponent,
                'KeyEventListener-builtin': KeyEventListenerComponent,
                'Link-builtin': LinkComponent,
                'ListView-builtin': ListViewComponent,
                'Margin-builtin': MarginComponent,
                'Markdown-builtin': MarkdownComponent,
                'MediaPlayer-builtin': MediaPlayerComponent,
                'MouseEventListener-builtin': MouseEventListenerComponent,
                'MultiLineTextInput-builtin': MultiLineTextInputComponent,
                'NodeInput-builtin': NodeInputComponent,
                'NodeOutput-builtin': NodeOutputComponent,
                'Overlay-builtin': OverlayComponent,
                'Plot-builtin': PlotComponent,
                'Popup-builtin': PopupComponent,
                'ProgressBar-builtin': ProgressBarComponent,
                'ProgressCircle-builtin': ProgressCircleComponent,
                'Rectangle-builtin': RectangleComponent,
                'Revealer-builtin': RevealerComponent,
                'Row-builtin': RowComponent,
                'ScrollContainer-builtin': ScrollContainerComponent,
                'ScrollTarget-builtin': ScrollTargetComponent,
                'Separator-builtin': SeparatorComponent,
                'SeparatorListItem-builtin': SeparatorListItemComponent,
                'Slider-builtin': SliderComponent,
                'Slideshow-builtin': SlideshowComponent,
                'Stack-builtin': StackComponent,
                'Switch-builtin': SwitchComponent,
                'Switcher-builtin': SwitcherComponent,
                'SwitcherBar-builtin': SwitcherBarComponent,
                'Table-builtin': TableComponent,
                'Text-builtin': TextComponent,
                'TextInput-builtin': TextInputComponent,
                'ThemeContextSwitcher-builtin': ThemeContextSwitcherComponent,
                'Tooltip-builtin': TooltipComponent,
                Placeholder: PlaceholderComponent,
            };
            globalThis.COMPONENT_CLASSES = COMPONENT_CLASSES;
            const componentsById = {};
            const componentsByElement = /* @__PURE__ */ new Map();
            function getRootComponent() {
                let element2 = document.body.querySelector(
                    '.rio-fundamental-root-component'
                );
                console.assert(
                    element2 !== null,
                    "Couldn't find the root component in the document body"
                );
                return componentsByElement.get(element2);
            }
            function getRootScroller() {
                let rootComponent = getRootComponent();
                return componentsById[rootComponent.state.content];
            }
            globalThis.getRootScroller = getRootScroller;
            function getComponentByElement(element2) {
                let instance = tryGetComponentByElement(element2);
                if (instance === null) {
                    let elem = element2.parentElement;
                    while (elem) {
                        instance = tryGetComponentByElement(elem);
                        if (instance !== null) {
                            throw `Element ${reprElement(
                                element2
                            )} does not correspond to a component. It is a child element of ${instance.toString()}`;
                        }
                        elem = elem.parentElement;
                    }
                    throw `Element ${reprElement(
                        element2
                    )} does not correspond to a component (and none of its parent elements correspond to a component, either)`;
                }
                return instance;
            }
            globalThis.componentsById = componentsById;
            globalThis.getInstanceByElement = getComponentByElement;
            function tryGetComponentByElement(element2) {
                return componentsByElement.get(element2) ?? null;
            }
            function isComponentElement(element2) {
                return componentsByElement.has(element2);
            }
            function getCurrentComponentState(id, deltaState) {
                let instance = componentsById[id];
                if (instance === void 0) {
                    return deltaState;
                }
                return {
                    ...instance.state,
                    ...deltaState,
                };
            }
            function createLayoutComponentStates(componentId, message) {
                let deltaState = message[componentId] || {};
                let entireState = getCurrentComponentState(
                    componentId,
                    deltaState
                );
                let resultId = componentId;
                let margin = entireState['_margin_'];
                if (margin === void 0) {
                    console.error(
                        `Got incomplete state for component ${componentId}`
                    );
                }
                if (
                    margin[0] !== 0 ||
                    margin[1] !== 0 ||
                    margin[2] !== 0 ||
                    margin[3] !== 0
                ) {
                    let marginId = componentId * -10;
                    message[marginId] = {
                        _type_: 'Margin-builtin',
                        _python_type_: 'Margin (injected)',
                        _key_: null,
                        _margin_: [0, 0, 0, 0],
                        _size_: [0, 0],
                        _grow_: entireState['_grow_'],
                        _rio_internal_: true,
                        // @ts-ignore
                        content: resultId,
                        margin_left: margin[0],
                        margin_top: margin[1],
                        margin_right: margin[2],
                        margin_bottom: margin[3],
                    };
                    resultId = marginId;
                }
                let align = entireState['_align_'];
                if (align === void 0) {
                    console.error(
                        `Got incomplete state for component ${componentId}`
                    );
                }
                if (align[0] !== null || align[1] !== null) {
                    let alignId = componentId * -10 - 1;
                    message[alignId] = {
                        _type_: 'Align-builtin',
                        _python_type_: 'Align (injected)',
                        _key_: null,
                        _margin_: [0, 0, 0, 0],
                        _size_: entireState['_size_'],
                        _grow_: entireState['_grow_'],
                        _rio_internal_: true,
                        // @ts-ignore
                        content: resultId,
                        align_x: align[0],
                        align_y: align[1],
                    };
                    resultId = alignId;
                }
                return resultId;
            }
            function replaceChildrenWithLayoutComponents(
                deltaState,
                childIds,
                message
            ) {
                let propertyNamesWithChildren =
                    globalThis.CHILD_ATTRIBUTE_NAMES[deltaState['_type_']] ||
                    [];
                function uninjectedId(id) {
                    if (id >= 0) {
                        return id;
                    }
                    return Math.floor(id / -10);
                }
                for (let propertyName of propertyNamesWithChildren) {
                    let propertyValue = deltaState[propertyName];
                    if (Array.isArray(propertyValue)) {
                        deltaState[propertyName] = propertyValue.map(
                            (childId) => {
                                childId = uninjectedId(childId);
                                childIds.add(childId);
                                return createLayoutComponentStates(
                                    childId,
                                    message
                                );
                            }
                        );
                    } else if (
                        propertyValue !== null &&
                        propertyValue !== void 0
                    ) {
                        let childId = uninjectedId(propertyValue);
                        deltaState[propertyName] = createLayoutComponentStates(
                            childId,
                            message
                        );
                        childIds.add(childId);
                    }
                }
            }
            function preprocessDeltaStates(message) {
                let originalComponentIds = Object.keys(message).map((id) =>
                    parseInt(id)
                );
                let childIds = /* @__PURE__ */ new Set();
                for (let componentId of originalComponentIds) {
                    replaceChildrenWithLayoutComponents(
                        message[componentId],
                        childIds,
                        message
                    );
                }
                for (let componentId of originalComponentIds) {
                    if (childIds.has(componentId)) {
                        continue;
                    }
                    let child = componentsById[componentId];
                    if (child === void 0) {
                        continue;
                    }
                    let parent = child.getParentExcludingInjected();
                    if (parent === null) {
                        continue;
                    }
                    let newParentState = { ...parent.state };
                    replaceChildrenWithLayoutComponents(
                        newParentState,
                        childIds,
                        message
                    );
                    message[parent.id] = newParentState;
                }
            }
            function updateComponentStates(deltaStates, rootComponentId) {
                preprocessDeltaStates(deltaStates);
                let focusedElement = document.activeElement;
                while (
                    focusedElement !== null &&
                    !isComponentElement(focusedElement)
                ) {
                    focusedElement = focusedElement.parentElement;
                }
                let focusedComponent =
                    focusedElement === null
                        ? null
                        : getComponentByElement(focusedElement);
                let latentComponents = /* @__PURE__ */ new Set();
                for (let componentIdAsString in deltaStates) {
                    let deltaState = deltaStates[componentIdAsString];
                    let component = componentsById[componentIdAsString];
                    if (component) {
                        continue;
                    }
                    const componentClass = COMPONENT_CLASSES[deltaState._type_];
                    if (!componentClass) {
                        throw `Encountered unknown component type: ${deltaState._type_}`;
                    }
                    let newComponent = new componentClass(
                        parseInt(componentIdAsString),
                        deltaState
                    );
                    componentsById[componentIdAsString] = newComponent;
                    componentsByElement.set(newComponent.element, newComponent);
                    newComponent.element.setAttribute(
                        'dbg-py-class',
                        deltaState._python_type_
                    );
                    newComponent.element.setAttribute(
                        'dbg-id',
                        componentIdAsString
                    );
                    let key = deltaState['key'];
                    if (key !== void 0) {
                        newComponent.element.setAttribute('dbg-key', `${key}`);
                    }
                }
                for (let id in deltaStates) {
                    let deltaState = deltaStates[id];
                    let component = componentsById[id];
                    component.updateElement(deltaState, latentComponents);
                    let width_changed =
                        Math.abs(
                            deltaState._size_[0] - component.state._size_[0]
                        ) > 1e-6;
                    let height_changed =
                        Math.abs(
                            deltaState._size_[1] - component.state._size_[1]
                        ) > 1e-6;
                    if (width_changed || height_changed) {
                        console.log(
                            `Triggering re-layout because component #${id} changed size: ${component.state._size_} -> ${deltaState._size_}`
                        );
                        component.makeLayoutDirty();
                    }
                    component.state = {
                        ...component.state,
                        ...deltaState,
                    };
                }
                if (rootComponentId !== null) {
                    let rootElement = componentsById[rootComponentId].element;
                    document.body.appendChild(rootElement);
                }
                if (focusedComponent !== null) {
                    restoreKeyboardFocus(focusedComponent, latentComponents);
                }
                for (let component of latentComponents) {
                    let queue = [component];
                    for (let comp of queue) {
                        queue.push(...comp.children);
                        comp.onDestruction();
                        delete componentsById[comp.id];
                        componentsByElement.delete(comp.element);
                    }
                }
                updateLayout();
            }
            function canHaveKeyboardFocus(instance) {
                return typeof instance.grabKeyboardFocus === 'function';
            }
            function restoreKeyboardFocus(focusedComponent, latentComponents) {
                let rootComponent = getRootComponent();
                let current = focusedComponent;
                let winner = null;
                while (current !== rootComponent) {
                    if (latentComponents.has(current)) {
                        winner = null;
                    } else if (
                        winner === null &&
                        canHaveKeyboardFocus(current)
                    ) {
                        winner = current;
                    }
                    current = current.parent;
                }
                if (winner !== null) {
                    winner.grabKeyboardFocus();
                }
            }
            globalThis.SESSION_TOKEN = '{session_token}';
            globalThis.PING_PONG_INTERVAL_SECONDS = '{ping_pong_interval}';
            globalThis.RIO_DEBUG_MODE = '{debug_mode}';
            globalThis.CHILD_ATTRIBUTE_NAMES = '{child_attribute_names}';
            globalThis.RUNNING_IN_WINDOW = '{running_in_window}';
            globalThis.RIO_DEBUGGER = null;
            let goingAway = false;
            function getScrollBarWidthInPixels() {
                let outer = document.createElement('div');
                outer.style.position = 'absolute';
                outer.style.top = '0px';
                outer.style.left = '0px';
                outer.style.visibility = 'hidden';
                outer.style.width = '200px';
                outer.style.height = '150px';
                outer.style.overflow = 'hidden';
                let inner = document.createElement('p');
                inner.style.width = '100%';
                inner.style.height = '200px';
                outer.appendChild(inner);
                document.body.appendChild(outer);
                let w1 = inner.offsetWidth;
                outer.style.overflow = 'scroll';
                let w2 = inner.offsetWidth;
                if (w1 == w2) w2 = outer.clientWidth;
                document.body.removeChild(outer);
                return w1 - w2;
            }
            const SCROLL_BAR_SIZE_IN_PIXELS = getScrollBarWidthInPixels();
            let pixelsPerRem = 16;
            let scrollBarSize = SCROLL_BAR_SIZE_IN_PIXELS / pixelsPerRem;
            function main() {
                if (globalThis.RIO_DEBUG_MODE) {
                    console.warn(
                        'Rio is running in DEBUG mode.\nDebug mode includes helpful tools for development, but is slower and disables some safety checks. Never use it in production!'
                    );
                }
                var measure = document.createElement('div');
                measure.style.height = '10rem';
                document.body.appendChild(measure);
                pixelsPerRem = measure.offsetHeight / 10;
                scrollBarSize = SCROLL_BAR_SIZE_IN_PIXELS / pixelsPerRem;
                document.body.removeChild(measure);
                globalThis.pixelsPerRem = pixelsPerRem;
                globalThis.scrollBarSize = scrollBarSize;
                window.addEventListener('beforeunload', () => {
                    goingAway = true;
                });
                window.addEventListener('popstate', (event) => {
                    console.log(`URL changed to ${window.location.href}`);
                    callRemoteMethodDiscardResponse('onUrlChange', {
                        newUrl: window.location.href.toString(),
                    });
                });
                window.addEventListener('resize', (event) => {
                    try {
                        callRemoteMethodDiscardResponse('onWindowResize', {
                            newWidth: window.innerWidth / pixelsPerRem,
                            newHeight: window.innerHeight / pixelsPerRem,
                        });
                    } catch (e) {
                        console.warn(
                            `Couldn't notify backend of window resize: ${e}`
                        );
                    }
                    let rootElement = document.body.querySelector(
                        '.rio-fundamental-root-component'
                    );
                    if (rootElement !== null) {
                        let rootInstance = getComponentByElement(rootElement);
                        rootInstance.makeLayoutDirty();
                        updateLayout();
                    }
                });
                initWebsocket();
            }
            main();
        </script>
        <style>
            @charset "UTF-8";
            .mdc-floating-label {
                -moz-osx-font-smoothing: grayscale;
                -webkit-font-smoothing: antialiased;
                font-family: Roboto, sans-serif;
                /* @alternate */
                font-family: var(
                    --mdc-typography-subtitle1-font-family,
                    var(--mdc-typography-font-family, Roboto, sans-serif)
                );
                font-size: 1rem;
                /* @alternate */
                font-size: var(--mdc-typography-subtitle1-font-size, 1rem);
                font-weight: 400;
                /* @alternate */
                font-weight: var(--mdc-typography-subtitle1-font-weight, 400);
                letter-spacing: 0.009375em;
                /* @alternate */
                letter-spacing: var(
                    --mdc-typography-subtitle1-letter-spacing,
                    0.009375em
                );
                text-decoration: inherit;
                /* @alternate */
                text-decoration: var(
                    --mdc-typography-subtitle1-text-decoration,
                    inherit
                );
                text-transform: inherit;
                /* @alternate */
                text-transform: var(
                    --mdc-typography-subtitle1-text-transform,
                    inherit
                );
                position: absolute;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                /* @noflip */ /*rtl:ignore*/
                -webkit-transform-origin: left top;
                /* @noflip */ /*rtl:ignore*/
                transform-origin: left top;
                line-height: 1.15rem;
                text-align: left;
                text-overflow: ellipsis;
                white-space: nowrap;
                cursor: text;
                overflow: hidden;
                /* @alternate */
                will-change: transform;
                transition:
                    transform 150ms cubic-bezier(0.4, 0, 0.2, 1),
                    color 150ms cubic-bezier(0.4, 0, 0.2, 1);
            }
            [dir='rtl'] .mdc-floating-label,
            .mdc-floating-label[dir='rtl'] {
                /*rtl:begin:ignore*/
                /* @noflip */ /*rtl:ignore*/
                right: 0;
                /* @noflip */ /*rtl:ignore*/
                left: auto;
                /* @noflip */ /*rtl:ignore*/
                -webkit-transform-origin: right top;
                /* @noflip */ /*rtl:ignore*/
                transform-origin: right top;
                /* @noflip */ /*rtl:ignore*/
                text-align: right;
                /*rtl:end:ignore*/
            }

            .mdc-floating-label--float-above {
                cursor: auto;
            }

            .mdc-floating-label--required::after {
                /* @noflip */ /*rtl:ignore*/
                margin-left: 1px;
                /* @noflip */ /*rtl:ignore*/
                margin-right: 0px;
                content: '*';
            }
            [dir='rtl'] .mdc-floating-label--required,
            .mdc-floating-label--required[dir='rtl'] {
                /*rtl:begin:ignore*/
                /*rtl:end:ignore*/
            }
            [dir='rtl'] .mdc-floating-label--required::after,
            .mdc-floating-label--required[dir='rtl']::after {
                /* @noflip */ /*rtl:ignore*/
                margin-left: 0;
                /* @noflip */ /*rtl:ignore*/
                margin-right: 1px;
            }

            .mdc-floating-label--float-above {
                transform: translateY(-106%) scale(0.75);
            }

            .mdc-floating-label--shake {
                animation: mdc-floating-label-shake-float-above-standard 250ms 1;
            }

            @keyframes mdc-floating-label-shake-float-above-standard {
                0% {
                    /* @noflip */ /*rtl:ignore*/
                    transform: translateX(calc(0 - 0%)) translateY(-106%)
                        scale(0.75);
                }
                33% {
                    animation-timing-function: cubic-bezier(
                        0.5,
                        0,
                        0.701732,
                        0.495819
                    );
                    /* @noflip */ /*rtl:ignore*/
                    transform: translateX(calc(4% - 0%)) translateY(-106%)
                        scale(0.75);
                }
                66% {
                    animation-timing-function: cubic-bezier(
                        0.302435,
                        0.381352,
                        0.55,
                        0.956352
                    );
                    /* @noflip */ /*rtl:ignore*/
                    transform: translateX(calc(-4% - 0%)) translateY(-106%)
                        scale(0.75);
                }
                100% {
                    /* @noflip */ /*rtl:ignore*/
                    transform: translateX(calc(0 - 0%)) translateY(-106%)
                        scale(0.75);
                }
            }
            .mdc-line-ripple::before,
            .mdc-line-ripple::after {
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                border-bottom-style: solid;
                content: '';
            }
            .mdc-line-ripple::before {
                border-bottom-width: 1px;
            }
            .mdc-line-ripple::before {
                z-index: 1;
            }
            .mdc-line-ripple::after {
                transform: scaleX(0);
                border-bottom-width: 2px;
                opacity: 0;
                z-index: 2;
            }
            .mdc-line-ripple::after {
                transition:
                    transform 180ms cubic-bezier(0.4, 0, 0.2, 1),
                    opacity 180ms cubic-bezier(0.4, 0, 0.2, 1);
            }

            .mdc-line-ripple--active::after {
                transform: scaleX(1);
                opacity: 1;
            }

            .mdc-line-ripple--deactivating::after {
                opacity: 0;
            }

            .mdc-notched-outline {
                display: flex;
                position: absolute;
                top: 0;
                right: 0;
                left: 0;
                box-sizing: border-box;
                width: 100%;
                max-width: 100%;
                height: 100%;
                /* @noflip */ /*rtl:ignore*/
                text-align: left;
                pointer-events: none;
            }
            [dir='rtl'] .mdc-notched-outline,
            .mdc-notched-outline[dir='rtl'] {
                /*rtl:begin:ignore*/
                /* @noflip */ /*rtl:ignore*/
                text-align: right;
                /*rtl:end:ignore*/
            }

            .mdc-notched-outline__leading,
            .mdc-notched-outline__notch,
            .mdc-notched-outline__trailing {
                box-sizing: border-box;
                height: 100%;
                border-top: 1px solid;
                border-bottom: 1px solid;
                pointer-events: none;
            }
            .mdc-notched-outline__leading {
                /* @noflip */ /*rtl:ignore*/
                border-left: 1px solid;
                /* @noflip */ /*rtl:ignore*/
                border-right: none;
                width: 12px;
            }
            [dir='rtl'] .mdc-notched-outline__leading,
            .mdc-notched-outline__leading[dir='rtl'] {
                /*rtl:begin:ignore*/
                /* @noflip */ /*rtl:ignore*/
                border-left: none;
                /* @noflip */ /*rtl:ignore*/
                border-right: 1px solid;
                /*rtl:end:ignore*/
            }

            .mdc-notched-outline__trailing {
                /* @noflip */ /*rtl:ignore*/
                border-left: none;
                /* @noflip */ /*rtl:ignore*/
                border-right: 1px solid;
                flex-grow: 1;
            }
            [dir='rtl'] .mdc-notched-outline__trailing,
            .mdc-notched-outline__trailing[dir='rtl'] {
                /*rtl:begin:ignore*/
                /* @noflip */ /*rtl:ignore*/
                border-left: 1px solid;
                /* @noflip */ /*rtl:ignore*/
                border-right: none;
                /*rtl:end:ignore*/
            }

            .mdc-notched-outline__notch {
                flex: 0 0 auto;
                width: auto;
                max-width: calc(100% - 12px * 2);
            }
            .mdc-notched-outline .mdc-floating-label {
                display: inline-block;
                position: relative;
                max-width: 100%;
            }
            .mdc-notched-outline .mdc-floating-label--float-above {
                text-overflow: clip;
            }
            .mdc-notched-outline--upgraded .mdc-floating-label--float-above {
                max-width: 133.3333333333%;
            }

            .mdc-notched-outline--notched .mdc-notched-outline__notch {
                /* @noflip */ /*rtl:ignore*/
                padding-left: 0;
                /* @noflip */ /*rtl:ignore*/
                padding-right: 8px;
                border-top: none;
            }
            [dir='rtl']
                .mdc-notched-outline--notched
                .mdc-notched-outline__notch,
            .mdc-notched-outline--notched
                .mdc-notched-outline__notch[dir='rtl'] {
                /*rtl:begin:ignore*/
                /* @noflip */ /*rtl:ignore*/
                padding-left: 8px;
                /* @noflip */ /*rtl:ignore*/
                padding-right: 0;
                /*rtl:end:ignore*/
            }

            .mdc-notched-outline--no-label .mdc-notched-outline__notch {
                display: none;
            }

            @keyframes mdc-ripple-fg-radius-in {
                from {
                    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
                    transform: translate(
                            var(--mdc-ripple-fg-translate-start, 0)
                        )
                        scale(1);
                }
                to {
                    transform: translate(var(--mdc-ripple-fg-translate-end, 0))
                        scale(var(--mdc-ripple-fg-scale, 1));
                }
            }
            @keyframes mdc-ripple-fg-opacity-in {
                from {
                    animation-timing-function: linear;
                    opacity: 0;
                }
                to {
                    opacity: var(--mdc-ripple-fg-opacity, 0);
                }
            }
            @keyframes mdc-ripple-fg-opacity-out {
                from {
                    animation-timing-function: linear;
                    opacity: var(--mdc-ripple-fg-opacity, 0);
                }
                to {
                    opacity: 0;
                }
            }
            .mdc-slider__thumb {
                --mdc-ripple-fg-size: 0;
                --mdc-ripple-left: 0;
                --mdc-ripple-top: 0;
                --mdc-ripple-fg-scale: 1;
                --mdc-ripple-fg-translate-end: 0;
                --mdc-ripple-fg-translate-start: 0;
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                will-change: transform, opacity;
            }
            .mdc-slider__thumb::before,
            .mdc-slider__thumb::after {
                position: absolute;
                border-radius: 50%;
                opacity: 0;
                pointer-events: none;
                content: '';
            }
            .mdc-slider__thumb::before {
                transition:
                    opacity 15ms linear,
                    background-color 15ms linear;
                z-index: 1;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 1);
            }
            .mdc-slider__thumb::after {
                z-index: 0;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 0);
            }
            .mdc-slider__thumb.mdc-ripple-upgraded::before {
                transform: scale(var(--mdc-ripple-fg-scale, 1));
            }
            .mdc-slider__thumb.mdc-ripple-upgraded::after {
                top: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                transform: scale(0);
                transform-origin: center center;
            }
            .mdc-slider__thumb.mdc-ripple-upgraded--unbounded::after {
                top: var(--mdc-ripple-top, 0);
                /* @noflip */ /*rtl:ignore*/
                left: var(--mdc-ripple-left, 0);
            }
            .mdc-slider__thumb.mdc-ripple-upgraded--foreground-activation::after {
                animation:
                    mdc-ripple-fg-radius-in 225ms forwards,
                    mdc-ripple-fg-opacity-in 75ms forwards;
            }
            .mdc-slider__thumb.mdc-ripple-upgraded--foreground-deactivation::after {
                animation: mdc-ripple-fg-opacity-out 150ms;
                transform: translate(var(--mdc-ripple-fg-translate-end, 0))
                    scale(var(--mdc-ripple-fg-scale, 1));
            }
            .mdc-slider__thumb::before,
            .mdc-slider__thumb::after {
                top: calc(50% - 50%);
                /* @noflip */ /*rtl:ignore*/
                left: calc(50% - 50%);
                width: 100%;
                height: 100%;
            }
            .mdc-slider__thumb.mdc-ripple-upgraded::before,
            .mdc-slider__thumb.mdc-ripple-upgraded::after {
                top: var(--mdc-ripple-top, calc(50% - 50%));
                /* @noflip */ /*rtl:ignore*/
                left: var(--mdc-ripple-left, calc(50% - 50%));
                width: var(--mdc-ripple-fg-size, 100%);
                height: var(--mdc-ripple-fg-size, 100%);
            }
            .mdc-slider__thumb.mdc-ripple-upgraded::after {
                width: var(--mdc-ripple-fg-size, 100%);
                height: var(--mdc-ripple-fg-size, 100%);
            }
            .mdc-slider__thumb::before,
            .mdc-slider__thumb::after {
                background-color: #6200ee;
                /* @alternate */
                background-color: var(
                    --mdc-ripple-color,
                    var(--mdc-theme-primary, #6200ee)
                );
            }
            .mdc-slider__thumb:hover::before,
            .mdc-slider__thumb.mdc-ripple-surface--hover::before {
                opacity: 0.04;
                /* @alternate */
                opacity: var(--mdc-ripple-hover-opacity, 0.04);
            }
            .mdc-slider__thumb.mdc-ripple-upgraded--background-focused::before,
            .mdc-slider__thumb:not(.mdc-ripple-upgraded):focus::before {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-focus-opacity, 0.12);
            }
            .mdc-slider__thumb:not(.mdc-ripple-upgraded)::after {
                transition: opacity 150ms linear;
            }
            .mdc-slider__thumb:not(.mdc-ripple-upgraded):active::after {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-press-opacity, 0.12);
            }
            .mdc-slider__thumb.mdc-ripple-upgraded {
                --mdc-ripple-fg-opacity: var(--mdc-ripple-press-opacity, 0.12);
            }

            .mdc-slider {
                cursor: pointer;
                height: 48px;
                margin: 0 24px;
                position: relative;
                touch-action: pan-y;
            }
            .mdc-slider .mdc-slider__track {
                height: 4px;
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 100%;
            }
            .mdc-slider .mdc-slider__track--active,
            .mdc-slider .mdc-slider__track--inactive {
                display: flex;
                height: 100%;
                position: absolute;
                width: 100%;
            }
            .mdc-slider .mdc-slider__track--active {
                border-radius: 3px;
                height: 6px;
                overflow: hidden;
                top: -1px;
            }
            .mdc-slider .mdc-slider__track--active_fill {
                border-top: 6px solid;
                box-sizing: border-box;
                height: 100%;
                width: 100%;
                position: relative;
                /* @noflip */ /*rtl:ignore*/
                -webkit-transform-origin: left;
                /* @noflip */ /*rtl:ignore*/
                transform-origin: left;
            }
            [dir='rtl'] .mdc-slider .mdc-slider__track--active_fill,
            .mdc-slider .mdc-slider__track--active_fill[dir='rtl'] {
                /*rtl:begin:ignore*/
                /* @noflip */ /*rtl:ignore*/
                -webkit-transform-origin: right;
                /* @noflip */ /*rtl:ignore*/
                transform-origin: right;
                /*rtl:end:ignore*/
            }

            .mdc-slider .mdc-slider__track--inactive {
                border-radius: 2px;
                height: 4px;
                left: 0;
                top: 0;
            }
            .mdc-slider .mdc-slider__track--inactive::before {
                position: absolute;
                box-sizing: border-box;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                border: 1px solid transparent;
                border-radius: inherit;
                content: '';
                pointer-events: none;
            }
            @media screen and (forced-colors: active) {
                .mdc-slider .mdc-slider__track--inactive::before {
                    border-color: CanvasText;
                }
            }
            .mdc-slider .mdc-slider__track--active_fill {
                border-color: #6200ee;
                /* @alternate */
                border-color: var(--mdc-theme-primary, #6200ee);
            }
            .mdc-slider.mdc-slider--disabled .mdc-slider__track--active_fill {
                border-color: #000;
                /* @alternate */
                border-color: var(--mdc-theme-on-surface, #000);
            }
            .mdc-slider .mdc-slider__track--inactive {
                background-color: #6200ee;
                /* @alternate */
                background-color: var(--mdc-theme-primary, #6200ee);
                opacity: 0.24;
            }
            .mdc-slider.mdc-slider--disabled .mdc-slider__track--inactive {
                background-color: #000;
                /* @alternate */
                background-color: var(--mdc-theme-on-surface, #000);
                opacity: 0.24;
            }
            .mdc-slider .mdc-slider__value-indicator-container {
                bottom: 44px;
                /* @noflip */ /*rtl:ignore*/
                left: 50%;
                /* @alternate */
                /* @noflip */ /*rtl:ignore*/
                left: var(--slider-value-indicator-container-left, 50%);
                pointer-events: none;
                position: absolute;
                /* @noflip */ /*rtl:ignore*/
                right: var(--slider-value-indicator-container-right);
                transform: translateX(-50%);
                /* @alternate */
                transform: var(
                    --slider-value-indicator-container-transform,
                    translateX(-50%)
                );
            }
            .mdc-slider .mdc-slider__value-indicator {
                transition: transform 100ms 0ms cubic-bezier(0.4, 0, 1, 1);
                align-items: center;
                border-radius: 4px;
                display: flex;
                height: 32px;
                padding: 0 12px;
                transform: scale(0);
                transform-origin: bottom;
            }
            .mdc-slider .mdc-slider__value-indicator::before {
                border-left: 6px solid transparent;
                border-right: 6px solid transparent;
                border-top: 6px solid;
                bottom: -5px;
                content: '';
                height: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 50%;
                /* @alternate */
                /* @noflip */ /*rtl:ignore*/
                left: var(--slider-value-indicator-caret-left, 50%);
                position: absolute;
                /* @noflip */ /*rtl:ignore*/
                right: var(--slider-value-indicator-caret-right);
                transform: translateX(-50%);
                /* @alternate */
                transform: var(
                    --slider-value-indicator-caret-transform,
                    translateX(-50%)
                );
                width: 0;
            }
            .mdc-slider .mdc-slider__value-indicator::after {
                position: absolute;
                box-sizing: border-box;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                border: 1px solid transparent;
                border-radius: inherit;
                content: '';
                pointer-events: none;
            }
            @media screen and (forced-colors: active) {
                .mdc-slider .mdc-slider__value-indicator::after {
                    border-color: CanvasText;
                }
            }
            .mdc-slider
                .mdc-slider__thumb--with-indicator
                .mdc-slider__value-indicator-container {
                pointer-events: auto;
            }
            .mdc-slider
                .mdc-slider__thumb--with-indicator
                .mdc-slider__value-indicator {
                transition: transform 100ms 0ms cubic-bezier(0, 0, 0.2, 1);
                transform: scale(1);
            }
            @media (prefers-reduced-motion) {
                .mdc-slider .mdc-slider__value-indicator,
                .mdc-slider
                    .mdc-slider__thumb--with-indicator
                    .mdc-slider__value-indicator {
                    transition: none;
                }
            }
            .mdc-slider .mdc-slider__value-indicator-text {
                -moz-osx-font-smoothing: grayscale;
                -webkit-font-smoothing: antialiased;
                font-family: Roboto, sans-serif;
                /* @alternate */
                font-family: var(
                    --mdc-typography-subtitle2-font-family,
                    var(--mdc-typography-font-family, Roboto, sans-serif)
                );
                font-size: 0.875rem;
                /* @alternate */
                font-size: var(--mdc-typography-subtitle2-font-size, 0.875rem);
                line-height: 1.375rem;
                /* @alternate */
                line-height: var(
                    --mdc-typography-subtitle2-line-height,
                    1.375rem
                );
                font-weight: 500;
                /* @alternate */
                font-weight: var(--mdc-typography-subtitle2-font-weight, 500);
                letter-spacing: 0.0071428571em;
                /* @alternate */
                letter-spacing: var(
                    --mdc-typography-subtitle2-letter-spacing,
                    0.0071428571em
                );
                text-decoration: inherit;
                /* @alternate */
                text-decoration: var(
                    --mdc-typography-subtitle2-text-decoration,
                    inherit
                );
                text-transform: inherit;
                /* @alternate */
                text-transform: var(
                    --mdc-typography-subtitle2-text-transform,
                    inherit
                );
            }
            .mdc-slider .mdc-slider__value-indicator {
                background-color: #000;
                opacity: 0.6;
            }
            .mdc-slider .mdc-slider__value-indicator::before {
                border-top-color: #000;
            }
            .mdc-slider .mdc-slider__value-indicator {
                color: #fff;
                /* @alternate */
                color: var(--mdc-theme-on-primary, #fff);
            }
            .mdc-slider .mdc-slider__thumb {
                display: flex;
                height: 48px;
                /* @noflip */ /*rtl:ignore*/
                left: -24px;
                outline: none;
                position: absolute;
                user-select: none;
                width: 48px;
            }
            .mdc-slider .mdc-slider__thumb--top {
                z-index: 1;
            }
            .mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,
            .mdc-slider
                .mdc-slider__thumb--top.mdc-slider__thumb:hover
                .mdc-slider__thumb-knob,
            .mdc-slider
                .mdc-slider__thumb--top.mdc-slider__thumb--focused
                .mdc-slider__thumb-knob {
                border-style: solid;
                border-width: 1px;
                box-sizing: content-box;
            }
            .mdc-slider .mdc-slider__thumb-knob {
                /* @alternate */
                box-shadow:
                    0px 2px 1px -1px rgba(0, 0, 0, 0.2),
                    0px 1px 1px 0px rgba(0, 0, 0, 0.14),
                    0px 1px 3px 0px rgba(0, 0, 0, 0.12);
                border: 10px solid;
                border-radius: 50%;
                box-sizing: border-box;
                height: 20px;
                /* @noflip */ /*rtl:ignore*/
                left: 50%;
                position: absolute;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 20px;
            }
            .mdc-slider .mdc-slider__thumb-knob {
                background-color: #6200ee;
                /* @alternate */
                background-color: var(--mdc-theme-primary, #6200ee);
                border-color: #6200ee;
                /* @alternate */
                border-color: var(--mdc-theme-primary, #6200ee);
            }
            .mdc-slider .mdc-slider__thumb--top .mdc-slider__thumb-knob,
            .mdc-slider
                .mdc-slider__thumb--top.mdc-slider__thumb:hover
                .mdc-slider__thumb-knob,
            .mdc-slider
                .mdc-slider__thumb--top.mdc-slider__thumb--focused
                .mdc-slider__thumb-knob {
                border-color: #fff;
            }
            .mdc-slider.mdc-slider--disabled .mdc-slider__thumb-knob {
                background-color: #000;
                /* @alternate */
                background-color: var(--mdc-theme-on-surface, #000);
                border-color: #000;
                /* @alternate */
                border-color: var(--mdc-theme-on-surface, #000);
            }
            .mdc-slider.mdc-slider--disabled
                .mdc-slider__thumb--top
                .mdc-slider__thumb-knob,
            .mdc-slider.mdc-slider--disabled
                .mdc-slider__thumb--top.mdc-slider__thumb:hover
                .mdc-slider__thumb-knob,
            .mdc-slider.mdc-slider--disabled
                .mdc-slider__thumb--top.mdc-slider__thumb--focused
                .mdc-slider__thumb-knob {
                border-color: #fff;
            }
            .mdc-slider .mdc-slider__thumb::before,
            .mdc-slider .mdc-slider__thumb::after {
                background-color: #6200ee;
                /* @alternate */
                background-color: var(
                    --mdc-ripple-color,
                    var(--mdc-theme-primary, #6200ee)
                );
            }
            .mdc-slider .mdc-slider__thumb:hover::before,
            .mdc-slider .mdc-slider__thumb.mdc-ripple-surface--hover::before {
                opacity: 0.04;
                /* @alternate */
                opacity: var(--mdc-ripple-hover-opacity, 0.04);
            }
            .mdc-slider
                .mdc-slider__thumb.mdc-ripple-upgraded--background-focused::before,
            .mdc-slider
                .mdc-slider__thumb:not(.mdc-ripple-upgraded):focus::before {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-focus-opacity, 0.12);
            }
            .mdc-slider .mdc-slider__thumb:not(.mdc-ripple-upgraded)::after {
                transition: opacity 150ms linear;
            }
            .mdc-slider
                .mdc-slider__thumb:not(.mdc-ripple-upgraded):active::after {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-press-opacity, 0.12);
            }
            .mdc-slider .mdc-slider__thumb.mdc-ripple-upgraded {
                --mdc-ripple-fg-opacity: var(--mdc-ripple-press-opacity, 0.12);
            }
            .mdc-slider .mdc-slider__tick-marks {
                align-items: center;
                box-sizing: border-box;
                display: flex;
                height: 100%;
                justify-content: space-between;
                padding: 0 1px;
                position: absolute;
                width: 100%;
            }
            .mdc-slider .mdc-slider__tick-mark--active,
            .mdc-slider .mdc-slider__tick-mark--inactive {
                border-radius: 50%;
                height: 2px;
                width: 2px;
            }
            .mdc-slider .mdc-slider__tick-mark--active {
                background-color: #fff;
                /* @alternate */
                background-color: var(--mdc-theme-on-primary, #fff);
                opacity: 0.6;
            }
            .mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--active {
                background-color: #fff;
                /* @alternate */
                background-color: var(--mdc-theme-on-primary, #fff);
                opacity: 0.6;
            }
            .mdc-slider .mdc-slider__tick-mark--inactive {
                background-color: #6200ee;
                /* @alternate */
                background-color: var(--mdc-theme-primary, #6200ee);
                opacity: 0.6;
            }
            .mdc-slider.mdc-slider--disabled .mdc-slider__tick-mark--inactive {
                background-color: #000;
                /* @alternate */
                background-color: var(--mdc-theme-on-surface, #000);
                opacity: 0.6;
            }
            .mdc-slider--discrete .mdc-slider__thumb,
            .mdc-slider--discrete .mdc-slider__track--active_fill {
                transition: transform 80ms ease;
            }
            @media (prefers-reduced-motion) {
                .mdc-slider--discrete .mdc-slider__thumb,
                .mdc-slider--discrete .mdc-slider__track--active_fill {
                    transition: none;
                }
            }

            .mdc-slider--disabled {
                opacity: 0.38;
                cursor: auto;
            }
            .mdc-slider--disabled .mdc-slider__thumb {
                pointer-events: none;
            }

            .mdc-slider__input {
                cursor: pointer;
                left: 0;
                margin: 0;
                height: 100%;
                opacity: 0;
                pointer-events: none;
                position: absolute;
                top: 0;
                width: 100%;
            }

            .mdc-elevation-overlay {
                position: absolute;
                border-radius: inherit;
                pointer-events: none;
                opacity: 0;
                /* @alternate */
                opacity: var(--mdc-elevation-overlay-opacity, 0);
                transition: opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);
                background-color: #fff;
                /* @alternate */
                background-color: var(--mdc-elevation-overlay-color, #fff);
            }

            .mdc-switch {
                align-items: center;
                background: none;
                border: none;
                cursor: pointer;
                display: inline-flex;
                flex-shrink: 0;
                margin: 0;
                outline: none;
                overflow: visible;
                padding: 0;
                position: relative;
            }
            .mdc-switch:disabled {
                cursor: default;
                pointer-events: none;
            }

            .mdc-switch__track {
                overflow: hidden;
                position: relative;
                width: 100%;
            }
            .mdc-switch__track::before,
            .mdc-switch__track::after {
                border: 1px solid transparent;
                border-radius: inherit;
                box-sizing: border-box;
                content: '';
                height: 100%;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                position: absolute;
                width: 100%;
            }
            @media screen and (forced-colors: active) {
                .mdc-switch__track::before,
                .mdc-switch__track::after {
                    border-color: currentColor;
                }
            }
            .mdc-switch__track::before {
                transition: transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);
                transform: translateX(0);
            }
            .mdc-switch__track::after {
                transition: transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);
                transform: translateX(-100%);
            }
            [dir='rtl'] .mdc-switch__track::after,
            .mdc-switch__track[dir='rtl']::after {
                /*rtl:begin:ignore*/
                transform: translateX(100%);
                /*rtl:end:ignore*/
            }

            .mdc-switch--selected .mdc-switch__track::before {
                transition: transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);
                transform: translateX(100%);
            }
            [dir='rtl'] .mdc-switch--selected .mdc-switch__track::before,
            .mdc-switch--selected .mdc-switch__track[dir='rtl']::before {
                /*rtl:begin:ignore*/
                transform: translateX(-100%);
                /*rtl:end:ignore*/
            }

            .mdc-switch--selected .mdc-switch__track::after {
                transition: transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);
                transform: translateX(0);
            }

            .mdc-switch__handle-track {
                height: 100%;
                pointer-events: none;
                position: absolute;
                top: 0;
                transition: transform 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                /* @noflip */ /*rtl:ignore*/
                right: auto;
                transform: translateX(0);
            }
            [dir='rtl'] .mdc-switch__handle-track,
            .mdc-switch__handle-track[dir='rtl'] {
                /*rtl:begin:ignore*/
                /* @noflip */ /*rtl:ignore*/
                left: auto;
                /* @noflip */ /*rtl:ignore*/
                right: 0;
                /*rtl:end:ignore*/
            }

            .mdc-switch--selected .mdc-switch__handle-track {
                transform: translateX(100%);
            }
            [dir='rtl'] .mdc-switch--selected .mdc-switch__handle-track,
            .mdc-switch--selected .mdc-switch__handle-track[dir='rtl'] {
                /*rtl:begin:ignore*/
                transform: translateX(-100%);
                /*rtl:end:ignore*/
            }

            .mdc-switch__handle {
                display: flex;
                pointer-events: auto;
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                /* @noflip */ /*rtl:ignore*/
                right: auto;
            }
            [dir='rtl'] .mdc-switch__handle,
            .mdc-switch__handle[dir='rtl'] {
                /*rtl:begin:ignore*/
                /* @noflip */ /*rtl:ignore*/
                left: auto;
                /* @noflip */ /*rtl:ignore*/
                right: 0;
                /*rtl:end:ignore*/
            }

            .mdc-switch__handle::before,
            .mdc-switch__handle::after {
                border: 1px solid transparent;
                border-radius: inherit;
                box-sizing: border-box;
                content: '';
                width: 100%;
                height: 100%;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                position: absolute;
                top: 0;
                transition:
                    background-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1),
                    border-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);
                z-index: -1;
            }
            @media screen and (forced-colors: active) {
                .mdc-switch__handle::before,
                .mdc-switch__handle::after {
                    border-color: currentColor;
                }
            }

            .mdc-switch__shadow {
                border-radius: inherit;
                bottom: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                position: absolute;
                /* @noflip */ /*rtl:ignore*/
                right: 0;
                top: 0;
            }

            .mdc-elevation-overlay {
                bottom: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                /* @noflip */ /*rtl:ignore*/
                right: 0;
                top: 0;
            }

            .mdc-switch__ripple {
                /* @noflip */ /*rtl:ignore*/
                left: 50%;
                position: absolute;
                top: 50%;
                transform: translate(-50%, -50%);
                z-index: -1;
            }
            .mdc-switch:disabled .mdc-switch__ripple {
                display: none;
            }

            .mdc-switch__icons {
                height: 100%;
                position: relative;
                width: 100%;
                z-index: 1;
            }

            .mdc-switch__icon {
                bottom: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                margin: auto;
                position: absolute;
                /* @noflip */ /*rtl:ignore*/
                right: 0;
                top: 0;
                opacity: 0;
                transition: opacity 30ms 0ms cubic-bezier(0.4, 0, 1, 1);
            }

            .mdc-switch--selected .mdc-switch__icon--on,
            .mdc-switch--unselected .mdc-switch__icon--off {
                opacity: 1;
                transition: opacity 45ms 30ms cubic-bezier(0, 0, 0.2, 1);
            }

            .mdc-switch {
                --mdc-ripple-fg-size: 0;
                --mdc-ripple-left: 0;
                --mdc-ripple-top: 0;
                --mdc-ripple-fg-scale: 1;
                --mdc-ripple-fg-translate-end: 0;
                --mdc-ripple-fg-translate-start: 0;
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                will-change: transform, opacity;
            }
            .mdc-switch .mdc-switch__ripple::before,
            .mdc-switch .mdc-switch__ripple::after {
                position: absolute;
                border-radius: 50%;
                opacity: 0;
                pointer-events: none;
                content: '';
            }
            .mdc-switch .mdc-switch__ripple::before {
                transition:
                    opacity 15ms linear,
                    background-color 15ms linear;
                z-index: 1;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 1);
            }
            .mdc-switch .mdc-switch__ripple::after {
                z-index: 0;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 0);
            }
            .mdc-switch.mdc-ripple-upgraded .mdc-switch__ripple::before {
                transform: scale(var(--mdc-ripple-fg-scale, 1));
            }
            .mdc-switch.mdc-ripple-upgraded .mdc-switch__ripple::after {
                top: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                transform: scale(0);
                transform-origin: center center;
            }
            .mdc-switch.mdc-ripple-upgraded--unbounded
                .mdc-switch__ripple::after {
                top: var(--mdc-ripple-top, 0);
                /* @noflip */ /*rtl:ignore*/
                left: var(--mdc-ripple-left, 0);
            }
            .mdc-switch.mdc-ripple-upgraded--foreground-activation
                .mdc-switch__ripple::after {
                animation:
                    mdc-ripple-fg-radius-in 225ms forwards,
                    mdc-ripple-fg-opacity-in 75ms forwards;
            }
            .mdc-switch.mdc-ripple-upgraded--foreground-deactivation
                .mdc-switch__ripple::after {
                animation: mdc-ripple-fg-opacity-out 150ms;
                transform: translate(var(--mdc-ripple-fg-translate-end, 0))
                    scale(var(--mdc-ripple-fg-scale, 1));
            }
            .mdc-switch .mdc-switch__ripple::before,
            .mdc-switch .mdc-switch__ripple::after {
                top: calc(50% - 50%);
                /* @noflip */ /*rtl:ignore*/
                left: calc(50% - 50%);
                width: 100%;
                height: 100%;
            }
            .mdc-switch.mdc-ripple-upgraded .mdc-switch__ripple::before,
            .mdc-switch.mdc-ripple-upgraded .mdc-switch__ripple::after {
                top: var(--mdc-ripple-top, calc(50% - 50%));
                /* @noflip */ /*rtl:ignore*/
                left: var(--mdc-ripple-left, calc(50% - 50%));
                width: var(--mdc-ripple-fg-size, 100%);
                height: var(--mdc-ripple-fg-size, 100%);
            }
            .mdc-switch.mdc-ripple-upgraded .mdc-switch__ripple::after {
                width: var(--mdc-ripple-fg-size, 100%);
                height: var(--mdc-ripple-fg-size, 100%);
            }
            .mdc-switch .mdc-switch__focus-ring-wrapper {
                width: 100%;
                position: absolute;
                top: 50%;
                /* @noflip */ /*rtl:ignore*/
                left: 50%;
                /* @noflip */ /*rtl:ignore*/
                transform: translate(-50%, -50%);
            }
            .mdc-switch.mdc-ripple-upgraded--background-focused
                .mdc-switch__focus-ring,
            .mdc-switch:not(.mdc-ripple-upgraded):focus
                .mdc-switch__focus-ring {
                pointer-events: none;
                border: 2px solid transparent;
                border-radius: 6px;
                box-sizing: content-box;
                position: absolute;
                top: 50%;
                /* @noflip */ /*rtl:ignore*/
                left: 50%;
                /* @noflip */ /*rtl:ignore*/
                transform: translate(-50%, -50%);
                height: calc(100% + 4px);
                width: calc(100% + 4px);
            }
            @media screen and (forced-colors: active) {
                .mdc-switch.mdc-ripple-upgraded--background-focused
                    .mdc-switch__focus-ring,
                .mdc-switch:not(.mdc-ripple-upgraded):focus
                    .mdc-switch__focus-ring {
                    border-color: CanvasText;
                }
            }
            .mdc-switch.mdc-ripple-upgraded--background-focused
                .mdc-switch__focus-ring::after,
            .mdc-switch:not(.mdc-ripple-upgraded):focus
                .mdc-switch__focus-ring::after {
                content: '';
                border: 2px solid transparent;
                border-radius: 8px;
                display: block;
                position: absolute;
                top: 50%;
                /* @noflip */ /*rtl:ignore*/
                left: 50%;
                /* @noflip */ /*rtl:ignore*/
                transform: translate(-50%, -50%);
                height: calc(100% + 4px);
                width: calc(100% + 4px);
            }
            @media screen and (forced-colors: active) {
                .mdc-switch.mdc-ripple-upgraded--background-focused
                    .mdc-switch__focus-ring::after,
                .mdc-switch:not(.mdc-ripple-upgraded):focus
                    .mdc-switch__focus-ring::after {
                    border-color: CanvasText;
                }
            }

            .mdc-switch {
                width: 36px;
                /* @alternate */
                width: var(--mdc-switch-track-width, 36px);
            }
            .mdc-switch.mdc-switch--selected:enabled
                .mdc-switch__handle::after {
                background: #6200ee;
                /* @alternate */
                background: var(
                    --mdc-switch-selected-handle-color,
                    var(--mdc-theme-primary, #6200ee)
                );
            }

            .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus):not(
                    :active
                )
                .mdc-switch__handle::after {
                background: #310077;
                /* @alternate */
                background: var(
                    --mdc-switch-selected-hover-handle-color,
                    #310077
                );
            }

            .mdc-switch.mdc-switch--selected:enabled:focus:not(:active)
                .mdc-switch__handle::after {
                background: #310077;
                /* @alternate */
                background: var(
                    --mdc-switch-selected-focus-handle-color,
                    #310077
                );
            }

            .mdc-switch.mdc-switch--selected:enabled:active
                .mdc-switch__handle::after {
                background: #310077;
                /* @alternate */
                background: var(
                    --mdc-switch-selected-pressed-handle-color,
                    #310077
                );
            }

            .mdc-switch.mdc-switch--selected:disabled
                .mdc-switch__handle::after {
                background: #424242;
                /* @alternate */
                background: var(
                    --mdc-switch-disabled-selected-handle-color,
                    #424242
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled
                .mdc-switch__handle::after {
                background: #616161;
                /* @alternate */
                background: var(--mdc-switch-unselected-handle-color, #616161);
            }

            .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus):not(
                    :active
                )
                .mdc-switch__handle::after {
                background: #212121;
                /* @alternate */
                background: var(
                    --mdc-switch-unselected-hover-handle-color,
                    #212121
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled:focus:not(:active)
                .mdc-switch__handle::after {
                background: #212121;
                /* @alternate */
                background: var(
                    --mdc-switch-unselected-focus-handle-color,
                    #212121
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled:active
                .mdc-switch__handle::after {
                background: #212121;
                /* @alternate */
                background: var(
                    --mdc-switch-unselected-pressed-handle-color,
                    #212121
                );
            }

            .mdc-switch.mdc-switch--unselected:disabled
                .mdc-switch__handle::after {
                background: #424242;
                /* @alternate */
                background: var(
                    --mdc-switch-disabled-unselected-handle-color,
                    #424242
                );
            }

            .mdc-switch .mdc-switch__handle::before {
                background: #fff;
                /* @alternate */
                background: var(
                    --mdc-switch-handle-surface-color,
                    var(--mdc-theme-surface, #fff)
                );
            }
            .mdc-switch:enabled .mdc-switch__shadow {
                --mdc-elevation-box-shadow-for-gss: 0px 2px 1px -1px rgba(0, 0, 0, 0.2),
                    0px 1px 1px 0px rgba(0, 0, 0, 0.14),
                    0px 1px 3px 0px rgba(0, 0, 0, 0.12);
                box-shadow:
                    0px 2px 1px -1px rgba(0, 0, 0, 0.2),
                    0px 1px 1px 0px rgba(0, 0, 0, 0.14),
                    0px 1px 3px 0px rgba(0, 0, 0, 0.12);
                /* @alternate */
                box-shadow: var(
                    --mdc-switch-handle-elevation,
                    var(--mdc-elevation-box-shadow-for-gss)
                );
            }
            .mdc-switch:disabled .mdc-switch__shadow {
                --mdc-elevation-box-shadow-for-gss: 0px 0px 0px 0px
                        rgba(0, 0, 0, 0.2),
                    0px 0px 0px 0px rgba(0, 0, 0, 0.14),
                    0px 0px 0px 0px rgba(0, 0, 0, 0.12);
                box-shadow:
                    0px 0px 0px 0px rgba(0, 0, 0, 0.2),
                    0px 0px 0px 0px rgba(0, 0, 0, 0.14),
                    0px 0px 0px 0px rgba(0, 0, 0, 0.12);
                /* @alternate */
                box-shadow: var(
                    --mdc-switch-disabled-handle-elevation,
                    var(--mdc-elevation-box-shadow-for-gss)
                );
            }
            .mdc-switch .mdc-switch__focus-ring-wrapper,
            .mdc-switch .mdc-switch__handle {
                height: 20px;
                /* @alternate */
                height: var(--mdc-switch-handle-height, 20px);
            }
            .mdc-switch:disabled .mdc-switch__handle::after {
                opacity: 0.38;
                /* @alternate */
                opacity: var(--mdc-switch-disabled-handle-opacity, 0.38);
            }

            .mdc-switch .mdc-switch__handle {
                border-radius: 10px;
                /* @alternate */
                border-radius: var(--mdc-switch-handle-shape, 10px);
            }
            .mdc-switch .mdc-switch__handle {
                width: 20px;
                /* @alternate */
                width: var(--mdc-switch-handle-width, 20px);
            }
            .mdc-switch .mdc-switch__handle-track {
                width: calc(100% - 20px);
                /* @alternate */
                width: calc(100% - var(--mdc-switch-handle-width, 20px));
            }
            .mdc-switch.mdc-switch--selected:enabled .mdc-switch__icon {
                fill: #fff;
                /* @alternate */
                fill: var(
                    --mdc-switch-selected-icon-color,
                    var(--mdc-theme-on-primary, #fff)
                );
            }

            .mdc-switch.mdc-switch--selected:disabled .mdc-switch__icon {
                fill: #fff;
                /* @alternate */
                fill: var(
                    --mdc-switch-disabled-selected-icon-color,
                    var(--mdc-theme-on-primary, #fff)
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled .mdc-switch__icon {
                fill: #fff;
                /* @alternate */
                fill: var(
                    --mdc-switch-unselected-icon-color,
                    var(--mdc-theme-on-primary, #fff)
                );
            }

            .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icon {
                fill: #fff;
                /* @alternate */
                fill: var(
                    --mdc-switch-disabled-unselected-icon-color,
                    var(--mdc-theme-on-primary, #fff)
                );
            }

            .mdc-switch.mdc-switch--selected:disabled .mdc-switch__icons {
                opacity: 0.38;
                /* @alternate */
                opacity: var(--mdc-switch-disabled-selected-icon-opacity, 0.38);
            }

            .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icons {
                opacity: 0.38;
                /* @alternate */
                opacity: var(
                    --mdc-switch-disabled-unselected-icon-opacity,
                    0.38
                );
            }

            .mdc-switch.mdc-switch--selected .mdc-switch__icon {
                width: 18px;
                /* @alternate */
                width: var(--mdc-switch-selected-icon-size, 18px);
                height: 18px;
                /* @alternate */
                height: var(--mdc-switch-selected-icon-size, 18px);
            }

            .mdc-switch.mdc-switch--unselected .mdc-switch__icon {
                width: 18px;
                /* @alternate */
                width: var(--mdc-switch-unselected-icon-size, 18px);
                height: 18px;
                /* @alternate */
                height: var(--mdc-switch-unselected-icon-size, 18px);
            }

            .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus)
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus)
                .mdc-switch__ripple::after {
                background-color: #6200ee;
                /* @alternate */
                background-color: var(
                    --mdc-switch-selected-hover-state-layer-color,
                    var(--mdc-theme-primary, #6200ee)
                );
            }

            .mdc-switch.mdc-switch--selected:enabled:focus
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--selected:enabled:focus
                .mdc-switch__ripple::after {
                background-color: #6200ee;
                /* @alternate */
                background-color: var(
                    --mdc-switch-selected-focus-state-layer-color,
                    var(--mdc-theme-primary, #6200ee)
                );
            }

            .mdc-switch.mdc-switch--selected:enabled:active
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--selected:enabled:active
                .mdc-switch__ripple::after {
                background-color: #6200ee;
                /* @alternate */
                background-color: var(
                    --mdc-switch-selected-pressed-state-layer-color,
                    var(--mdc-theme-primary, #6200ee)
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus)
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus)
                .mdc-switch__ripple::after {
                background-color: #424242;
                /* @alternate */
                background-color: var(
                    --mdc-switch-unselected-hover-state-layer-color,
                    #424242
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled:focus
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--unselected:enabled:focus
                .mdc-switch__ripple::after {
                background-color: #424242;
                /* @alternate */
                background-color: var(
                    --mdc-switch-unselected-focus-state-layer-color,
                    #424242
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled:active
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--unselected:enabled:active
                .mdc-switch__ripple::after {
                background-color: #424242;
                /* @alternate */
                background-color: var(
                    --mdc-switch-unselected-pressed-state-layer-color,
                    #424242
                );
            }

            .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus):hover
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--selected:enabled:hover:not(
                    :focus
                ).mdc-ripple-surface--hover
                .mdc-switch__ripple::before {
                opacity: 0.04;
                /* @alternate */
                opacity: var(
                    --mdc-switch-selected-hover-state-layer-opacity,
                    0.04
                );
            }

            .mdc-switch.mdc-switch--selected:enabled:focus.mdc-ripple-upgraded--background-focused
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--selected:enabled:focus:not(
                    .mdc-ripple-upgraded
                ):focus
                .mdc-switch__ripple::before {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(
                    --mdc-switch-selected-focus-state-layer-opacity,
                    0.12
                );
            }

            .mdc-switch.mdc-switch--selected:enabled:active:not(
                    .mdc-ripple-upgraded
                )
                .mdc-switch__ripple::after {
                transition: opacity 150ms linear;
            }
            .mdc-switch.mdc-switch--selected:enabled:active:not(
                    .mdc-ripple-upgraded
                ):active
                .mdc-switch__ripple::after {
                transition-duration: 75ms;
                opacity: 0.1;
                /* @alternate */
                opacity: var(
                    --mdc-switch-selected-pressed-state-layer-opacity,
                    0.1
                );
            }
            .mdc-switch.mdc-switch--selected:enabled:active.mdc-ripple-upgraded {
                --mdc-ripple-fg-opacity: var(
                    --mdc-switch-selected-pressed-state-layer-opacity,
                    0.1
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus):hover
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--unselected:enabled:hover:not(
                    :focus
                ).mdc-ripple-surface--hover
                .mdc-switch__ripple::before {
                opacity: 0.04;
                /* @alternate */
                opacity: var(
                    --mdc-switch-unselected-hover-state-layer-opacity,
                    0.04
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled:focus.mdc-ripple-upgraded--background-focused
                .mdc-switch__ripple::before,
            .mdc-switch.mdc-switch--unselected:enabled:focus:not(
                    .mdc-ripple-upgraded
                ):focus
                .mdc-switch__ripple::before {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(
                    --mdc-switch-unselected-focus-state-layer-opacity,
                    0.12
                );
            }

            .mdc-switch.mdc-switch--unselected:enabled:active:not(
                    .mdc-ripple-upgraded
                )
                .mdc-switch__ripple::after {
                transition: opacity 150ms linear;
            }
            .mdc-switch.mdc-switch--unselected:enabled:active:not(
                    .mdc-ripple-upgraded
                ):active
                .mdc-switch__ripple::after {
                transition-duration: 75ms;
                opacity: 0.1;
                /* @alternate */
                opacity: var(
                    --mdc-switch-unselected-pressed-state-layer-opacity,
                    0.1
                );
            }
            .mdc-switch.mdc-switch--unselected:enabled:active.mdc-ripple-upgraded {
                --mdc-ripple-fg-opacity: var(
                    --mdc-switch-unselected-pressed-state-layer-opacity,
                    0.1
                );
            }

            .mdc-switch .mdc-switch__ripple {
                height: 48px;
                /* @alternate */
                height: var(--mdc-switch-state-layer-size, 48px);
                width: 48px;
                /* @alternate */
                width: var(--mdc-switch-state-layer-size, 48px);
            }
            .mdc-switch .mdc-switch__track {
                height: 14px;
                /* @alternate */
                height: var(--mdc-switch-track-height, 14px);
            }
            .mdc-switch:disabled .mdc-switch__track {
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-switch-disabled-track-opacity, 0.12);
            }

            .mdc-switch:enabled .mdc-switch__track::after {
                background: #d7bbff;
                /* @alternate */
                background: var(--mdc-switch-selected-track-color, #d7bbff);
            }

            .mdc-switch:enabled:hover:not(:focus):not(:active)
                .mdc-switch__track::after {
                background: #d7bbff;
                /* @alternate */
                background: var(
                    --mdc-switch-selected-hover-track-color,
                    #d7bbff
                );
            }

            .mdc-switch:enabled:focus:not(:active) .mdc-switch__track::after {
                background: #d7bbff;
                /* @alternate */
                background: var(
                    --mdc-switch-selected-focus-track-color,
                    #d7bbff
                );
            }

            .mdc-switch:enabled:active .mdc-switch__track::after {
                background: #d7bbff;
                /* @alternate */
                background: var(
                    --mdc-switch-selected-pressed-track-color,
                    #d7bbff
                );
            }

            .mdc-switch:disabled .mdc-switch__track::after {
                background: #424242;
                /* @alternate */
                background: var(
                    --mdc-switch-disabled-selected-track-color,
                    #424242
                );
            }

            .mdc-switch:enabled .mdc-switch__track::before {
                background: #e0e0e0;
                /* @alternate */
                background: var(--mdc-switch-unselected-track-color, #e0e0e0);
            }

            .mdc-switch:enabled:hover:not(:focus):not(:active)
                .mdc-switch__track::before {
                background: #e0e0e0;
                /* @alternate */
                background: var(
                    --mdc-switch-unselected-hover-track-color,
                    #e0e0e0
                );
            }

            .mdc-switch:enabled:focus:not(:active) .mdc-switch__track::before {
                background: #e0e0e0;
                /* @alternate */
                background: var(
                    --mdc-switch-unselected-focus-track-color,
                    #e0e0e0
                );
            }

            .mdc-switch:enabled:active .mdc-switch__track::before {
                background: #e0e0e0;
                /* @alternate */
                background: var(
                    --mdc-switch-unselected-pressed-track-color,
                    #e0e0e0
                );
            }

            .mdc-switch:disabled .mdc-switch__track::before {
                background: #424242;
                /* @alternate */
                background: var(
                    --mdc-switch-disabled-unselected-track-color,
                    #424242
                );
            }

            .mdc-switch .mdc-switch__track {
                border-radius: 7px;
                /* @alternate */
                border-radius: var(--mdc-switch-track-shape, 7px);
            }

            @media screen and (forced-colors: active),
                (-ms-high-contrast: active) {
                .mdc-switch:enabled .mdc-switch__shadow {
                    /* @alternate */
                }
                .mdc-switch:disabled .mdc-switch__shadow {
                    /* @alternate */
                }
                .mdc-switch:disabled .mdc-switch__handle::after {
                    opacity: 1;
                    /* @alternate */
                    opacity: var(--mdc-switch-disabled-handle-opacity, 1);
                }
                .mdc-switch.mdc-switch--selected:enabled .mdc-switch__icon {
                    fill: ButtonText;
                    /* @alternate */
                    fill: var(--mdc-switch-selected-icon-color, ButtonText);
                }
                .mdc-switch.mdc-switch--selected:disabled .mdc-switch__icon {
                    fill: GrayText;
                    /* @alternate */
                    fill: var(
                        --mdc-switch-disabled-selected-icon-color,
                        GrayText
                    );
                }
                .mdc-switch.mdc-switch--unselected:enabled .mdc-switch__icon {
                    fill: ButtonText;
                    /* @alternate */
                    fill: var(--mdc-switch-unselected-icon-color, ButtonText);
                }
                .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icon {
                    fill: GrayText;
                    /* @alternate */
                    fill: var(
                        --mdc-switch-disabled-unselected-icon-color,
                        GrayText
                    );
                }
                .mdc-switch.mdc-switch--selected:disabled .mdc-switch__icons {
                    opacity: 1;
                    /* @alternate */
                    opacity: var(
                        --mdc-switch-disabled-selected-icon-opacity,
                        1
                    );
                }
                .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icons {
                    opacity: 1;
                    /* @alternate */
                    opacity: var(
                        --mdc-switch-disabled-unselected-icon-opacity,
                        1
                    );
                }
                .mdc-switch:disabled .mdc-switch__track {
                    opacity: 1;
                    /* @alternate */
                    opacity: var(--mdc-switch-disabled-track-opacity, 1);
                }
            }
            @font-face {
                font-family: 'Noto Sans';
                font-style: normal;
                font-weight: normal;
                src: url('/rio/asset/fonts/Noto Sans/NotoSans-Regular.ttf');
            }
            @font-face {
                font-family: 'Noto Sans';
                font-style: normal;
                font-weight: bold;
                src: url('/rio/asset/fonts/Noto Sans/NotoSans-Bold.ttf');
            }
            @font-face {
                font-family: 'Noto Sans';
                font-style: italic;
                font-weight: normal;
                src: url('/rio/asset/fonts/Noto Sans/NotoSans-Italic.ttf');
            }
            @font-face {
                font-family: 'Noto Sans';
                font-style: italic;
                font-weight: bold;
                src: url('/rio/asset/fonts/Noto Sans/NotoSans-BoldItalic.ttf');
            }
            @font-face {
                font-family: 'Roboto';
                font-style: normal;
                font-weight: normal;
                src: url('/rio/asset/fonts/Roboto/Roboto-Regular.ttf');
            }
            @font-face {
                font-family: 'Roboto';
                font-style: normal;
                font-weight: bold;
                src: url('/rio/asset/fonts/Roboto/Roboto-Bold.ttf');
            }
            @font-face {
                font-family: 'Roboto';
                font-style: italic;
                font-weight: normal;
                src: url('/rio/asset/fonts/Roboto/Roboto-Italic.ttf');
            }
            @font-face {
                font-family: 'Roboto';
                font-style: italic;
                font-weight: bold;
                src: url('/rio/asset/fonts/Roboto/Roboto-BoldItalic.ttf');
            }
            @font-face {
                font-family: 'Roboto Mono';
                font-style: normal;
                font-weight: normal;
                src: url('/rio/asset/fonts/Roboto Mono/RobotoMono-Regular.ttf');
            }
            @font-face {
                font-family: 'Roboto Mono';
                font-style: normal;
                font-weight: bold;
                src: url('/rio/asset/fonts/Roboto Mono/RobotoMono-Bold.ttf');
            }
            @font-face {
                font-family: 'Roboto Mono';
                font-style: italic;
                font-weight: normal;
                src: url('/rio/asset/fonts/Roboto Mono/RobotoMono-Italic.ttf');
            }
            @font-face {
                font-family: 'Roboto Mono';
                font-style: italic;
                font-weight: bold;
                src: url('/rio/asset/fonts/Roboto Mono/RobotoMono-BoldItalic.ttf');
            }
            @keyframes mdc-linear-progress-primary-indeterminate-translate {
                0% {
                    transform: translateX(0);
                }
                20% {
                    animation-timing-function: cubic-bezier(
                        0.5,
                        0,
                        0.701732,
                        0.495819
                    );
                    transform: translateX(0);
                }
                59.15% {
                    animation-timing-function: cubic-bezier(
                        0.302435,
                        0.381352,
                        0.55,
                        0.956352
                    );
                    transform: translateX(83.67142%);
                    /* @alternate */
                    transform: translateX(
                        var(--mdc-linear-progress-primary-half, 83.67142%)
                    );
                }
                100% {
                    transform: translateX(200.611057%);
                    /* @alternate */
                    transform: translateX(
                        var(--mdc-linear-progress-primary-full, 200.611057%)
                    );
                }
            }
            @keyframes mdc-linear-progress-primary-indeterminate-scale {
                0% {
                    transform: scaleX(0.08);
                }
                36.65% {
                    animation-timing-function: cubic-bezier(
                        0.334731,
                        0.12482,
                        0.785844,
                        1
                    );
                    transform: scaleX(0.08);
                }
                69.15% {
                    animation-timing-function: cubic-bezier(0.06, 0.11, 0.6, 1);
                    transform: scaleX(0.661479);
                }
                100% {
                    transform: scaleX(0.08);
                }
            }
            @keyframes mdc-linear-progress-secondary-indeterminate-translate {
                0% {
                    animation-timing-function: cubic-bezier(
                        0.15,
                        0,
                        0.515058,
                        0.409685
                    );
                    transform: translateX(0);
                }
                25% {
                    animation-timing-function: cubic-bezier(
                        0.31033,
                        0.284058,
                        0.8,
                        0.733712
                    );
                    transform: translateX(37.651913%);
                    /* @alternate */
                    transform: translateX(
                        var(--mdc-linear-progress-secondary-quarter, 37.651913%)
                    );
                }
                48.35% {
                    animation-timing-function: cubic-bezier(
                        0.4,
                        0.627035,
                        0.6,
                        0.902026
                    );
                    transform: translateX(84.386165%);
                    /* @alternate */
                    transform: translateX(
                        var(--mdc-linear-progress-secondary-half, 84.386165%)
                    );
                }
                100% {
                    transform: translateX(160.277782%);
                    /* @alternate */
                    transform: translateX(
                        var(--mdc-linear-progress-secondary-full, 160.277782%)
                    );
                }
            }
            @keyframes mdc-linear-progress-secondary-indeterminate-scale {
                0% {
                    animation-timing-function: cubic-bezier(
                        0.205028,
                        0.057051,
                        0.57661,
                        0.453971
                    );
                    transform: scaleX(0.08);
                }
                19.15% {
                    animation-timing-function: cubic-bezier(
                        0.152313,
                        0.196432,
                        0.648374,
                        1.004315
                    );
                    transform: scaleX(0.457104);
                }
                44.15% {
                    animation-timing-function: cubic-bezier(
                        0.257759,
                        -0.003163,
                        0.211762,
                        1.38179
                    );
                    transform: scaleX(0.72796);
                }
                100% {
                    transform: scaleX(0.08);
                }
            }
            @keyframes mdc-linear-progress-buffering {
                from {
                    transform: rotate(180deg) translateX(-10px);
                }
            }
            @keyframes mdc-linear-progress-primary-indeterminate-translate-reverse {
                0% {
                    transform: translateX(0);
                }
                20% {
                    animation-timing-function: cubic-bezier(
                        0.5,
                        0,
                        0.701732,
                        0.495819
                    );
                    transform: translateX(0);
                }
                59.15% {
                    animation-timing-function: cubic-bezier(
                        0.302435,
                        0.381352,
                        0.55,
                        0.956352
                    );
                    transform: translateX(-83.67142%);
                    /* @alternate */
                    transform: translateX(
                        var(--mdc-linear-progress-primary-half-neg, -83.67142%)
                    );
                }
                100% {
                    transform: translateX(-200.611057%);
                    /* @alternate */
                    transform: translateX(
                        var(
                            --mdc-linear-progress-primary-full-neg,
                            -200.611057%
                        )
                    );
                }
            }
            @keyframes mdc-linear-progress-secondary-indeterminate-translate-reverse {
                0% {
                    animation-timing-function: cubic-bezier(
                        0.15,
                        0,
                        0.515058,
                        0.409685
                    );
                    transform: translateX(0);
                }
                25% {
                    animation-timing-function: cubic-bezier(
                        0.31033,
                        0.284058,
                        0.8,
                        0.733712
                    );
                    transform: translateX(-37.651913%);
                    /* @alternate */
                    transform: translateX(
                        var(
                            --mdc-linear-progress-secondary-quarter-neg,
                            -37.651913%
                        )
                    );
                }
                48.35% {
                    animation-timing-function: cubic-bezier(
                        0.4,
                        0.627035,
                        0.6,
                        0.902026
                    );
                    transform: translateX(-84.386165%);
                    /* @alternate */
                    transform: translateX(
                        var(
                            --mdc-linear-progress-secondary-half-neg,
                            -84.386165%
                        )
                    );
                }
                100% {
                    transform: translateX(-160.277782%);
                    /* @alternate */
                    transform: translateX(
                        var(
                            --mdc-linear-progress-secondary-full-neg,
                            -160.277782%
                        )
                    );
                }
            }
            @keyframes mdc-linear-progress-buffering-reverse {
                from {
                    transform: translateX(-10px);
                }
            }
            .mdc-linear-progress {
                position: relative;
                width: 100%;
                transform: translateZ(0);
                outline: 1px solid transparent;
                overflow: hidden;
                transition: opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1);
            }
            @media screen and (forced-colors: active) {
                .mdc-linear-progress {
                    outline-color: CanvasText;
                }
            }
            .mdc-linear-progress__bar {
                position: absolute;
                width: 100%;
                height: 100%;
                animation: none;
                transform-origin: top left;
                transition: transform 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1);
            }
            .mdc-linear-progress__bar-inner {
                display: inline-block;
                position: absolute;
                width: 100%;
                animation: none;
                border-top-style: solid;
            }
            .mdc-linear-progress__buffer {
                display: flex;
                position: absolute;
                width: 100%;
                height: 100%;
            }
            .mdc-linear-progress__buffer-dots {
                background-repeat: repeat-x;
                flex: auto;
                transform: rotate(180deg);
                animation: mdc-linear-progress-buffering 250ms infinite linear;
            }
            .mdc-linear-progress__buffer-bar {
                flex: 0 1 100%;
                transition: flex-basis 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1);
            }
            .mdc-linear-progress__primary-bar {
                transform: scaleX(0);
            }
            .mdc-linear-progress__secondary-bar {
                display: none;
            }
            .mdc-linear-progress--indeterminate .mdc-linear-progress__bar {
                transition: none;
            }
            .mdc-linear-progress--indeterminate
                .mdc-linear-progress__primary-bar {
                left: -145.166611%;
            }
            .mdc-linear-progress--indeterminate
                .mdc-linear-progress__secondary-bar {
                left: -54.888891%;
                display: block;
            }
            .mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready
                .mdc-linear-progress__primary-bar {
                animation: mdc-linear-progress-primary-indeterminate-translate
                    2s infinite linear;
            }
            .mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready
                .mdc-linear-progress__primary-bar
                > .mdc-linear-progress__bar-inner {
                animation: mdc-linear-progress-primary-indeterminate-scale 2s
                    infinite linear;
            }
            .mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready
                .mdc-linear-progress__secondary-bar {
                animation: mdc-linear-progress-secondary-indeterminate-translate
                    2s infinite linear;
            }
            .mdc-linear-progress--indeterminate.mdc-linear-progress--animation-ready
                .mdc-linear-progress__secondary-bar
                > .mdc-linear-progress__bar-inner {
                animation: mdc-linear-progress-secondary-indeterminate-scale 2s
                    infinite linear;
            }
            [dir='rtl'] .mdc-linear-progress,
            .mdc-linear-progress[dir='rtl'] {
                /*rtl:begin:ignore*/
                /*rtl:end:ignore*/
            }
            [dir='rtl']
                .mdc-linear-progress:not([dir='ltr'])
                .mdc-linear-progress__bar,
            .mdc-linear-progress[dir='rtl']:not([dir='ltr'])
                .mdc-linear-progress__bar {
                /* @noflip */ /*rtl:ignore*/
                right: 0;
                /* @noflip */ /*rtl:ignore*/
                -webkit-transform-origin: center right;
                /* @noflip */ /*rtl:ignore*/
                transform-origin: center right;
            }
            [dir='rtl']
                .mdc-linear-progress:not(
                    [dir='ltr']
                ).mdc-linear-progress--animation-ready
                .mdc-linear-progress__primary-bar,
            .mdc-linear-progress[dir='rtl']:not(
                    [dir='ltr']
                ).mdc-linear-progress--animation-ready
                .mdc-linear-progress__primary-bar {
                animation-name: mdc-linear-progress-primary-indeterminate-translate-reverse;
            }
            [dir='rtl']
                .mdc-linear-progress:not(
                    [dir='ltr']
                ).mdc-linear-progress--animation-ready
                .mdc-linear-progress__secondary-bar,
            .mdc-linear-progress[dir='rtl']:not(
                    [dir='ltr']
                ).mdc-linear-progress--animation-ready
                .mdc-linear-progress__secondary-bar {
                animation-name: mdc-linear-progress-secondary-indeterminate-translate-reverse;
            }
            [dir='rtl']
                .mdc-linear-progress:not([dir='ltr'])
                .mdc-linear-progress__buffer-dots,
            .mdc-linear-progress[dir='rtl']:not([dir='ltr'])
                .mdc-linear-progress__buffer-dots {
                animation: mdc-linear-progress-buffering-reverse 250ms infinite
                    linear;
                transform: rotate(0);
            }
            [dir='rtl']
                .mdc-linear-progress:not(
                    [dir='ltr']
                ).mdc-linear-progress--indeterminate
                .mdc-linear-progress__primary-bar,
            .mdc-linear-progress[dir='rtl']:not(
                    [dir='ltr']
                ).mdc-linear-progress--indeterminate
                .mdc-linear-progress__primary-bar {
                /* @noflip */ /*rtl:ignore*/
                right: -145.166611%;
                /* @noflip */ /*rtl:ignore*/
                left: auto;
            }
            [dir='rtl']
                .mdc-linear-progress:not(
                    [dir='ltr']
                ).mdc-linear-progress--indeterminate
                .mdc-linear-progress__secondary-bar,
            .mdc-linear-progress[dir='rtl']:not(
                    [dir='ltr']
                ).mdc-linear-progress--indeterminate
                .mdc-linear-progress__secondary-bar {
                /* @noflip */ /*rtl:ignore*/
                right: -54.888891%;
                /* @noflip */ /*rtl:ignore*/
                left: auto;
            }

            .mdc-linear-progress--closed {
                opacity: 0;
            }
            .mdc-linear-progress--closed-animation-off
                .mdc-linear-progress__buffer-dots {
                animation: none;
            }
            .mdc-linear-progress--closed-animation-off.mdc-linear-progress--indeterminate
                .mdc-linear-progress__bar,
            .mdc-linear-progress--closed-animation-off.mdc-linear-progress--indeterminate
                .mdc-linear-progress__bar
                .mdc-linear-progress__bar-inner {
                animation: none;
            }

            .mdc-linear-progress__bar-inner {
                border-color: #6200ee;
                /* @alternate */
                border-color: var(--mdc-theme-primary, #6200ee);
            }

            .mdc-linear-progress__buffer-dots {
                background-image: url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' enable-background='new 0 0 5 2' xml:space='preserve' viewBox='0 0 5 2' preserveAspectRatio='none slice'%3E%3Ccircle cx='1' cy='1' r='1' fill='%23e6e6e6'/%3E%3C/svg%3E");
            }

            .mdc-linear-progress__buffer-bar {
                background-color: #e6e6e6;
            }

            .mdc-linear-progress {
                height: 4px;
            }
            .mdc-linear-progress__bar-inner {
                border-top-width: 4px;
            }
            .mdc-linear-progress__buffer-dots {
                background-size: 10px 4px;
            }

            html[data-theme='light'] {
                /*!
    Theme: Default
    Description: Original highlight.js style
    Author: (c) Ivan Sagalaev <maniac@softwaremaniacs.org>
    Maintainer: @highlightjs/core-team
    Website: https://highlightjs.org/
    License: see project LICENSE
    Touched: 2021
  */
            }
            html[data-theme='light'] pre code.hljs {
                display: block;
                overflow-x: auto;
                padding: 1rem;
            }
            html[data-theme='light'] code.hljs {
                padding: 3px 5px;
            }
            html[data-theme='light'] .hljs {
                background: #f3f3f3;
                color: #444;
            }
            html[data-theme='light'] .hljs-comment {
                color: #697070;
            }
            html[data-theme='light'] .hljs-punctuation,
            html[data-theme='light'] .hljs-tag {
                color: rgba(68, 68, 68, 0.6666666667);
            }
            html[data-theme='light'] .hljs-tag .hljs-attr,
            html[data-theme='light'] .hljs-tag .hljs-name {
                color: #444;
            }
            html[data-theme='light'] .hljs-attribute,
            html[data-theme='light'] .hljs-doctag,
            html[data-theme='light'] .hljs-keyword,
            html[data-theme='light'] .hljs-meta .hljs-keyword,
            html[data-theme='light'] .hljs-name,
            html[data-theme='light'] .hljs-selector-tag {
                font-weight: 700;
            }
            html[data-theme='light'] .hljs-deletion,
            html[data-theme='light'] .hljs-number,
            html[data-theme='light'] .hljs-quote,
            html[data-theme='light'] .hljs-selector-class,
            html[data-theme='light'] .hljs-selector-id,
            html[data-theme='light'] .hljs-string,
            html[data-theme='light'] .hljs-template-tag,
            html[data-theme='light'] .hljs-type {
                color: #800;
            }
            html[data-theme='light'] .hljs-section,
            html[data-theme='light'] .hljs-title {
                color: #800;
                font-weight: 700;
            }
            html[data-theme='light'] .hljs-link,
            html[data-theme='light'] .hljs-operator,
            html[data-theme='light'] .hljs-regexp,
            html[data-theme='light'] .hljs-selector-attr,
            html[data-theme='light'] .hljs-selector-pseudo,
            html[data-theme='light'] .hljs-symbol,
            html[data-theme='light'] .hljs-template-variable,
            html[data-theme='light'] .hljs-variable {
                color: #ab5656;
            }
            html[data-theme='light'] .hljs-literal {
                color: #695;
            }
            html[data-theme='light'] .hljs-addition,
            html[data-theme='light'] .hljs-built_in,
            html[data-theme='light'] .hljs-bullet,
            html[data-theme='light'] .hljs-code {
                color: #397300;
            }
            html[data-theme='light'] .hljs-meta {
                color: #1f7199;
            }
            html[data-theme='light'] .hljs-meta .hljs-string {
                color: #38a;
            }
            html[data-theme='light'] .hljs-emphasis {
                font-style: italic;
            }
            html[data-theme='light'] .hljs-strong {
                font-weight: 700;
            }

            html[data-theme='dark'] {
                /*

  Dark style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org>

  */
            }
            html[data-theme='dark'] .hljs {
                color: #ddd;
                background: #303030;
            }
            html[data-theme='dark'] .hljs-keyword,
            html[data-theme='dark'] .hljs-selector-tag,
            html[data-theme='dark'] .hljs-literal,
            html[data-theme='dark'] .hljs-section,
            html[data-theme='dark'] .hljs-link {
                color: white;
            }
            html[data-theme='dark'] .hljs-subst {
                /* default */
            }
            html[data-theme='dark'] .hljs-string,
            html[data-theme='dark'] .hljs-title,
            html[data-theme='dark'] .hljs-name,
            html[data-theme='dark'] .hljs-type,
            html[data-theme='dark'] .hljs-attribute,
            html[data-theme='dark'] .hljs-symbol,
            html[data-theme='dark'] .hljs-bullet,
            html[data-theme='dark'] .hljs-built_in,
            html[data-theme='dark'] .hljs-addition,
            html[data-theme='dark'] .hljs-variable,
            html[data-theme='dark'] .hljs-template-tag,
            html[data-theme='dark'] .hljs-template-variable {
                color: #d88;
            }
            html[data-theme='dark'] .hljs-comment,
            html[data-theme='dark'] .hljs-quote,
            html[data-theme='dark'] .hljs-deletion,
            html[data-theme='dark'] .hljs-meta {
                color: #979797;
            }
            html[data-theme='dark'] .hljs-keyword,
            html[data-theme='dark'] .hljs-selector-tag,
            html[data-theme='dark'] .hljs-literal,
            html[data-theme='dark'] .hljs-title,
            html[data-theme='dark'] .hljs-section,
            html[data-theme='dark'] .hljs-doctag,
            html[data-theme='dark'] .hljs-type,
            html[data-theme='dark'] .hljs-name,
            html[data-theme='dark'] .hljs-strong {
                font-weight: bold;
            }
            html[data-theme='dark'] .hljs-emphasis {
                font-style: italic;
            }

            .rio-switcheroo-background {
                --rio-local-plain-bg: var(--rio-global-background-bg);
                --rio-local-plain-bg-variant: var(
                    --rio-global-background-bg-variant
                );
                --rio-local-plain-bg-active: var(
                    --rio-global-background-bg-active
                );
                --rio-local-accent-bg: var(--rio-global-secondary-bg);
                --rio-local-accent-fg: var(--rio-global-secondary-fg);
                --rio-local-heading1-color: var(--rio-global-heading1-color);
                --rio-local-heading1-background: var(
                    --rio-global-heading1-background
                );
                --rio-local-heading1-background-clip: var(
                    --rio-global-heading1-background-clip
                );
                --rio-local-heading1-fill-color: var(
                    --rio-global-heading1-fill-color
                );
                --rio-local-heading1-font-weight: var(
                    --rio-global-heading1-font-weight
                );
                --rio-local-heading2-color: var(--rio-global-heading2-color);
                --rio-local-heading2-background: var(
                    --rio-global-heading2-background
                );
                --rio-local-heading2-background-clip: var(
                    --rio-global-heading2-background-clip
                );
                --rio-local-heading2-fill-color: var(
                    --rio-global-heading2-fill-color
                );
                --rio-local-heading2-font-weight: var(
                    --rio-global-heading2-font-weight
                );
                --rio-local-heading3-color: var(--rio-global-heading3-color);
                --rio-local-heading3-background: var(
                    --rio-global-heading3-background
                );
                --rio-local-heading3-background-clip: var(
                    --rio-global-heading3-background-clip
                );
                --rio-local-heading3-fill-color: var(
                    --rio-global-heading3-fill-color
                );
                --rio-local-heading3-font-weight: var(
                    --rio-global-heading3-font-weight
                );
                --rio-local-text-color: var(--rio-global-text-color);
                --rio-local-text-background: var(--rio-global-text-background);
                --rio-local-text-background-clip: var(
                    --rio-global-text-background-clip
                );
                --rio-local-text-fill-color: var(--rio-global-text-fill-color);
                --rio-local-text-font-weight: var(
                    --rio-global-text-font-weight
                );
                --mdc-theme-primary: var(--rio-global-secondary-bg);
                --mdc-theme-background: var(--rio-global-background-bg);
                --mdc-theme-surface: var(--rio-global-neutral-bg);
                --mdc-theme-on-primary: var(--rio-global-secondary-fg);
                --mdc-theme-on-surface: var(--rio-global-background-fg);
                color: var(--rio-global-text-color);
            }

            .rio-switcheroo-neutral {
                --rio-local-plain-bg: var(--rio-global-neutral-bg);
                --rio-local-plain-bg-variant: var(
                    --rio-global-neutral-bg-variant
                );
                --rio-local-plain-bg-active: var(
                    --rio-global-neutral-bg-active
                );
                --rio-local-accent-bg: var(--rio-global-secondary-bg);
                --rio-local-accent-fg: var(--rio-global-secondary-fg);
                --rio-local-heading1-color: var(--rio-global-heading1-color);
                --rio-local-heading1-background: var(
                    --rio-global-heading1-background
                );
                --rio-local-heading1-background-clip: var(
                    --rio-global-heading1-background-clip
                );
                --rio-local-heading1-fill-color: var(
                    --rio-global-heading1-fill-color
                );
                --rio-local-heading2-color: var(--rio-global-heading2-color);
                --rio-local-heading2-background: var(
                    --rio-global-heading2-background
                );
                --rio-local-heading2-background-clip: var(
                    --rio-global-heading2-background-clip
                );
                --rio-local-heading2-fill-color: var(
                    --rio-global-heading2-fill-color
                );
                --rio-local-heading3-color: var(--rio-global-heading3-color);
                --rio-local-heading3-background: var(
                    --rio-global-heading3-background
                );
                --rio-local-heading3-background-clip: var(
                    --rio-global-heading3-background-clip
                );
                --rio-local-heading3-fill-color: var(
                    --rio-global-heading3-fill-color
                );
                --rio-local-text-color: var(--rio-global-text-color);
                --rio-local-text-background: var(--rio-global-text-background);
                --rio-local-text-background-clip: var(
                    --rio-global-text-background-clip
                );
                --rio-local-text-fill-color: var(--rio-global-text-fill-color);
                color: var(--rio-global-text-color);
            }

            .rio-switcheroo-hud {
                --rio-local-plain-bg: var(--rio-global-hud-bg);
                --rio-local-plain-bg-variant: var(--rio-global-hud-bg-variant);
                --rio-local-plain-bg-active: var(--rio-global-hud-bg-active);
                --rio-local-accent-bg: var(--rio-global-primary-bg);
                --rio-local-accent-fg: var(--rio-global-primary-fg);
                --rio-local-heading1-color: var(--rio-global-hud-fg);
                --rio-local-heading1-background: 'none';
                --rio-local-heading1-background-clip: 'border-box';
                --rio-local-heading1-fill-color: 'transparent';
                --rio-local-heading2-color: var(--rio-global-hud-fg);
                --rio-local-heading2-background: 'none';
                --rio-local-heading2-background-clip: 'border-box';
                --rio-local-heading2-fill-color: 'transparent';
                --rio-local-heading3-color: var(--rio-global-hud-fg);
                --rio-local-heading3-background: 'none';
                --rio-local-heading3-background-clip: 'border-box';
                --rio-local-heading3-fill-color: 'transparent';
                --rio-local-text-color: var(--rio-global-hud-fg);
                --rio-local-text-background: 'none';
                --rio-local-text-background-clip: 'border-box';
                --rio-local-text-fill-color: 'transparent';
                color: var(--rio-global-hud-fg);
            }

            .rio-switcheroo-primary {
                --rio-local-plain-bg: var(--rio-global-primary-bg);
                --rio-local-plain-bg-variant: var(
                    --rio-global-primary-bg-variant
                );
                --rio-local-plain-bg-active: var(
                    --rio-global-primary-bg-active
                );
                --rio-local-accent-bg: var(--rio-global-secondary-bg);
                --rio-local-accent-fg: var(--rio-global-secondary-fg);
                --rio-local-heading1-color: var(--rio-global-primary-fg);
                --rio-local-heading1-background: 'none';
                --rio-local-heading1-background-clip: 'border-box';
                --rio-local-heading1-fill-color: 'transparent';
                --rio-local-heading2-color: var(--rio-global-primary-fg);
                --rio-local-heading2-background: 'none';
                --rio-local-heading2-background-clip: 'border-box';
                --rio-local-heading2-fill-color: 'transparent';
                --rio-local-heading3-color: var(--rio-global-primary-fg);
                --rio-local-heading3-background: 'none';
                --rio-local-heading3-background-clip: 'border-box';
                --rio-local-heading3-fill-color: 'transparent';
                --rio-local-text-color: var(--rio-global-primary-fg);
                --rio-local-text-background: 'none';
                --rio-local-text-background-clip: 'border-box';
                --rio-local-text-fill-color: 'transparent';
                color: var(--rio-global-primary-fg);
            }

            .rio-switcheroo-secondary {
                --rio-local-plain-bg: var(--rio-global-secondary-bg);
                --rio-local-plain-bg-variant: var(
                    --rio-global-secondary-bg-variant
                );
                --rio-local-plain-bg-active: var(
                    --rio-global-secondary-bg-active
                );
                --rio-local-accent-bg: var(--rio-global-primary-bg);
                --rio-local-accent-fg: var(--rio-global-primary-fg);
                --rio-local-heading1-color: var(--rio-global-secondary-fg);
                --rio-local-heading1-background: 'none';
                --rio-local-heading1-background-clip: 'border-box';
                --rio-local-heading1-fill-color: 'transparent';
                --rio-local-heading2-color: var(--rio-global-secondary-fg);
                --rio-local-heading2-background: 'none';
                --rio-local-heading2-background-clip: 'border-box';
                --rio-local-heading2-fill-color: 'transparent';
                --rio-local-heading3-color: var(--rio-global-secondary-fg);
                --rio-local-heading3-background: 'none';
                --rio-local-heading3-background-clip: 'border-box';
                --rio-local-heading3-fill-color: 'transparent';
                --rio-local-text-color: var(--rio-global-secondary-fg);
                --rio-local-text-background: 'none';
                --rio-local-text-background-clip: 'border-box';
                --rio-local-text-fill-color: 'transparent';
                color: var(--rio-global-secondary-fg);
            }

            .rio-switcheroo-success {
                --rio-local-plain-bg: var(--rio-global-success-bg);
                --rio-local-plain-bg-variant: var(
                    --rio-global-success-bg-variant
                );
                --rio-local-plain-bg-active: var(
                    --rio-global-success-bg-active
                );
                --rio-local-accent-bg: var(--rio-global-secondary-bg);
                --rio-local-accent-fg: var(--rio-global-secondary-fg);
                --rio-local-heading1-color: var(--rio-global-success-fg);
                --rio-local-heading1-background: 'none';
                --rio-local-heading1-background-clip: 'border-box';
                --rio-local-heading1-fill-color: 'transparent';
                --rio-local-heading2-color: var(--rio-global-success-fg);
                --rio-local-heading2-background: 'none';
                --rio-local-heading2-background-clip: 'border-box';
                --rio-local-heading2-fill-color: 'transparent';
                --rio-local-heading3-color: var(--rio-global-success-fg);
                --rio-local-heading3-background: 'none';
                --rio-local-heading3-background-clip: 'border-box';
                --rio-local-heading3-fill-color: 'transparent';
                --rio-local-text-color: var(--rio-global-success-fg);
                --rio-local-text-background: 'none';
                --rio-local-text-background-clip: 'border-box';
                --rio-local-text-fill-color: 'transparent';
                color: var(--rio-global-success-fg);
            }

            .rio-switcheroo-warning {
                --rio-local-plain-bg: var(--rio-global-warning-bg);
                --rio-local-plain-bg-variant: var(
                    --rio-global-warning-bg-variant
                );
                --rio-local-plain-bg-active: var(
                    --rio-global-warning-bg-active
                );
                --rio-local-accent-bg: var(--rio-global-secondary-bg);
                --rio-local-accent-fg: var(--rio-global-secondary-fg);
                --rio-local-heading1-color: var(--rio-global-warning-fg);
                --rio-local-heading1-background: 'none';
                --rio-local-heading1-background-clip: 'border-box';
                --rio-local-heading1-fill-color: 'transparent';
                --rio-local-heading2-color: var(--rio-global-warning-fg);
                --rio-local-heading2-background: 'none';
                --rio-local-heading2-background-clip: 'border-box';
                --rio-local-heading2-fill-color: 'transparent';
                --rio-local-heading3-color: var(--rio-global-warning-fg);
                --rio-local-heading3-background: 'none';
                --rio-local-heading3-background-clip: 'border-box';
                --rio-local-heading3-fill-color: 'transparent';
                --rio-local-text-color: var(--rio-global-warning-fg);
                --rio-local-text-background: 'none';
                --rio-local-text-background-clip: 'border-box';
                --rio-local-text-fill-color: 'transparent';
                color: var(--rio-global-warning-fg);
            }

            .rio-switcheroo-danger {
                --rio-local-plain-bg: var(--rio-global-danger-bg);
                --rio-local-plain-bg-variant: var(
                    --rio-global-danger-bg-variant
                );
                --rio-local-plain-bg-active: var(--rio-global-danger-bg-active);
                --rio-local-accent-bg: var(--rio-global-secondary-bg);
                --rio-local-accent-fg: var(--rio-global-secondary-fg);
                --rio-local-heading1-color: var(--rio-global-danger-fg);
                --rio-local-heading1-background: 'none';
                --rio-local-heading1-background-clip: 'border-box';
                --rio-local-heading1-fill-color: 'transparent';
                --rio-local-heading2-color: var(--rio-global-danger-fg);
                --rio-local-heading2-background: 'none';
                --rio-local-heading2-background-clip: 'border-box';
                --rio-local-heading2-fill-color: 'transparent';
                --rio-local-heading3-color: var(--rio-global-danger-fg);
                --rio-local-heading3-background: 'none';
                --rio-local-heading3-background-clip: 'border-box';
                --rio-local-heading3-fill-color: 'transparent';
                --rio-local-text-color: var(--rio-global-danger-fg);
                --rio-local-text-background: 'none';
                --rio-local-text-background-clip: 'border-box';
                --rio-local-text-fill-color: 'transparent';
                color: var(--rio-global-danger-fg);
            }

            .rio-switcheroo-disabled {
                --rio-local-plain-bg: var(--rio-global-disabled-bg);
                --rio-local-accent-bg: var(--rio-global-disabled-bg);
                --rio-local-accent-fg: var(--rio-global-disabled-fg);
                --rio-local-heading1-color: var(--rio-global-disabled-fg);
                --rio-local-heading1-background: 'none';
                --rio-local-heading1-background-clip: 'border-box';
                --rio-local-heading1-fill-color: 'transparent';
                --rio-local-heading2-color: var(--rio-global-disabled-fg);
                --rio-local-heading2-background: 'none';
                --rio-local-heading2-background-clip: 'border-box';
                --rio-local-heading2-fill-color: 'transparent';
                --rio-local-heading3-color: var(--rio-global-disabled-fg);
                --rio-local-heading3-background: 'none';
                --rio-local-heading3-background-clip: 'border-box';
                --rio-local-heading3-fill-color: 'transparent';
                --rio-local-text-color: var(--rio-global-disabled-fg);
                --rio-local-text-background: 'none';
                --rio-local-text-background-clip: 'border-box';
                --rio-local-text-fill-color: 'transparent';
                color: var(--rio-global-disabled-fg);
            }

            .rio-switcheroo-custom {
                --rio-local-plain-bg: var(--rio-local-custom-plain-bg);
                --rio-local-plain-bg-variant: var(
                    --rio-local-custom-plain-bg-variant
                );
                --rio-local-plain-bg-active: var(
                    --rio-local-custom-plain-bg-active
                );
                --rio-local-accent-bg: var(--rio-local-custom-accent-bg);
                --rio-local-accent-fg: var(--rio-local-custom-accent-fg);
                --rio-local-heading1-color: var(--rio-local-custom-plain-fg);
                --rio-local-heading1-background: 'none';
                --rio-local-heading1-background-clip: 'border-box';
                --rio-local-heading1-fill-color: 'transparent';
                --rio-local-heading2-color: var(--rio-local-custom-plain-fg);
                --rio-local-heading2-background: 'none';
                --rio-local-heading2-background-clip: 'border-box';
                --rio-local-heading2-fill-color: 'transparent';
                --rio-local-heading3-color: var(--rio-local-custom-plain-fg);
                --rio-local-heading3-background: 'none';
                --rio-local-heading3-background-clip: 'border-box';
                --rio-local-heading3-fill-color: 'transparent';
                --rio-local-text-color: var(--rio-local-custom-plain-fg);
                --rio-local-text-background: 'none';
                --rio-local-text-background-clip: 'border-box';
                --rio-local-text-fill-color: 'transparent';
                color: var(--rio-local-custom-plain-fg);
            }

            .rio-switcheroo-accent-to-plain {
                --rio-local-plain-bg: var(--rio-local-accent-bg);
                --rio-local-text-color: var(--rio-local-accent-fg);
                color: var(--rio-local-accent-fg);
            }

            @keyframes content-loading {
                from {
                    background-position: -100rem 0;
                }
                to {
                    background-position: 0 0;
                }
            }
            .rio-content-loading {
                background-image: linear-gradient(
                    to right,
                    transparent 10%,
                    var(--rio-local-accent-bg) 12%,
                    transparent 14%
                );
                background-size: 100rem 5rem;
                animation: content-loading 3s linear infinite;
            }

            @keyframes barber-pole {
                from {
                    background-position: 0 0;
                }
                to {
                    background-position: 3rem 0rem;
                }
            }
            a {
                color: var(--rio-local-accent-bg);
            }

            code {
                font-family: var(--rio-global-monospace-font), monospace;
            }

            html {
                background: var(--rio-global-background-bg);
                overflow: hidden;
            }

            body {
                margin: 0;
                padding: 0;
                font-family: var(--rio-global-font, Roboto, sans-serif);
            }

            input,
            textarea,
            select {
                font-family: inherit;
                font-size: 1rem;
            }

            .rio-component {
                position: absolute;
            }

            .rio-fundamental-root-component {
                position: relative !important;
                width: 100vw;
                height: 100vh;
            }

            .rio-linear-child-container > * {
                position: relative !important;
            }

            .rio-list-view > .rio-linear-child-container > div > *:first-child {
                position: relative !important;
            }

            .rio-undefined-space {
                pointer-events: none;
                flex-grow: 1;
                background-image: linear-gradient(
                    -45deg,
                    var(--rio-global-warning-bg) 15%,
                    transparent 15%,
                    transparent 50%,
                    var(--rio-global-warning-bg) 50%,
                    var(--rio-global-warning-bg) 65%,
                    transparent 65%
                );
                background-size: 3rem 3rem;
                animation: barber-pole 1s linear infinite;
            }

            .rio-row {
                pointer-events: none;
                display: flex;
                align-items: stretch;
            }

            .rio-row > .rio-linear-child-container {
                display: flex;
                align-items: stretch;
            }

            .rio-column {
                pointer-events: none;
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }

            .rio-column > .rio-linear-child-container {
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }

            .rio-grid {
                pointer-events: none;
                display: grid;
            }

            .rio-text {
                pointer-events: auto;
                display: flex;
                align-items: center;
                color: var(--rio-local-text-color);
            }

            .rio-text > div {
                flex-grow: 1;
                overflow: hidden;
            }

            .rio-rectangle {
                pointer-events: auto;
                border-style: solid;
                transition-property: background, stroke-color, stroke-width,
                    border-radius, shadow-color, shadow-radius, shadow-offset;
                transition-timing-function: ease;
                background: var(--rio-rectangle-fill);
                border-color: var(--rio-rectangle-stroke_color);
                border-width: var(--rio-rectangle-stroke_width);
                border-radius: var(--rio-rectangle-corner_radius);
                box-shadow: var(--rio-rectangle-shadow_offset_x)
                    var(--rio-rectangle-shadow_offset_y)
                    var(--rio-rectangle-shadow_radius)
                    var(--rio-rectangle-shadow_color);
            }

            .rio-rectangle:hover {
                background: var(--rio-rectangle-hover-fill);
                border-color: var(--rio-rectangle-hover-stroke_color);
                border-width: var(--rio-rectangle-hover-stroke_width);
                border-radius: var(--rio-rectangle-hover-corner_radius);
                box-shadow: var(--rio-rectangle-hover-shadow_offset_x)
                    var(--rio-rectangle-hover-shadow_offset_y)
                    var(--rio-rectangle-hover-shadow_radius)
                    var(--rio-rectangle-hover-shadow_color);
            }

            .rio-rectangle-ripple {
                overflow: hidden;
                --mdc-ripple-fg-size: 0;
                --mdc-ripple-left: 0;
                --mdc-ripple-top: 0;
                --mdc-ripple-fg-scale: 1;
                --mdc-ripple-fg-translate-end: 0;
                --mdc-ripple-fg-translate-start: 0;
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                will-change: transform, opacity;
            }
            .rio-rectangle-ripple::before,
            .rio-rectangle-ripple::after {
                position: absolute;
                border-radius: 50%;
                opacity: 0;
                pointer-events: none;
                content: '';
            }
            .rio-rectangle-ripple::before {
                transition:
                    opacity 15ms linear,
                    background-color 15ms linear;
                z-index: 1;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 1);
            }
            .rio-rectangle-ripple::after {
                z-index: 0;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 0);
            }
            .rio-rectangle-ripple.mdc-ripple-upgraded::before {
                transform: scale(var(--mdc-ripple-fg-scale, 1));
            }
            .rio-rectangle-ripple.mdc-ripple-upgraded::after {
                top: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                transform: scale(0);
                transform-origin: center center;
            }
            .rio-rectangle-ripple.mdc-ripple-upgraded--unbounded::after {
                top: var(--mdc-ripple-top, 0);
                /* @noflip */ /*rtl:ignore*/
                left: var(--mdc-ripple-left, 0);
            }
            .rio-rectangle-ripple.mdc-ripple-upgraded--foreground-activation::after {
                animation:
                    mdc-ripple-fg-radius-in 225ms forwards,
                    mdc-ripple-fg-opacity-in 75ms forwards;
            }
            .rio-rectangle-ripple.mdc-ripple-upgraded--foreground-deactivation::after {
                animation: mdc-ripple-fg-opacity-out 150ms;
                transform: translate(var(--mdc-ripple-fg-translate-end, 0))
                    scale(var(--mdc-ripple-fg-scale, 1));
            }
            .rio-rectangle-ripple::before,
            .rio-rectangle-ripple::after {
                top: calc(50% - 100%);
                /* @noflip */ /*rtl:ignore*/
                left: calc(50% - 100%);
                width: 200%;
                height: 200%;
            }
            .rio-rectangle-ripple.mdc-ripple-upgraded::after {
                width: var(--mdc-ripple-fg-size, 100%);
                height: var(--mdc-ripple-fg-size, 100%);
            }
            .rio-rectangle-ripple::before,
            .rio-rectangle-ripple::after {
                background-color: #000;
                /* @alternate */
                background-color: var(--mdc-ripple-color, #000);
            }
            .rio-rectangle-ripple:hover::before,
            .rio-rectangle-ripple.mdc-ripple-surface--hover::before {
                opacity: 0.04;
                /* @alternate */
                opacity: var(--mdc-ripple-hover-opacity, 0.04);
            }
            .rio-rectangle-ripple.mdc-ripple-upgraded--background-focused::before,
            .rio-rectangle-ripple:not(.mdc-ripple-upgraded):focus::before {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-focus-opacity, 0.12);
            }
            .rio-rectangle-ripple:not(.mdc-ripple-upgraded)::after {
                transition: opacity 150ms linear;
            }
            .rio-rectangle-ripple:not(.mdc-ripple-upgraded):active::after {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-press-opacity, 0.12);
            }
            .rio-rectangle-ripple.mdc-ripple-upgraded {
                --mdc-ripple-fg-opacity: var(--mdc-ripple-press-opacity, 0.12);
            }

            .rio-text-input {
                cursor: text;
            }

            .rio-text-input-hint-text {
                display: flex;
                align-items: end;
                user-select: none;
                padding-bottom: 0.6rem;
                color: var(--rio-local-text-color);
                opacity: 0;
                transition: all 0.13s linear;
            }

            .rio-text-input-prefix-text {
                padding-left: 0.8rem;
                margin-right: 0.2rem;
            }

            .rio-text-input-suffix-text {
                padding-right: 0.8rem;
                margin-left: 0.2rem;
            }

            input:not(:placeholder-shown) ~ .rio-text-input-hint-text,
            .rio-input-box:focus-within > .rio-text-input-hint-text,
            .rio-input-box-focused > .rio-text-input-hint-text {
                opacity: 0.5;
            }

            .rio-text-input.rio-input-box {
                padding-left: 0 !important;
                padding-right: 0 !important;
            }

            .rio-input-box {
                pointer-events: auto;
                display: flex;
                flex-direction: row;
                align-items: stretch;
                padding-left: 0.8rem;
                padding-right: 0.8rem;
                box-sizing: border-box;
                background-color: var(--rio-local-plain-bg-variant);
                border-radius: var(--rio-global-corner-radius-small)
                    var(--rio-global-corner-radius-small) 0 0;
            }

            .rio-input-box:not(.rio-disabled-input) {
                overflow: hidden;
                --mdc-ripple-fg-size: 0;
                --mdc-ripple-left: 0;
                --mdc-ripple-top: 0;
                --mdc-ripple-fg-scale: 1;
                --mdc-ripple-fg-translate-end: 0;
                --mdc-ripple-fg-translate-start: 0;
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                will-change: transform, opacity;
            }
            .rio-input-box:not(.rio-disabled-input)::before,
            .rio-input-box:not(.rio-disabled-input)::after {
                position: absolute;
                border-radius: 50%;
                opacity: 0;
                pointer-events: none;
                content: '';
            }
            .rio-input-box:not(.rio-disabled-input)::before {
                transition:
                    opacity 15ms linear,
                    background-color 15ms linear;
                z-index: 1;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 1);
            }
            .rio-input-box:not(.rio-disabled-input)::after {
                z-index: 0;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 0);
            }
            .rio-input-box:not(
                    .rio-disabled-input
                ).mdc-ripple-upgraded::before {
                transform: scale(var(--mdc-ripple-fg-scale, 1));
            }
            .rio-input-box:not(.rio-disabled-input).mdc-ripple-upgraded::after {
                top: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                transform: scale(0);
                transform-origin: center center;
            }
            .rio-input-box:not(
                    .rio-disabled-input
                ).mdc-ripple-upgraded--unbounded::after {
                top: var(--mdc-ripple-top, 0);
                /* @noflip */ /*rtl:ignore*/
                left: var(--mdc-ripple-left, 0);
            }
            .rio-input-box:not(
                    .rio-disabled-input
                ).mdc-ripple-upgraded--foreground-activation::after {
                animation:
                    mdc-ripple-fg-radius-in 225ms forwards,
                    mdc-ripple-fg-opacity-in 75ms forwards;
            }
            .rio-input-box:not(
                    .rio-disabled-input
                ).mdc-ripple-upgraded--foreground-deactivation::after {
                animation: mdc-ripple-fg-opacity-out 150ms;
                transform: translate(var(--mdc-ripple-fg-translate-end, 0))
                    scale(var(--mdc-ripple-fg-scale, 1));
            }
            .rio-input-box:not(.rio-disabled-input)::before,
            .rio-input-box:not(.rio-disabled-input)::after {
                top: calc(50% - 100%);
                /* @noflip */ /*rtl:ignore*/
                left: calc(50% - 100%);
                width: 200%;
                height: 200%;
            }
            .rio-input-box:not(.rio-disabled-input).mdc-ripple-upgraded::after {
                width: var(--mdc-ripple-fg-size, 100%);
                height: var(--mdc-ripple-fg-size, 100%);
            }
            .rio-input-box:not(.rio-disabled-input)::before,
            .rio-input-box:not(.rio-disabled-input)::after {
                background-color: #000;
                /* @alternate */
                background-color: var(--mdc-ripple-color, #000);
            }
            .rio-input-box:not(.rio-disabled-input):hover::before,
            .rio-input-box:not(
                    .rio-disabled-input
                ).mdc-ripple-surface--hover::before {
                opacity: 0.04;
                /* @alternate */
                opacity: var(--mdc-ripple-hover-opacity, 0.04);
            }
            .rio-input-box:not(
                    .rio-disabled-input
                ).mdc-ripple-upgraded--background-focused::before,
            .rio-input-box:not(.rio-disabled-input):not(
                    .mdc-ripple-upgraded
                ):focus::before {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-focus-opacity, 0.12);
            }
            .rio-input-box:not(.rio-disabled-input):not(
                    .mdc-ripple-upgraded
                )::after {
                transition: opacity 150ms linear;
            }
            .rio-input-box:not(.rio-disabled-input):not(
                    .mdc-ripple-upgraded
                ):active::after {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-press-opacity, 0.12);
            }
            .rio-input-box:not(.rio-disabled-input).mdc-ripple-upgraded {
                --mdc-ripple-fg-opacity: var(--mdc-ripple-press-opacity, 0.12);
            }

            .rio-input-box:focus-within,
            .rio-input-box.rio-input-box-focused {
                outline: none;
                background-color: var(--rio-local-plain-bg-active);
            }

            .rio-input-box > input,
            .rio-input-box > textarea {
                flex-grow: 1;
                min-width: 0;
                background-color: transparent;
                color: var(--rio-local-text-color);
                caret-color: var(--rio-local-accent-bg);
                border: none;
            }

            .rio-input-box > input {
                height: calc(200% - 2.38rem);
            }

            .rio-input-box > textarea {
                margin-top: 1.5rem;
                width: 100%;
                resize: none;
                padding: 0 0.8rem;
            }

            .rio-input-box > input:active,
            .rio-input-box > textarea:active {
                background-color: transparent;
            }

            .rio-input-box > input:focus-visible,
            .rio-input-box > textarea:focus-visible {
                outline: none;
            }

            .rio-input-box-label {
                pointer-events: none;
                position: absolute;
                left: 0.8rem;
                top: calc(50% - 0.5rem);
                font-size: 1rem;
                color: var(--rio-local-text-color);
                opacity: 0.5;
                transition: all 0.13s linear;
            }

            input:not(:placeholder-shown) ~ .rio-input-box-label,
            textarea:not(:placeholder-shown) ~ .rio-input-box-label,
            .rio-input-box:focus-within > .rio-input-box-label,
            .rio-input-box-focused > .rio-input-box-label {
                opacity: 1;
                top: 0.4rem;
                bottom: unset;
                font-size: 0.8rem;
            }

            .rio-input-box:focus-within > .rio-input-box-label,
            .rio-input-box-focused > .rio-input-box-label {
                color: var(--rio-local-accent-bg);
            }

            .rio-input-box-plain-bar,
            .rio-input-box-color-bar {
                position: absolute;
                bottom: 0;
                height: 0.12rem;
            }

            .rio-input-box-plain-bar {
                background-color: var(--rio-local-text-color);
                left: 0;
                right: 0;
                opacity: 0.15;
            }

            .rio-input-box-color-bar {
                background-color: var(--rio-local-accent-bg);
                left: 40%;
                right: 40%;
                opacity: 0;
                transition: all 0.2s ease-in-out;
            }

            .rio-input-box:focus-within .rio-input-box-color-bar,
            .rio-input-box-focused .rio-input-box-color-bar {
                left: 0;
                right: 0;
                opacity: 1;
            }

            .rio-stack {
                pointer-events: none;
                display: inline-grid;
            }

            .rio-stack > * {
                grid-column-start: 1;
                grid-row-start: 1;
            }

            .rio-switch {
                display: flex;
            }

            .rio-switch > * {
                pointer-events: auto;
                position: relative;
                width: 3.18rem;
                height: 1.54rem;
                margin: auto;
                border-radius: 4.3rem;
                background-color: var(--rio-global-disabled-bg-variant);
                transition: 0.3s ease all;
                z-index: 1;
            }

            .rio-switch.is-on > * {
                background-color: var(--rio-local-accent-bg);
            }

            .rio-switch input {
                position: relative;
                width: 100%;
                height: 100%;
                padding: 0;
                margin: 0;
                opacity: 0;
                cursor: pointer;
                z-index: 3;
            }

            .rio-switch .knob {
                z-index: 2;
                position: absolute;
                top: 0.17rem;
                left: 0.17rem;
                width: 0.86rem;
                height: 0.43rem;
                padding: 0.39rem 0.17rem;
                background-color: var(--rio-global-disabled-bg);
                border-radius: 50%;
                transition:
                    0.3s ease all,
                    left 0.3s cubic-bezier(0.18, 0.89, 0.35, 1.15);
            }

            .rio-switch input:active + .knob {
                width: 1.98rem;
                border-radius: 4.3rem;
            }

            .rio-switch.is-on input:active + .knob {
                margin-left: -1.12rem;
            }

            .rio-switch.is-on input + .knob {
                left: 1.8rem;
                background-color: var(--rio-local-plain-bg);
            }

            .rio-dropdown {
                pointer-events: auto;
            }
            .rio-dropdown,
            .rio-dropdown > input {
                cursor: pointer;
            }

            .rio-dropdown-popup {
                position: absolute;
                z-index: 10003;
                height: 0;
                max-height: 100vh;
                background-color: var(--rio-global-background-bg);
                color: var(--rio-global-text-color);
                border-radius: 0 0 var(--rio-global-corner-radius-small)
                    var(--rio-global-corner-radius-small);
                box-shadow: 0 0 0.8rem var(--rio-global-shadow-color);
                transition: height 0.2s ease-in-out;
            }

            .rio-dropdown-popup-above {
                border-radius: var(--rio-global-corner-radius-small) !important;
            }

            .rio-dropdown.rio-input-box > .rio-dropdown-arrow {
                pointer-events: none;
                order: 2;
                display: flex;
                align-items: center;
            }
            .rio-dropdown.rio-input-box > .rio-dropdown-arrow svg {
                width: 1.3rem;
                height: 1.3rem;
            }

            .rio-dropdown-option-highlight {
                font-weight: bold;
                color: var(--rio-local-accent-bg);
            }

            .rio-dropdown-options {
                position: relative;
                display: flex;
                flex-direction: column;
                align-items: stretch;
                cursor: pointer;
            }

            .rio-dropdown-options > div {
                position: relative;
            }

            .rio-dropdown-options > svg {
                position: relative;
                width: 4rem;
                height: 4rem;
                margin: 1.5rem auto;
                opacity: 0.2;
            }

            .rio-dropdown-option::after {
                content: '';
                pointer-events: none;
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: var(--rio-global-primary-bg);
                opacity: 0;
                transition: opacity 0.1s ease-in-out;
            }

            .rio-dropdown-option-highlighted::after {
                opacity: 0.2;
            }

            .rio-progress-circle {
                pointer-events: auto;
                stroke: var(--rio-local-plain-bg);
                display: flex;
                justify-content: center;
                overflow: hidden;
            }

            .rio-progress-circle circle {
                fill: none;
                stroke-width: 3.5;
                color: var(--rio-local-accent-bg);
            }

            .spinning svg {
                transform-origin: center;
                animation: rotate 2s linear infinite;
            }

            .spinning .progress {
                stroke-dasharray: 1, 200;
                stroke-dashoffset: 0;
                stroke-linecap: round;
                animation: dash 1.5s ease-in-out infinite;
            }

            .rio-progress-circle:not(.spinning) .progress {
                stroke-dashoffset: -94.25;
                stroke-dasharray: var(--dasharray);
                transition: stroke-dasharray 0.5s ease;
            }

            @keyframes rotate {
                100% {
                    transform: rotate(360deg);
                }
            }
            @keyframes dash {
                0% {
                    stroke-dasharray: 1, 200;
                    stroke-dashoffset: 0;
                }
                50% {
                    stroke-dasharray: 90, 200;
                    stroke-dashoffset: -35px;
                }
                100% {
                    stroke-dashoffset: -125px;
                }
            }
            .rio-button {
                --outer-text-color: var(--rio-local-text-color);
            }

            .rio-button > * {
                width: 100%;
                height: 100%;
                pointer-events: auto;
                overflow: hidden;
                transition:
                    background-color 0.1s ease-in-out,
                    color 0.1s ease-in-out,
                    border-color 0.1s ease-in-out;
            }

            .rio-button:not(.rio-switcheroo-disabled) > * {
                --mdc-ripple-fg-size: 0;
                --mdc-ripple-left: 0;
                --mdc-ripple-top: 0;
                --mdc-ripple-fg-scale: 1;
                --mdc-ripple-fg-translate-end: 0;
                --mdc-ripple-fg-translate-start: 0;
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                will-change: transform, opacity;
            }
            .rio-button:not(.rio-switcheroo-disabled) > *::before,
            .rio-button:not(.rio-switcheroo-disabled) > *::after {
                position: absolute;
                border-radius: 50%;
                opacity: 0;
                pointer-events: none;
                content: '';
            }
            .rio-button:not(.rio-switcheroo-disabled) > *::before {
                transition:
                    opacity 15ms linear,
                    background-color 15ms linear;
                z-index: 1;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 1);
            }
            .rio-button:not(.rio-switcheroo-disabled) > *::after {
                z-index: 0;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 0);
            }
            .rio-button:not(.rio-switcheroo-disabled)
                > *.mdc-ripple-upgraded::before {
                transform: scale(var(--mdc-ripple-fg-scale, 1));
            }
            .rio-button:not(.rio-switcheroo-disabled)
                > *.mdc-ripple-upgraded::after {
                top: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                transform: scale(0);
                transform-origin: center center;
            }
            .rio-button:not(.rio-switcheroo-disabled)
                > *.mdc-ripple-upgraded--unbounded::after {
                top: var(--mdc-ripple-top, 0);
                /* @noflip */ /*rtl:ignore*/
                left: var(--mdc-ripple-left, 0);
            }
            .rio-button:not(.rio-switcheroo-disabled)
                > *.mdc-ripple-upgraded--foreground-activation::after {
                animation:
                    mdc-ripple-fg-radius-in 225ms forwards,
                    mdc-ripple-fg-opacity-in 75ms forwards;
            }
            .rio-button:not(.rio-switcheroo-disabled)
                > *.mdc-ripple-upgraded--foreground-deactivation::after {
                animation: mdc-ripple-fg-opacity-out 150ms;
                transform: translate(var(--mdc-ripple-fg-translate-end, 0))
                    scale(var(--mdc-ripple-fg-scale, 1));
            }
            .rio-button:not(.rio-switcheroo-disabled) > *::before,
            .rio-button:not(.rio-switcheroo-disabled) > *::after {
                top: calc(50% - 100%);
                /* @noflip */ /*rtl:ignore*/
                left: calc(50% - 100%);
                width: 200%;
                height: 200%;
            }
            .rio-button:not(.rio-switcheroo-disabled)
                > *.mdc-ripple-upgraded::after {
                width: var(--mdc-ripple-fg-size, 100%);
                height: var(--mdc-ripple-fg-size, 100%);
            }
            .rio-button:not(.rio-switcheroo-disabled) > *::before,
            .rio-button:not(.rio-switcheroo-disabled) > *::after {
                background-color: #000;
                /* @alternate */
                background-color: var(--mdc-ripple-color, #000);
            }
            .rio-button:not(.rio-switcheroo-disabled) > *:hover::before,
            .rio-button:not(.rio-switcheroo-disabled)
                > *.mdc-ripple-surface--hover::before {
                opacity: 0.04;
                /* @alternate */
                opacity: var(--mdc-ripple-hover-opacity, 0.04);
            }
            .rio-button:not(.rio-switcheroo-disabled)
                > *.mdc-ripple-upgraded--background-focused::before,
            .rio-button:not(.rio-switcheroo-disabled)
                > *:not(.mdc-ripple-upgraded):focus::before {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-focus-opacity, 0.12);
            }
            .rio-button:not(.rio-switcheroo-disabled)
                > *:not(.mdc-ripple-upgraded)::after {
                transition: opacity 150ms linear;
            }
            .rio-button:not(.rio-switcheroo-disabled)
                > *:not(.mdc-ripple-upgraded):active::after {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-press-opacity, 0.12);
            }
            .rio-button:not(.rio-switcheroo-disabled) > *.mdc-ripple-upgraded {
                --mdc-ripple-fg-opacity: var(--mdc-ripple-press-opacity, 0.12);
            }

            .rio-buttonstyle-major {
                background: var(--rio-local-plain-bg);
                box-shadow: 0 0 0 transparent;
                transition: box-shadow 0.2s ease-in-out;
            }

            .rio-buttonstyle-major:hover:not(.rio-switcheroo-disabled) {
                background: var(--rio-local-plain-bg);
                cursor: pointer;
                box-shadow: 0 0.1rem 0.22rem rgba(0, 0, 0, 0.35);
            }

            .rio-buttonstyle-minor:not(:hover) {
                outline: 0.1rem solid var(--rio-local-plain-bg);
                --rio-local-text-color: var(--rio-local-plain-bg);
            }

            .rio-buttonstyle-minor:hover:not(.rio-switcheroo-disabled) {
                background: var(--rio-local-plain-bg);
                cursor: pointer;
            }

            .rio-buttonstyle-plain {
                --rio-local-text-color: var(--outer-text-color);
            }

            .rio-buttonstyle-plain:hover:not(.rio-switcheroo-disabled) {
                cursor: pointer;
                --rio-local-text-color: var(--rio-local-plain-bg);
            }

            .rio-shape-pill {
                border-radius: 99999px;
            }

            .rio-shape-rounded {
                border-radius: var(--rio-global-corner-radius-small);
            }

            .rio-shape-rectangle {
                border-radius: 0;
            }

            .rio-shape-circle {
                border-radius: 50%;
            }

            .rio-revealer {
                display: flex;
                flex-direction: column;
                align-items: stretch;
                justify-content: stretch;
                border-radius: var(--rio-global-corner-radius-small);
                transition: background-color 0.15s ease-out;
            }

            .rio-revealer-header {
                pointer-events: auto;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: space-between;
                color: var(--rio-local-text-color);
            }

            .rio-revealer-label {
                flex-grow: 1;
            }

            .rio-revealer-arrow {
                transform: rotate(90deg);
                transition: transform 0.25s ease-in-out;
            }

            .rio-revealer-open .rio-revealer-arrow {
                transform: rotate(0deg);
            }

            .rio-revealer-content-outer {
                flex-grow: 1;
                position: relative;
                overflow: hidden;
            }

            .rio-revealer-content-inner {
                position: absolute;
                bottom: 0;
                opacity: 0;
                transform: translateY(-50%);
                transition:
                    opacity 0.45s ease-in-out,
                    transform 0.35s ease;
            }

            .rio-revealer-open .rio-revealer-content-inner {
                opacity: 1;
                transform: translateY(0%);
            }

            .rio-revealer-content-inner > * {
                position: relative !important;
            }

            .rio-plot {
                display: inline-block;
                display: flex;
                justify-content: center;
                align-items: center;
                overflow: hidden;
            }

            .rio-icon {
                pointer-events: auto;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .rio-slideshow {
                pointer-events: auto;
                overflow: hidden;
            }

            .slideshow-child-container {
                position: relative;
                display: grid;
                width: 100%;
                height: 100%;
            }

            .slideshow-child-container > div {
                grid-column-start: 1;
                grid-row-start: 1;
                width: 100%;
                height: 100%;
            }

            .slideshow-child-container > div > * {
                grid-column-start: 1;
                grid-row-start: 1;
                width: 100%;
                height: 100%;
            }

            .slideshow-progress {
                position: absolute;
                bottom: 0;
                width: 100%;
                height: 0.3rem;
                background-color: var(--rio-local-accent-bg);
            }

            .rio-overlay {
                pointer-events: none;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: unset !important;
                height: unset !important;
                z-index: 10000;
            }

            .rio-spacer {
                pointer-events: none;
            }

            .rio-media-player {
                pointer-events: auto;
            }

            .rio-media-player video {
                pointer-events: none;
                width: 100%;
                height: 100%;
                object-fit: contain;
            }

            .rio-media-player-alt-display {
                pointer-events: none;
                position: absolute;
                left: 50%;
                top: 50%;
                width: 50%;
                height: 50%;
                max-width: 20rem;
                max-height: 20rem;
                aspect-ratio: 1;
                opacity: 0.5;
                transform: translate(-50%, -50%);
            }

            .rio-media-player-controls {
                position: absolute;
                left: 0;
                bottom: 0;
                right: 0;
                background: linear-gradient(
                    rgba(0, 0, 0, 0),
                    rgba(0, 0, 0, 0.6)
                );
                padding-top: 2.5rem;
                display: flex;
                flex-direction: column;
                gap: 0rem;
                align-items: stretch;
                transition: opacity 0.4s ease-in-out;
            }

            .rio-media-player-timeline {
                pointer-events: auto;
                cursor: pointer;
                position: relative;
                height: 2rem;
                margin: 0 0.5rem;
            }

            .rio-media-player-timeline > div {
                pointer-events: none;
                position: relative;
                top: 50%;
                height: 0.2rem;
                transform: translateY(-50%);
                transition: height 0.2s ease-in-out;
            }

            .rio-media-player-timeline:hover > div {
                height: 0.4rem;
            }

            .rio-media-player-timeline-knob {
                position: absolute;
                width: 0rem;
                height: 0rem;
                left: 100%;
                top: 50%;
                background-color: var(--rio-global-primary-bg);
                border-radius: 50%;
                transform: translate(-50%, -50%);
                transition:
                    width 0.2s ease-in-out,
                    height 0.2s ease-in-out;
            }

            .rio-media-player-timeline:hover .rio-media-player-timeline-knob {
                width: 0.9rem;
                height: 0.9rem;
            }

            .rio-media-player-timeline-background,
            .rio-media-player-timeline-loaded,
            .rio-media-player-timeline-hover,
            .rio-media-player-timeline-played {
                position: absolute;
                width: 0%;
                height: 100%;
                background-color: white;
                border-radius: 99999px;
            }

            .rio-media-player-timeline-background {
                width: 100%;
                opacity: 0.2;
            }

            .rio-media-player-timeline-loaded {
                opacity: 0.3;
            }

            .rio-media-player-timeline-hover {
                opacity: 0;
                transition: opacity 0.2s ease-in-out;
            }

            .rio-media-player-timeline-played {
                background-color: var(--rio-global-primary-bg);
            }

            .rio-media-player-controls-row {
                display: flex;
                gap: 1.2rem;
                align-items: center;
                padding: 0.5rem;
                padding-top: 0;
            }

            .rio-media-player-button {
                pointer-events: auto;
                cursor: pointer;
                width: 2rem;
                height: 2rem;
            }

            .rio-media-player-button > img {
                width: 100%;
                height: 100%;
            }

            .rio-media-player-volume {
                pointer-events: auto;
                cursor: pointer;
                position: relative;
                width: 5rem;
                height: 1.5rem;
            }

            .rio-media-player-volume > div {
                pointer-events: none;
                position: relative;
                top: 50%;
                height: 0.2rem;
                transform: translateY(-50%);
            }

            .rio-media-player-volume-background,
            .rio-media-player-volume-current {
                position: absolute;
                width: 100%;
                height: 100%;
                border-radius: 99999px;
                background-color: white;
            }

            .rio-media-player-volume-background {
                opacity: 0.2;
            }

            .rio-media-player-volume-knob {
                position: absolute;
                width: 0.9rem;
                height: 0.9rem;
                left: 100%;
                top: 50%;
                background-color: white;
                border-radius: 50%;
                transform: translate(-50%, -50%);
            }

            .rio-media-player-volume > div {
                position: relative;
                top: 50%;
                height: 0.2rem;
                transform: translateY(-50%);
            }

            .rio-media-player-playtime-label {
                color: white;
                opacity: 0.6;
            }

            .rio-markdown-view {
                pointer-events: auto;
                --rio-padding: calc(
                    0.5rem + var(--rio-global-corner-radius-small)
                );
                color: var(--rio-local-text-color);
            }
            .rio-markdown-view ul {
                margin: 0;
                padding-left: 1rem;
                list-style-type: none;
            }
            .rio-markdown-view ul > li {
                margin-bottom: 0.4rem;
            }
            .rio-markdown-view ul > li:before {
                content: '- ';
                font-weight: bold;
            }
            .rio-markdown-view p code {
                font-family: var(--rio-global-monospace-font), monospace;
                background: var(--rio-local-plain-bg-variant);
                border-radius: var(--rio-global-corner-radius-small);
                padding: 0.1rem 0.3rem;
            }
            .rio-markdown-view h1 {
                font-family: var(--rio-global-heading1-font-name);
                color: var(--rio-local-heading1-color);
                font-size: var(--rio-global-heading1-font-size);
                font-style: var(--rio-global-heading1-italic);
                font-weight: var(--rio-global-heading1-font-weight);
                text-decoration: var(--rio-global-heading1-underlined);
                text-transform: var(--rio-global-heading1-all-caps);
                margin-top: 0;
            }
            .rio-markdown-view h1 :not(:first-child) {
                margin-top: 2rem;
            }
            .rio-markdown-view h2 {
                font-family: var(--rio-global-heading2-font-name);
                color: var(--rio-local-heading2-color);
                font-size: var(--rio-global-heading2-font-size);
                font-style: var(--rio-global-heading2-italic);
                font-weight: var(--rio-global-heading2-font-weight);
                text-decoration: var(--rio-global-heading2-underlined);
                text-transform: var(--rio-global-heading2-all-caps);
                margin-top: 0;
            }
            .rio-markdown-view h2 :not(:first-child) {
                margin-top: 1.5rem;
            }
            .rio-markdown-view h3 {
                font-family: var(--rio-global-heading3-font-name);
                color: var(--rio-local-heading3-color);
                font-size: var(--rio-global-heading3-font-size);
                font-style: var(--rio-global-heading3-italic);
                font-weight: var(--rio-global-heading3-font-weight);
                text-decoration: var(--rio-global-heading3-underlined);
                text-transform: var(--rio-global-heading3-all-caps);
                margin-top: 0;
            }
            .rio-markdown-view h3 :not(:first-child) {
                margin-top: 1rem;
            }
            .rio-markdown-view p {
                font-family: var(--rio-global-font);
                color: var(--rio-local-text-color);
                font-size: var(--rio-global-text-font-size);
                font-style: var(--rio-global-text-italic);
                font-weight: var(--rio-global-text-font-weight);
                text-decoration: var(--rio-global-text-underlined);
                text-transform: var(--rio-global-text-all-caps);
            }

            .rio-markdown-view > * {
                position: relative;
                top: 0;
                left: 0;
            }

            .rio-markdown-view > *:first-child {
                margin-top: 0 !important;
            }

            .rio-markdown-view > *:last-child {
                margin-bottom: 0 !important;
            }

            .rio-markdown-code-block {
                background: var(--rio-local-plain-bg-variant);
                border-radius: var(--rio-global-corner-radius-small);
            }

            .rio-markdown-code-block-header {
                display: flex;
                flex-direction: row;
                justify-content: space-between;
                color: var(--rio-local-text-color);
                padding: var(--rio-padding);
                gap: var(--rio-padding);
            }

            .rio-markdown-code-block-language {
                font-weight: bold;
                opacity: 0.4;
            }

            .rio-markdown-code-block-copy-button {
                min-width: 1.2rem;
                min-height: 1.2rem;
                cursor: pointer;
                border: none;
                background: none;
                border-radius: var(--rio-global-corner-radius-small);
                margin: 0;
                padding: 0;
                opacity: 0.4;
                transition: opacity 0.2s ease-in-out;
            }

            .rio-markdown-code-block-copy-button:hover {
                color: var(--rio-local-accent-bg);
                opacity: 1;
            }

            .rio-markdown-code-block > code {
                font-size: 1rem;
                display: block;
                padding: 0 var(--rio-padding) var(--rio-padding)
                    var(--rio-padding);
            }

            .rio-link {
                pointer-events: auto;
                display: block;
            }

            .rio-text-link {
                color: var(--rio-local-accent-bg);
                cursor: pointer;
            }

            .rio-scroll-container {
                pointer-events: auto;
            }

            .rio-color-picker {
                pointer-events: none;
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }

            .rio-color-picker-color-square {
                pointer-events: auto;
                position: relative;
                min-height: 6rem;
                cursor: crosshair;
                margin-bottom: 0.7rem;
                border-radius: var(--rio-global-corner-radius-small);
                flex-grow: 1;
            }

            .rio-color-picker-slider-outer {
                pointer-events: auto;
                position: relative;
                padding: 0.7rem 0;
            }

            .rio-color-slider-inner {
                height: 0.9rem;
                cursor: crosshair;
                border-radius: 99999px;
            }

            .rio-color-picker-knob {
                pointer-events: none;
                cursor: crosshair;
                width: 1.4rem;
                height: 1.4rem;
                border-radius: 50%;
                border: 0.2rem solid var(--rio-local-text-color);
                position: absolute;
                transform: translate(-50%, -50%);
                box-sizing: border-box;
                background: var(--chosen-color-opaque);
            }

            .rio-color-picker-slider-outer > .rio-color-picker-knob {
                top: 50%;
            }

            .color-slider-checkers {
                border-radius: 99999px;
            }

            .rio-color-picker-hue-bar > .rio-color-slider-inner {
                background: linear-gradient(
                    to right,
                    red,
                    yellow,
                    lime,
                    aqua,
                    blue,
                    magenta,
                    red
                );
            }

            .rio-color-picker-opacity-bar
                > .rio-color-slider-inner:not(.rio-checkered) {
                position: absolute;
                top: 0.7rem;
                left: 0;
                right: 0;
                bottom: 0.7rem;
                background: linear-gradient(
                    to right,
                    transparent,
                    var(--chosen-color-opaque)
                );
            }

            .rio-color-picker-result-container {
                margin-top: 0.5rem;
                margin-left: auto;
                margin-right: auto;
                display: flex;
                align-items: center;
                gap: 0.8rem;
            }

            .rio-color-picker-selected-color-circle {
                position: relative;
                width: 2.5rem;
                height: 2.5rem;
            }

            .rio-color-picker-selected-color-circle > * {
                width: 100%;
                height: 100%;
                border-radius: 50%;
                box-sizing: border-box;
                border: 0.2rem solid var(--rio-local-text-color);
            }

            .rio-color-picker-selected-color-circle > div:first-child {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: var(--chosen-color-transparent);
            }

            .rio-color-picker-selected-color-circle-color {
                background: var(--chosen-color-transparent);
            }

            .rio-color-picker-selected-color-label {
                pointer-events: auto;
                opacity: 0.5;
                /* Fixed width to avoid movement when the value changes */
                width: 5rem;
                /* Text style */
                color: var(--rio-local-text-color);
                font-family: Roboto, sans-serif;
                font-size: 0.9rem;
                text-align: center;
                font-weight: bold;
                /* Override the default styling */
                background: transparent;
                border: none;
                padding: 0.3rem;
                border-radius: 0.5rem;
                transition:
                    opacity 0.1s ease-in-out,
                    color 0.1s ease-in-out,
                    background-color 0.1s ease-in-out;
            }

            .rio-color-picker-selected-color-label:focus {
                outline: none;
                opacity: 1;
                color: var(--rio-local-accent-bg);
                background: var(--rio-local-plain-bg-variant);
            }

            .rio-checkered {
                --checker-color: #888;
                --checker-size: 0.9rem;
                background-image: linear-gradient(
                        45deg,
                        var(--checker-color) 25%,
                        transparent 25%
                    ),
                    linear-gradient(
                        45deg,
                        transparent 75%,
                        var(--checker-color) 75%
                    ),
                    linear-gradient(
                        45deg,
                        transparent 75%,
                        var(--checker-color) 75%
                    ),
                    linear-gradient(
                        45deg,
                        var(--checker-color) 25%,
                        transparent 25%
                    );
                background-size: var(--checker-size) var(--checker-size);
                background-position:
                    0 0,
                    0 0,
                    calc(var(--checker-size) * -0.5)
                        calc(var(--checker-size) * -0.5),
                    calc(var(--checker-size) * 0.5)
                        calc(var(--checker-size) * 0.5);
            }

            .rio-drawer {
                pointer-events: auto;
                overflow: hidden;
                display: flex;
                align-items: stretch;
            }

            .rio-drawer-shade {
                pointer-events: none;
                position: absolute;
                left: 0;
                top: 0;
                right: 0;
                bottom: 0;
                transition: background-color 0.5s ease-in-out;
            }

            .rio-drawer-anchor {
                pointer-events: none;
                flex-grow: 1;
            }

            .rio-drawer-content-outer {
                pointer-events: auto;
                display: flex;
                position: absolute;
                background-color: var(--rio-global-neutral-bg);
                box-shadow: 0 0 1rem var(--rio-global-shadow-color);
                transition: transform 0.5s ease-out;
            }

            .rio-drawer-content-inner {
                order: 1;
            }

            .rio-drawer-content-inner > * {
                position: relative !important;
            }

            .rio-drawer-knob {
                align-self: center;
                margin: 0.5rem;
                border-radius: 99999px;
                background: var(--rio-local-text-color);
                opacity: 0.15;
            }

            .rio-drawer-left .rio-drawer-knob,
            .rio-drawer-right .rio-drawer-knob {
                width: 0.4rem;
                height: 4rem;
            }

            .rio-drawer-top .rio-drawer-knob,
            .rio-drawer-bottom .rio-drawer-knob {
                width: 4rem;
                height: 0.4rem;
            }
            .rio-drawer-top .rio-drawer-content-outer,
            .rio-drawer-bottom .rio-drawer-content-outer {
                flex-direction: column;
            }

            .rio-drawer-left .rio-drawer-knob,
            .rio-drawer-top .rio-drawer-knob {
                order: 2;
            }

            .rio-drawer-right .rio-drawer-knob,
            .rio-drawer-bottom .rio-drawer-knob {
                order: 0;
            }

            .rio-drawer-left > .rio-drawer-content-outer {
                top: 0;
                left: 0;
                bottom: 0;
                width: fit-content;
                border-radius: 0 var(--rio-global-corner-radius-large)
                    var(--rio-global-corner-radius-large) 0;
            }

            .rio-drawer-right > .rio-drawer-content-outer {
                top: 0;
                right: 0;
                bottom: 0;
                width: fit-content;
                border-radius: var(--rio-global-corner-radius-large) 0 0
                    var(--rio-global-corner-radius-large);
            }

            .rio-drawer-top > .rio-drawer-content-outer {
                left: 0;
                top: 0;
                right: 0;
                height: fit-content;
                border-radius: 0 0 var(--rio-global-corner-radius-large)
                    var(--rio-global-corner-radius-large);
            }

            .rio-drawer-bottom > .rio-drawer-content-outer {
                left: 0;
                bottom: 0;
                right: 0;
                height: fit-content;
                border-radius: var(--rio-global-corner-radius-large)
                    var(--rio-global-corner-radius-large) 0 0;
            }

            .rio-drawer-no-transition {
                transition: none !important;
            }

            .rio-drawer-no-transition > * {
                transition: none !important;
            }

            .rio-popup {
                z-index: 10003;
            }

            .rio-popup-anchor > *,
            .rio-popup-content > * {
                position: relative !important;
            }

            .rio-popup-content {
                position: fixed;
                width: min-content;
                height: min-content;
                background-color: var(--rio-local-plain-bg);
                border-radius: var(--rio-global-corner-radius-medium);
                box-shadow: 0 0 1rem var(--rio-global-shadow-color);
                transform: scale(0);
                opacity: 0;
                transition:
                    transform 0.2s linear,
                    opacity 0.1s ease-in-out;
            }

            .rio-popup-open > .rio-popup-content {
                transform: scale(1);
                opacity: 1;
                transition:
                    transform 0.2s cubic-bezier(0.5, 0.5, 0.2, 1.14),
                    opacity 0.1s ease-in-out;
            }

            .rio-image {
                pointer-events: auto;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .rio-image img {
                width: 100%;
                height: 100%;
                object-fit: contain;
            }
            .rio-image svg {
                max-width: 3rem;
            }

            .rio-card {
                pointer-events: auto;
                background-color: var(--rio-local-plain-bg);
                box-shadow: 0 0 0 var(--rio-global-shadow-color);
                transition:
                    box-shadow 0.15s ease-out,
                    background-color 0.15s ease-out;
            }

            .rio-card-elevate-on-hover:hover {
                box-shadow: 0 0.15rem 0.3rem var(--rio-global-shadow-color);
            }

            .rio-card-colorize-on-hover:hover {
                background-color: var(--rio-local-plain-bg-active);
            }

            .rio-switcher-bar {
                display: flex;
                align-items: center;
            }

            .rio-switcher-bar > div {
                position: relative;
            }

            .rio-switcher-bar > div > .rio-switcher-bar-options {
                position: relative !important;
            }

            .rio-switcher-bar-options {
                pointer-events: auto;
                position: absolute;
                display: flex;
                align-items: stretch;
                justify-content: space-between;
            }

            .rio-switcher-bar-option {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: space-between;
                cursor: pointer;
                overflow: hidden;
                border-radius: var(--rio-global-corner-radius-large);
                color: var(--rio-local-text-color);
                --mdc-ripple-fg-size: 0;
                --mdc-ripple-left: 0;
                --mdc-ripple-top: 0;
                --mdc-ripple-fg-scale: 1;
                --mdc-ripple-fg-translate-end: 0;
                --mdc-ripple-fg-translate-start: 0;
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                will-change: transform, opacity;
            }
            .rio-switcher-bar-option::before,
            .rio-switcher-bar-option::after {
                position: absolute;
                border-radius: 50%;
                opacity: 0;
                pointer-events: none;
                content: '';
            }
            .rio-switcher-bar-option::before {
                transition:
                    opacity 15ms linear,
                    background-color 15ms linear;
                z-index: 1;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 1);
            }
            .rio-switcher-bar-option::after {
                z-index: 0;
                /* @alternate */
                z-index: var(--mdc-ripple-z-index, 0);
            }
            .rio-switcher-bar-option.mdc-ripple-upgraded::before {
                transform: scale(var(--mdc-ripple-fg-scale, 1));
            }
            .rio-switcher-bar-option.mdc-ripple-upgraded::after {
                top: 0;
                /* @noflip */ /*rtl:ignore*/
                left: 0;
                transform: scale(0);
                transform-origin: center center;
            }
            .rio-switcher-bar-option.mdc-ripple-upgraded--unbounded::after {
                top: var(--mdc-ripple-top, 0);
                /* @noflip */ /*rtl:ignore*/
                left: var(--mdc-ripple-left, 0);
            }
            .rio-switcher-bar-option.mdc-ripple-upgraded--foreground-activation::after {
                animation:
                    mdc-ripple-fg-radius-in 225ms forwards,
                    mdc-ripple-fg-opacity-in 75ms forwards;
            }
            .rio-switcher-bar-option.mdc-ripple-upgraded--foreground-deactivation::after {
                animation: mdc-ripple-fg-opacity-out 150ms;
                transform: translate(var(--mdc-ripple-fg-translate-end, 0))
                    scale(var(--mdc-ripple-fg-scale, 1));
            }
            .rio-switcher-bar-option::before,
            .rio-switcher-bar-option::after {
                top: calc(50% - 100%);
                /* @noflip */ /*rtl:ignore*/
                left: calc(50% - 100%);
                width: 200%;
                height: 200%;
            }
            .rio-switcher-bar-option.mdc-ripple-upgraded::after {
                width: var(--mdc-ripple-fg-size, 100%);
                height: var(--mdc-ripple-fg-size, 100%);
            }
            .rio-switcher-bar-option::before,
            .rio-switcher-bar-option::after {
                background-color: #000;
                /* @alternate */
                background-color: var(--mdc-ripple-color, #000);
            }
            .rio-switcher-bar-option:hover::before,
            .rio-switcher-bar-option.mdc-ripple-surface--hover::before {
                opacity: 0.04;
                /* @alternate */
                opacity: var(--mdc-ripple-hover-opacity, 0.04);
            }
            .rio-switcher-bar-option.mdc-ripple-upgraded--background-focused::before,
            .rio-switcher-bar-option:not(.mdc-ripple-upgraded):focus::before {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-focus-opacity, 0.12);
            }
            .rio-switcher-bar-option:not(.mdc-ripple-upgraded)::after {
                transition: opacity 150ms linear;
            }
            .rio-switcher-bar-option:not(.mdc-ripple-upgraded):active::after {
                transition-duration: 75ms;
                opacity: 0.12;
                /* @alternate */
                opacity: var(--mdc-ripple-press-opacity, 0.12);
            }
            .rio-switcher-bar-option.mdc-ripple-upgraded {
                --mdc-ripple-fg-opacity: var(--mdc-ripple-press-opacity, 0.12);
            }

            .rio-switcher-bar-option > div {
                margin-left: auto;
                margin-right: auto;
                white-space: nowrap;
            }

            .rio-switcher-bar-marker {
                pointer-events: none;
                background: var(--rio-local-plain-bg);
                overflow: hidden;
                position: absolute;
                left: 0;
                top: 0;
                border-radius: var(--rio-global-corner-radius-large);
            }

            .rio-table {
                pointer-events: auto;
                display: grid;
            }
            .rio-table > * {
                padding: 0.5rem 0.8rem;
            }
            .rio-table .header {
                display: flex;
                cursor: pointer;
            }
            .rio-table .header::after {
                content: '▴';
                display: inline-block;
                margin-left: 0.3rem;
                opacity: 0;
            }
            .rio-table .header[data-sort='ascending']::after {
                content: '▴';
                opacity: 1;
            }
            .rio-table .header[data-sort='descending']::after {
                content: '▾';
                opacity: 1;
            }

            .rio-list-view {
                pointer-events: none;
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }

            .rio-heading-list-item {
                pointer-events: none;
                box-sizing: border-box;
            }

            .rio-listview-grouped {
                pointer-events: auto;
                background-color: var(--rio-local-plain-bg-variant);
                transition: background-color 0.1s ease-out;
            }

            .rio-listview-grouped + .rio-listview-grouped::after {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 1px;
                background-color: var(--rio-local-text-color);
                opacity: 0.2;
            }

            .rio-flow-container {
                display: flex;
                flex-wrap: wrap;
            }

            .rio-flow-container > * {
                transition:
                    left 0.2s ease-out,
                    top 0.2s ease-out;
            }

            .mdc-linear-progress__bar-inner {
                height: 100%;
                background-color: var(--mdc-theme-primary);
            }

            .rio-connection-lost-popup {
                pointer-events: none;
                position: fixed;
                left: 0;
                top: 0;
                width: 100vw;
                height: 100vh;
                z-index: 10004;
                background-color: transparent;
                transition: background-color 1s ease-in-out;
            }

            .rio-connection-lost-popup.rio-connection-lost-popup-visible {
                display: flex;
                align-items: stretch;
                background-color: rgba(0, 0, 0, 0.5);
            }

            .rio-connection-lost-popup > * {
                position: absolute;
                flex-grow: 1;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                opacity: 0;
                transform: translateY(-5rem);
                transition:
                    opacity 0.3s ease-in-out,
                    transform 0.3s cubic-bezier(0.5, 0.5, 0.2, 1.14);
            }

            .rio-connection-lost-popup.rio-connection-lost-popup-visible > * {
                opacity: 1;
                transform: translateY(0);
            }

            .rio-traceback {
                pointer-events: auto;
                position: relative;
                left: 50%;
                top: 5rem;
                width: fit-content;
                max-width: 50rem;
                padding: 2.2rem;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                align-items: stretch;
                gap: 1.5rem;
                border-radius: var(--rio-global-corner-radius-large);
                box-shadow: 0 0.4rem 1rem var(--rio-global-shadow-color);
                transform: translateX(-50%);
            }

            .rio-traceback-header {
                display: flex;
                align-items: center;
                gap: 0.6rem;
            }

            .rio-traceback-header > svg {
                width: 2.5rem;
                height: 2.5rem;
                fill: var(--rio-global-danger-bg);
            }

            .rio-traceback-header > div {
                flex-grow: 1;
                text-align: left;
                font-size: 1.8rem;
                color: var(--rio-global-danger-bg);
            }

            .rio-traceback-traceback {
                font-family: var(--rio-global-monospace-font), monospace;
                font-size: 0.9rem;
                white-space: pre-wrap;
                overflow-wrap: break-word;
                padding: 0.5rem 1rem;
                background-color: var(--rio-local-plain-bg-variant);
                border-radius: var(--rio-global-corner-radius-small);
            }

            .rio-traceback-footer {
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
            }

            .rio-traceback-footer-links {
                display: flex;
                flex-direction: row;
                gap: 0.5rem;
                justify-content: space-between;
            }

            .rio-traceback-footer > a {
                flex: 1;
            }

            .rio-traceback-bold {
                font-weight: bold;
            }

            .rio-traceback-dim {
                opacity: 0.5;
            }

            .rio-traceback-red {
                color: var(--rio-global-danger-bg);
            }

            .rio-traceback-yellow {
                color: var(--rio-global-warning-bg);
            }

            .rio-debugger {
                background: var(--rio-global-background-bg);
                z-index: 10002;
            }

            .rio-debugger-navigation-rio-logo {
                pointer-events: auto;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: end;
                gap: 0.35rem;
                z-index: 2;
                text-decoration: none;
            }
            .rio-debugger-navigation-rio-logo img {
                width: 2.5rem;
                height: 2.5rem;
                object-fit: contain;
            }
            .rio-debugger-navigation-rio-logo div {
                margin-bottom: 1rem;
                font-size: 1.2rem;
                color: var(--rio-local-text-color);
                transition: color 1s ease-in-out;
            }
            .rio-debugger-navigation-rio-logo:hover div {
                color: var(--rio-global-secondary-fg);
                transition: color 0.1s ease-in-out;
            }

            .rio-debugger-navigation-rio-logo::before {
                content: '';
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
                z-index: -1;
                background: linear-gradient(
                    to top,
                    var(--rio-global-secondary-bg),
                    transparent
                );
                opacity: 0;
                transition: opacity 1s ease-out;
            }

            .rio-debugger-navigation-rio-logo:hover::before {
                opacity: 1;
                transition: opacity 0.1s ease-out;
            }

            .rio-debugger-tree-component-tree {
                overflow: auto;
            }

            .rio-debugger-tree-component-tree > * {
                position: absolute;
                width: 100%;
                height: 100%;
                overflow-x: hidden;
                overflow-y: auto;
            }

            .rio-debugger-component-tree-item {
                display: flex;
                flex-direction: column;
                gap: 0.2rem;
            }

            @keyframes flash-text {
                0% {
                    color: initial;
                }
                20% {
                    color: var(--rio-global-warning-bg);
                }
                100% {
                    color: initial;
                }
            }
            .rio-debugger-component-tree-flash {
                animation: flash-text 3s linear;
            }

            .rio-debugger-component-tree-item-header {
                pointer-events: auto;
                cursor: pointer;
                z-index: 1;
                position: relative;
                padding: 0.3rem 0.6rem;
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 0.5rem;
            }

            .rio-debugger-component-tree-item
                > .rio-debugger-component-tree-item-header
                > div:first-child {
                width: 1rem;
                height: 1rem;
                transition: transform 0.1s ease-in-out;
            }

            .rio-debugger-component-tree-item[data-expanded='true']
                > .rio-debugger-component-tree-item-header
                > div:first-child {
                transform: rotate(90deg);
            }

            .rio-debugger-component-tree-item-header::after {
                pointer-events: none;
                content: '';
                display: block;
                z-index: -1;
                position: absolute;
                left: 0;
                top: 0;
                right: 0;
                bottom: 0;
                background: var(--rio-global-secondary-bg);
                border-radius: 99999px;
                opacity: 0;
                transition: opacity 0.1s ease-in-out;
            }

            .rio-debugger-component-tree-item-header > div > svg {
                width: 1rem;
                height: 1rem;
            }

            .rio-debugger-component-tree-item-header-weakly-selected {
                font-weight: bold;
            }

            .rio-debugger-component-tree-item-header-strongly-selected {
                font-weight: bold;
                color: var(--rio-global-secondary-fg);
            }

            .rio-debugger-component-tree-item-header:hover::after {
                opacity: 0.4;
            }

            .rio-debugger-component-tree-item-header-weakly-selected::after {
                opacity: 0.15;
            }

            .rio-debugger-component-tree-item-header-strongly-selected::after {
                opacity: 0.6;
            }

            .rio-debugger-component-tree-item-header-strongly-selected:hover::after {
                opacity: 0.8;
            }

            .rio-debugger-component-tree-item-children {
                margin-left: 0.7rem;
                display: none;
                flex-direction: column;
                gap: 0.2rem;
            }

            .rio-debugger-component-tree-item[data-has-children='true'][data-expanded='true']
                > .rio-debugger-component-tree-item-children {
                display: flex;
            }

            .rio-debugger-component-highlighter {
                pointer-events: none;
                position: fixed;
                z-index: 10001;
                transition:
                    left 0.3s ease-in-out,
                    top 0.3s ease-in-out,
                    width 0.3s ease-in-out,
                    height 0.3s ease-in-out;
            }

            @keyframes pulse {
                0% {
                    left: -0.3rem;
                    top: -0.3rem;
                    right: -0.3rem;
                    bottom: -0.3rem;
                    border-width: 0.4rem;
                }
                50% {
                    left: -0.7rem;
                    top: -0.7rem;
                    right: -0.7rem;
                    bottom: -0.7rem;
                    border-width: 0.3rem;
                }
                100% {
                    left: -0.3rem;
                    top: -0.3rem;
                    right: -0.3rem;
                    bottom: -0.3rem;
                    border-width: 0.4rem;
                }
            }
            .rio-debugger-component-highlighter::after {
                content: '';
                position: absolute;
                display: block;
                border-radius: 1rem;
                box-shadow: 0 0 0 9999rem rgba(0, 0, 0, 0.6);
                border-style: solid;
                border-color: var(--rio-global-secondary-bg);
                animation: pulse 1.4s infinite;
            }

            .rio-debugger-background {
                z-index: -1;
                position: relative;
                background: var(--rio-local-plain-bg);
            }

            .rio-debugger-background::after {
                content: '';
                position: absolute;
                display: block;
                z-index: -1;
                left: 0;
                top: 0;
                bottom: 0;
                right: 0;
                background-image: linear-gradient(
                    -45deg,
                    var(--rio-local-plain-bg) 25%,
                    var(--rio-global-secondary-bg) 25%,
                    var(--rio-global-secondary-bg) 50%,
                    var(--rio-local-plain-bg) 50%,
                    var(--rio-local-plain-bg) 75%,
                    var(--rio-global-secondary-bg) 75%,
                    var(--rio-global-secondary-bg)
                );
                background-size: 3rem 3rem;
                opacity: 0.03;
            }

            .rio-switcher {
                overflow: hidden;
            }

            .rio-tooltip {
                pointer-events: none;
                position: relative;
            }

            .rio-tooltip-anchor {
                pointer-events: auto;
                position: relative;
            }

            .rio-tooltip-anchor > *,
            .rio-tooltip-label > * {
                position: relative !important;
            }

            .rio-tooltip-label {
                position: absolute;
                width: max-content;
                padding: 0.5rem;
                border-radius: var(--rio-global-corner-radius-small);
                background: var(--rio-global-hud-bg);
                box-shadow: 0 0.1rem 0.2rem var(--rio-global-shadow-color);
                opacity: 0;
                transition: opacity 0.15s ease-in-out;
            }

            .rio-build-failed {
                pointer-events: auto;
                color: var(--rio-global-danger-fg);
                display: flex;
                flex-direction: column;
                align-items: stretch;
                background: var(--rio-global-danger-bg);
                border-radius: var(--rio-global-corner-radius-small);
                overflow: hidden;
                background-image: linear-gradient(
                    -45deg,
                    var(--rio-global-danger-bg-variant) 15%,
                    transparent 15%,
                    transparent 50%,
                    var(--rio-global-danger-bg-variant) 50%,
                    var(--rio-global-danger-bg-variant) 65%,
                    transparent 65%
                );
                background-size: 3rem 3rem;
                animation: barber-pole 1s linear infinite;
            }

            .rio-build-failed-top,
            .rio-build-failed-bottom {
                flex-grow: 1;
            }

            .rio-build-failed-top {
                background: linear-gradient(
                    to top,
                    var(--rio-global-danger-bg),
                    var(--rio-global-danger-bg) 30%,
                    transparent
                );
            }

            .rio-build-failed-bottom {
                background: linear-gradient(
                    to bottom,
                    var(--rio-global-danger-bg),
                    var(--rio-global-danger-bg) 30%,
                    transparent
                );
            }

            .rio-build-failed-content {
                padding: 1rem;
                display: flex;
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
                background: var(--rio-global-danger-bg);
            }

            .rio-build-failed-header {
                align-self: center;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .rio-build-failed-icon {
                width: 2rem;
                height: 2rem;
            }

            .rio-build-failed-summary {
                font-weight: bold;
            }

            .rio-build-failed-details {
                align-self: center;
            }

            .rio-code-explorer {
                pointer-events: auto;
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            .rio-code-explorer-source-code {
                display: block;
                cursor: text;
                white-space: pre;
                font-size: 1rem;
                font-family: var(--rio-global-monospace-font), monospace;
                position: relative;
                min-width: 25rem;
                width: min-content;
                background: var(--rio-local-plain-bg-variant);
                border-radius: var(--rio-global-corner-radius-medium);
            }

            .rio-code-explorer-build-result {
                position: relative;
            }

            .rio-code-explorer-build-result
                > *:not(.rio-code-explorer-highlighter) {
                position: relative !important;
            }

            .rio-code-explorer-highlighter {
                pointer-events: none;
                position: absolute;
                opacity: 0;
                transition:
                    opacity 0.3s ease-in-out,
                    left 0.3s ease-in-out,
                    top 0.3s ease-in-out,
                    width 0.3s ease-in-out,
                    height 0.3s ease-in-out;
            }

            .rio-code-explorer-highlighter::after {
                content: '';
                z-index: 10001;
                position: absolute;
                border-radius: 1rem;
                border-style: solid;
                border-width: 0.2rem !important;
                border-color: var(--rio-global-secondary-bg);
                box-shadow: 0 0 4rem 1rem var(--rio-global-secondary-bg);
                opacity: 0.4;
                animation: pulse 1.4s infinite;
            }

            .rio-separator {
                position: relative;
                background-color: var(--rio-local-plain-bg);
            }

            .rio-separator::after {
                content: '';
                position: absolute;
                left: 0;
                top: 0;
                right: 0;
                bottom: 0;
                background-color: var(--separator-color);
                opacity: var(--separator-opacity);
            }
        </style>
    </head>

    <body class="rio-switcheroo-background"></body>
</html>
